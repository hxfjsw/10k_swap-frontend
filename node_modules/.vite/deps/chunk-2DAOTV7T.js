import {
  require_minimalistic_assert
} from "./chunk-KSVBIC6C.js";
import {
  require_bn
} from "./chunk-Q5BQ6LHN.js";
import {
  __commonJS
} from "./chunk-S5KM4IGW.js";

// node_modules/starknet/dist/utils/encode.js
var require_encode = __commonJS({
  "node_modules/starknet/dist/utils/encode.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.utf8ToArray = exports.sanitizeHex = exports.sanitizeBytes = exports.calcByteLength = exports.padLeft = exports.addHexPrefix = exports.removeHexPrefix = exports.buf2hex = exports.btoaUniversal = exports.arrayBufferToString = exports.IS_BROWSER = void 0;
    exports.IS_BROWSER = typeof window !== "undefined";
    var STRING_ZERO = "0";
    function arrayBufferToString(array) {
      return new Uint8Array(array).reduce(function(data, byte) {
        return data + String.fromCharCode(byte);
      }, "");
    }
    exports.arrayBufferToString = arrayBufferToString;
    function btoaUniversal(b) {
      return exports.IS_BROWSER ? btoa(arrayBufferToString(b)) : Buffer.from(b).toString("base64");
    }
    exports.btoaUniversal = btoaUniversal;
    function buf2hex(buffer) {
      return __spreadArray([], __read(buffer), false).map(function(x) {
        return x.toString(16).padStart(2, "0");
      }).join("");
    }
    exports.buf2hex = buf2hex;
    function removeHexPrefix(hex) {
      return hex.replace(/^0x/, "");
    }
    exports.removeHexPrefix = removeHexPrefix;
    function addHexPrefix(hex) {
      return "0x".concat(removeHexPrefix(hex));
    }
    exports.addHexPrefix = addHexPrefix;
    function padString(str, length, left, padding) {
      if (padding === void 0) {
        padding = STRING_ZERO;
      }
      var diff = length - str.length;
      var result = str;
      if (diff > 0) {
        var pad = padding.repeat(diff);
        result = left ? pad + str : str + pad;
      }
      return result;
    }
    function padLeft(str, length, padding) {
      if (padding === void 0) {
        padding = STRING_ZERO;
      }
      return padString(str, length, true, padding);
    }
    exports.padLeft = padLeft;
    function calcByteLength(length, byteSize) {
      if (byteSize === void 0) {
        byteSize = 8;
      }
      var remainder = length % byteSize;
      return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
    }
    exports.calcByteLength = calcByteLength;
    function sanitizeBytes(str, byteSize, padding) {
      if (byteSize === void 0) {
        byteSize = 8;
      }
      if (padding === void 0) {
        padding = STRING_ZERO;
      }
      return padLeft(str, calcByteLength(str.length, byteSize), padding);
    }
    exports.sanitizeBytes = sanitizeBytes;
    function sanitizeHex(hex) {
      hex = removeHexPrefix(hex);
      hex = sanitizeBytes(hex, 2);
      if (hex) {
        hex = addHexPrefix(hex);
      }
      return hex;
    }
    exports.sanitizeHex = sanitizeHex;
    function utf8ToArray(str) {
      return new TextEncoder().encode(str);
    }
    exports.utf8ToArray = utf8ToArray;
  }
});

// node_modules/starknet/dist/utils/number.js
var require_number = __commonJS({
  "node_modules/starknet/dist/utils/number.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bigNumberishArrayToDecimalStringArray = exports.assertInRange = exports.toFelt = exports.hexToDecimalString = exports.toHex = exports.toBN = exports.isHex = void 0;
    var bn_js_1 = __importStar(require_bn());
    var minimalistic_assert_1 = __importDefault(require_minimalistic_assert());
    var encode_1 = require_encode();
    function isHex(hex) {
      return hex.startsWith("0x");
    }
    exports.isHex = isHex;
    function toBN(number, base) {
      if (typeof number === "string" && isHex(number) && !base)
        return new bn_js_1.default((0, encode_1.removeHexPrefix)(number), "hex");
      return new bn_js_1.default(number, base);
    }
    exports.toBN = toBN;
    function toHex(number) {
      return (0, encode_1.addHexPrefix)(number.toString("hex"));
    }
    exports.toHex = toHex;
    function hexToDecimalString(hex) {
      return toBN("0x".concat(hex.replace(/^0x/, ""))).toString();
    }
    exports.hexToDecimalString = hexToDecimalString;
    function toFelt(num) {
      if ((0, bn_js_1.isBN)(num)) {
        return num.toString();
      }
      return toBN(num).toString();
    }
    exports.toFelt = toFelt;
    function assertInRange(input, lowerBound, upperBound, inputName) {
      if (inputName === void 0) {
        inputName = "";
      }
      var messageSuffix = inputName === "" ? "invalid length" : "invalid ".concat(inputName, " length");
      var inputBn = toBN(input);
      (0, minimalistic_assert_1.default)(inputBn.gte(toBN(lowerBound)) && inputBn.lt(toBN(upperBound)), "Message not signable, ".concat(messageSuffix, "."));
    }
    exports.assertInRange = assertInRange;
    function bigNumberishArrayToDecimalStringArray(rawCalldata) {
      return rawCalldata.map(function(x) {
        return toBN(x).toString(10);
      });
    }
    exports.bigNumberishArrayToDecimalStringArray = bigNumberishArrayToDecimalStringArray;
  }
});

// node_modules/starknet/dist/utils/uint256.js
var require_uint256 = __commonJS({
  "node_modules/starknet/dist/utils/uint256.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bnToUint256 = exports.isUint256 = exports.UINT_256_MAX = exports.UINT_128_MAX = exports.uint256ToBN = void 0;
    var encode_1 = require_encode();
    var number_1 = require_number();
    function uint256ToBN(uint256) {
      return (0, number_1.toBN)(uint256.high).shln(128).add((0, number_1.toBN)(uint256.low));
    }
    exports.uint256ToBN = uint256ToBN;
    exports.UINT_128_MAX = (0, number_1.toBN)(1).shln(128).sub((0, number_1.toBN)(1));
    exports.UINT_256_MAX = (0, number_1.toBN)(1).shln(256).sub((0, number_1.toBN)(1));
    function isUint256(bn) {
      return (0, number_1.toBN)(bn).lte(exports.UINT_256_MAX);
    }
    exports.isUint256 = isUint256;
    function bnToUint256(bignumber) {
      var bn = (0, number_1.toBN)(bignumber);
      if (!isUint256(bn))
        throw new Error("Number is too large");
      return {
        low: (0, encode_1.addHexPrefix)(bn.maskn(128).toString(16)),
        high: (0, encode_1.addHexPrefix)(bn.shrn(128).toString(16))
      };
    }
    exports.bnToUint256 = bnToUint256;
  }
});

export {
  require_encode,
  require_number,
  require_uint256
};
//# sourceMappingURL=chunk-2DAOTV7T.js.map
