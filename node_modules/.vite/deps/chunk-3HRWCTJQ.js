import {
  require_encode,
  require_number,
  require_uint256
} from "./chunk-2DAOTV7T.js";
import {
  require_elliptic,
  require_hash,
  require_keccak
} from "./chunk-GP6BPR6O.js";
import {
  require_minimalistic_assert
} from "./chunk-KSVBIC6C.js";
import {
  init_lib2 as init_lib,
  lib_exports
} from "./chunk-77IFFSE7.js";
import {
  require_bn
} from "./chunk-Q5BQ6LHN.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-S5KM4IGW.js";

// node_modules/url-join/lib/url-join.js
var require_url_join = __commonJS({
  "node_modules/url-join/lib/url-join.js"(exports, module) {
    (function(name, context, definition) {
      if (typeof module !== "undefined" && module.exports)
        module.exports = definition();
      else if (typeof define === "function" && define.amd)
        define(definition);
      else
        context[name] = definition();
    })("urljoin", exports, function() {
      function normalize(strArray) {
        var resultArray = [];
        if (strArray.length === 0) {
          return "";
        }
        if (typeof strArray[0] !== "string") {
          throw new TypeError("Url must be a string. Received " + strArray[0]);
        }
        if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
          var first = strArray.shift();
          strArray[0] = first + strArray[0];
        }
        if (strArray[0].match(/^file:\/\/\//)) {
          strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1:///");
        } else {
          strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1://");
        }
        for (var i = 0; i < strArray.length; i++) {
          var component = strArray[i];
          if (typeof component !== "string") {
            throw new TypeError("Url must be a string. Received " + component);
          }
          if (component === "") {
            continue;
          }
          if (i > 0) {
            component = component.replace(/^[\/]+/, "");
          }
          if (i < strArray.length - 1) {
            component = component.replace(/[\/]+$/, "");
          } else {
            component = component.replace(/[\/]+$/, "/");
          }
          resultArray.push(component);
        }
        var str = resultArray.join("/");
        str = str.replace(/\/(\?|&|#[^!])/g, "$1");
        var parts = str.split("?");
        str = parts.shift() + (parts.length > 0 ? "?" : "") + parts.join("&");
        return str;
      }
      return function() {
        var input;
        if (typeof arguments[0] === "object") {
          input = arguments[0];
        } else {
          input = [].slice.call(arguments);
        }
        return normalize(input);
      };
    });
  }
});

// node_modules/starknet/dist/constants.js
var require_constants = __commonJS({
  "node_modules/starknet/dist/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CONSTANT_POINTS = exports.MAX_ECDSA_VAL = exports.BETA = exports.ALPHA = exports.EC_ORDER = exports.FIELD_SIZE = exports.FIELD_GEN = exports.FIELD_PRIME = exports.TransactionHashPrefix = exports.StarknetChainId = exports.MASK_251 = exports.MASK_250 = exports.TWO = exports.ONE = exports.ZERO = exports.IS_BROWSER = void 0;
    var number_1 = require_number();
    var encode_1 = require_encode();
    Object.defineProperty(exports, "IS_BROWSER", { enumerable: true, get: function() {
      return encode_1.IS_BROWSER;
    } });
    exports.ZERO = (0, number_1.toBN)(0);
    exports.ONE = (0, number_1.toBN)(1);
    exports.TWO = (0, number_1.toBN)(2);
    exports.MASK_250 = exports.TWO.pow((0, number_1.toBN)(250)).sub(exports.ONE);
    exports.MASK_251 = exports.TWO.pow((0, number_1.toBN)(251));
    var StarknetChainId;
    (function(StarknetChainId2) {
      StarknetChainId2["MAINNET"] = "0x534e5f4d41494e";
      StarknetChainId2["TESTNET"] = "0x534e5f474f45524c49";
    })(StarknetChainId = exports.StarknetChainId || (exports.StarknetChainId = {}));
    var TransactionHashPrefix;
    (function(TransactionHashPrefix2) {
      TransactionHashPrefix2["DECLARE"] = "0x6465636c617265";
      TransactionHashPrefix2["DEPLOY"] = "0x6465706c6f79";
      TransactionHashPrefix2["INVOKE"] = "0x696e766f6b65";
      TransactionHashPrefix2["L1_HANDLER"] = "0x6c315f68616e646c6572";
    })(TransactionHashPrefix = exports.TransactionHashPrefix || (exports.TransactionHashPrefix = {}));
    exports.FIELD_PRIME = "800000000000011000000000000000000000000000000000000000000000001";
    exports.FIELD_GEN = "3";
    exports.FIELD_SIZE = 251;
    exports.EC_ORDER = "800000000000010FFFFFFFFFFFFFFFFB781126DCAE7B2321E66A241ADC64D2F";
    exports.ALPHA = "1";
    exports.BETA = "6F21413EFBE40DE150E596D72F7A8C5609AD26C15C915C1F4CDFCB99CEE9E89";
    exports.MAX_ECDSA_VAL = "800000000000000000000000000000000000000000000000000000000000000";
    exports.CONSTANT_POINTS = [
      [
        "49ee3eba8c1600700ee1b87eb599f16716b0b1022947733551fde4050ca6804",
        "3ca0cfe4b3bc6ddf346d49d06ea0ed34e621062c0e056c1d0405d266e10268a"
      ],
      [
        "1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca",
        "5668060aa49730b7be4801df46ec62de53ecd11abe43a32873000c36e8dc1f"
      ],
      [
        "234287dcbaffe7f969c748655fca9e58fa8120b6d56eb0c1080d17957ebe47b",
        "3b056f100f96fb21e889527d41f4e39940135dd7a6c94cc6ed0268ee89e5615"
      ],
      [
        "3909690e1123c80678a7ba0fde0e8447f6f02b3f6b960034d1e93524f8b476",
        "7122e9063d239d89d4e336753845b76f2b33ca0d7f0c1acd4b9fe974994cc19"
      ],
      [
        "40fd002e38ea01a01b2702eb7c643e9decc2894cbf31765922e281939ab542c",
        "109f720a79e2a41471f054ca885efd90c8cfbbec37991d1b6343991e0a3e740"
      ],
      [
        "2f52066635c139fc2f64eb0bd5e3fd7a705f576854ec4f00aa60361fddb981b",
        "6d78a24d8a5f97fc600318ce16b3c840315979c3273078ec1a285f217ee6a26"
      ],
      [
        "6a0767a1fd60d5b9027a35af1b68e57a1c366ebcde2006cdd07af27043ef674",
        "606b72c0ca0498b8c1817ed7922d550894c324f5efdfc85a19a1ae382411ca2"
      ],
      [
        "7fa463ee2a2d6a585d5c3358918270f6c28c66df1f86803374d1edf3819cc62",
        "a996edf01598832e644e1cae9a37288865ad80e2787f9bf958aceccc99afae"
      ],
      [
        "3d4da70d1540da597dbae1651d28487604a4e66a4a1823b97e8e9639393dbec",
        "45cdef70c35d3b6f0a2273a9886ccb6306d813e8204bdfd30b4efee63c8a3f9"
      ],
      [
        "1e448fdbcd9896c6fbf5f36cb7e7fcb77a751ff2d942593cae023363cc7750e",
        "30c81da0f3a8cb64468eaa491c7ae7b4842b62cb4148820da211afc4caffb3a"
      ],
      [
        "6531acf1a7cb90a4eb27de0b7f915e387a3b0fd063ba6e1289b91f48411be26",
        "31330f5daa091889981a3ea782ae997f5f171336ed0487a03f051551a2cafa2"
      ],
      [
        "54be016394d5662d67d7e82f5e889ed2f97ccf95d911f57dd2362c4040ed4f4",
        "c6cb184053f054d6a59c1bf0986d17090d25089b3fdcdaf185edc87ef113e5"
      ],
      [
        "35b9ecd0499ca1d5d42dcbb0c6b4042b3733c64b607ca711e706e786ef2afc6",
        "5624b476a5b21c3a544f0712d4817b06ad380a5a6529d323bf64da8ef862d8d"
      ],
      [
        "4ce0378e3ee8f77ed58f2ddbd8bb7676c8a38bfb1d3694c275254bd8ca38e23",
        "5a16fcbff0769c9cf2b02c31621878ec819fff4b8231bff82c6183db2746820"
      ],
      [
        "648d5c6f98680a1b926bfeb01c00224c56fdcf751b251c4449c8a94f425cfcf",
        "72c05ac793cd1620a833fbe2214d36900ebe446e095c62fcb740937f98cca8c"
      ],
      [
        "bd09be3e4e1af8a14189977e334f097c18e4a8bf42577ef5aafa0f807bd89b",
        "6e0e72ed7eb65c86cee29c411fb4761122558ee81013344ba8509c49de9f9b6"
      ],
      [
        "35ea4e339b44ae7724419bdfbe07022253137a4afb7cbaffad341ea61249357",
        "3665d676a026a174f367bb4417780e53a7803cb02d0db32eb4545c267c42f14"
      ],
      [
        "36457bc744f42e697b825c2d1afd8f4029d696a4514710f81da52d88e178643",
        "7c93715896735492a68c7969a024b3a8fd538bffc1521538107de1a5f13ce9c"
      ],
      [
        "5b3a08ebcf9c109cc9082f70d9df2b9c11b5428ee23917b4e790c4c10f6e661",
        "9d7b42ab0c20f5510df7ea5e196eec99342739077e9a168198c89da859753"
      ],
      [
        "21883ef8580fc06e59481955d52ece3aca6e82c8c9fc58e216dcf46f96990c6",
        "51a6423543e6e8a43e71da34cd90f5b520b8d33b67c4bf857573ab9e301aa4c"
      ],
      [
        "19e86b77f9b581e81092b305c852faf53940a8f15f0a6990c414f04c0fa7ef9",
        "515630e35d4398c9c79fc4ee08e1023fa47d8e03c6e7819c6d2ccef45398fa"
      ],
      [
        "888ab8eb4c31bb2ac5b54aa320dbe1a69c96b864e8a5f54d89c1d1a6b86c24",
        "730e148467f6a55ce22c5296f5380df88f38de76ef0b2de844cd3094aaaf3ea"
      ],
      [
        "75e79ff13a894e7120dac17b7429c0c32ce7828f726c9973728c0977a5f5977",
        "4960526e59c1c736561a201bc56f7d762641b39f609d273cc996f5d9197cfb8"
      ],
      [
        "640fe009249115d7254f72ecafb3006139e4bed7e9041af51458c737282d1d5",
        "3cc6c978a575246e2ce4f7ef1fcc7f63085db9ff98a1b1f3fe374087c0332c"
      ],
      [
        "6d6fd09ccab7c26de9b3906191235deb5c34685580c488275356a05e209ca96",
        "7157f81a34213dd8f91dea4f6df1bcfabc4ee091a3049eeeb3b7923d39b8645"
      ],
      [
        "5531ca1d00f151d71da820918f74caf2985b24dca20e124721fff507b5a5876",
        "518529643d3f25e47f72c322223ba60a63d6bfe78cf3f612215d9c19bf29200"
      ],
      [
        "6192d454e4f8fe212bdfccd5b15dd5056d7622ffe456c6c67e5a7265aea49c4",
        "2377a45dc630017ae863cb968ddb38333a70c7946d8684e6d7a6213f634b7bc"
      ],
      [
        "542fb44b4ef3640a64fdb22a2560fb26668065c069cf31d1df424819a39ff18",
        "5dbae9b0948e0361aea443503840341c322aa1a1366ce5390e71bf161f78f8c"
      ],
      [
        "299ff3e3412a7eb4cb4a3051b07b1be2e7b1c4b789f39ffb52cba3d048b71de",
        "1951d3175c02761b291d86b6c0a08387ad5e2a2130ccc33c852530572cb3958"
      ],
      [
        "628ce3f5367dadc1411133e55eb25e2e3c2880d6e28754a5cb1c5d109627e73",
        "ae3e9b7d50964e28bd15380400b7659b87affdef5d2586cbefcd9be7d67c0d"
      ],
      [
        "6ea54aff064895eccf9db2283225d62044ae67621192b3346338948382f5933",
        "6431507e51aadacfaf39f102a8ff387756e9b5e1bc8323d44acae55130d93db"
      ],
      [
        "28097d50d175a6235320fe8cfe138dd9e46895d189582e472c38ad7a67d923a",
        "7f9eab4133d7d09a7ff63368d6135c26262b62336eca1b5ca33f2096ce388ba"
      ],
      [
        "619fd09cdd6ff4323973f256c2cbdcb224f7f25b8aef623af2d4a0105e62e02",
        "2c95f0ae11d47eeae1bc7f1350f75f9185c5bc840382ceb38a797cae9c40308"
      ],
      [
        "641c18982ced304512a3f2395942a38add0d6a7156229c2a7c8b8dfbe9beb96",
        "6f6288c9c659b6af5ac975f4180deffe53d516399b2cc62f31732e9d4ba9837"
      ],
      [
        "58ab546e51fe49fc5a382e4064a2bd6cfc268904412f86c26de14f28a71d0f2",
        "124b7217943e7e328408e8afdfa7da00dcbc94a2bb85fd8e01fb162d2c2c0a9"
      ],
      [
        "a82c2fdedbb26c3c762a12f7e86b0e01e65320e0a25a8399d665f6e266bf74",
        "1a1de28e253f3e10f44d0111e8074f882d7f42e5900780ccbdc31da372d3fd8"
      ],
      [
        "744c725a7455a992e3cf5bd007bc234dd4668dba285f553f38350ad94c1615b",
        "7f721a87f48798bdc4a9c0eb88559e2ad7a74112fd901e70ea159e67a9c33f"
      ],
      [
        "434df142ddaa60f7881b6348d91687de40457de7ccfb07f0304b9e820705d0c",
        "7fae425e3b53f97dd1f5b20e49ed9fe24ff1efc341ba5e017ac89cf8df0cc39"
      ],
      [
        "7a1e2b809dff46277021cbc376f79c37e1b683bbd6bca5317014f0dc0e1ae73",
        "56790278a231912c334eff05281e08af1558e85516b4411ef64647c13bea431"
      ],
      [
        "4931b7990348d41cf8907be79f45bb7991fd18f8a57868351c92fa7a34cbcd7",
        "ca35091815cdf0837d396e25aad6052ad32d497a33b123256cffdc008bc50e"
      ],
      [
        "250b815d352fd89f8210b624b147ea7d0a4f47bcac49f3ac9b777840da93ebe",
        "1173f10e9691948b7da7632f328520455aadcba46e017f891e0a1d7da2bef04"
      ],
      [
        "2223b85032fa67292f6e1f822628e6756e5c3cc08fc252ab88d63d624e4dfb2",
        "55619ba96a7dcec77832fcb22cd5c21c7dcebc0280d730cba0002b67e0a8c63"
      ],
      [
        "249b131e04de73af9820d3e22492d9ec51bdc0c4c4f34d95352fa44dd61f245",
        "7576d3b5d136368ff01170a77d8286d0d1c7c40688862fb40813b4af3c6065e"
      ],
      [
        "6777915d9b4769027eb7e04733f8a2d669c84fe06080f55e8a55674dfbf9efb",
        "640d0ff384c9635e1af364760f104e058e3c86209fa9d2320aeac887b2e02d8"
      ],
      [
        "2abe3f237681052f002414399111cf07f8421535af41251edc427a36b5b19c9",
        "636ce4deaf468a503ab20ccb2f7e5bdc98551656ebf53e9c7786b11dd9090be"
      ],
      [
        "4d5cc5414758ea1be55be779bd7da296c7e11f1564d9e8797ceea347c16f8ea",
        "1a680c4c410cf5ddc74e95ff2897c193edaaecce5b2cde4e96bbae5c0054eff"
      ],
      [
        "46c375c684b30adf4d51de81e92afee52b1a3847e177403372c82109373edca",
        "1eaadc5783c90a0261306423d52009e991126b3f620e9cb6cffca41ca096f4f"
      ],
      [
        "2ddfb71f51205888118cbabba8fd07d460a810289bfdeeb7118707e310cb152",
        "1fd905d07b3933be886f2518246bdafa6f33259a174668808223cd7c28183c7"
      ],
      [
        "386f3879960713d41fdb3b1e41bbebf26b1c0e27a9a75bb1adcc1a0d3e8547b",
        "2b21498c0f34ec6f17c720334dc0f36021c2f87afbbbc8847d0bd536eb265e5"
      ],
      [
        "407eae62c6c4de3b942195afec3f45efec71ddb5e6edee3d427631bcdbf9b90",
        "436e7f2d78268ef62c4172d2ff1469028bad1f1d0f97ab007064418e61caa8f"
      ],
      [
        "1b881175e21201d17e095e9b3966b354f47de8c1acee5177f5909e0fd72328f",
        "69954b1a9b8bfccf8ec384d32924518a935758f3d3662ef754bcc88f1f6f3ec"
      ],
      [
        "7d545a82bff003b8115be32a0c437f7c0a98f776bcf7fddb0392822844f3c5e",
        "34b6e53a9565a7daa010711f5bf72254a4e61da3e6a562210a9abc9e8b66d69"
      ],
      [
        "299b9fcd4fadfc4b6141457a3036aaa68501c23df579de26df69d4def89b913",
        "b95bf2c2bb303c38bb396382edc798ca6a4847e573ce19b7b08533d1912675"
      ],
      [
        "551f5a4dae4a341a3e20336a7d2f365ddd45849351ec6dd4fcbedfe4806d5d5",
        "5865c977a0ecf13ce85ae14c5c316872080bd36f0f614f56b6dfc7ece83792e"
      ],
      [
        "7a1d69c08e68c80ad8b310736e6247a53bcba0183b9b8798833bc696a0fb6e2",
        "3ce803a20ebb3b120d5eaf0ad64bed0522fad1a0f2ce39a5c5cbae98c4438f6"
      ],
      [
        "28acacc0bc41d84e83663f02b36981a2c8272ecd72d3901164be2affb09c504",
        "7a5aee0b160eaff5b5968ab1a0304ce58c3d5ae0148d9191c39e87668229e5b"
      ],
      [
        "1f78cfdbcc767b68e69a224a077468cdfcb0afd6952b85bccbdb96d1fb8500b",
        "4772ba173c6b583284eb001cfc2a124104833f464ff9df096443e10ef3e9dd4"
      ],
      [
        "2774108962ca9897e7f22c064d2ccedac4fef5fc9569331c27cdc336c95774b",
        "9e13d79b68e8dc8091c019618f5b07283a710ddf1733dc674a99fc32c12911"
      ],
      [
        "770d116415cd2c4ace0d8b721dd77e4a2ef766591f9ec9fa0b61304548994ed",
        "42165d93c82f687635aa2b68492b3adffd516beb4baa94520efa11467a209fd"
      ],
      [
        "5e6e4ece6621e2275415e1fda1e7c4f496de498b77c0b913073c6a6099394b9",
        "3d92ce044fc77fa227adc31f6fc17ef8b4ec1c5aafc44630c0d9195075bf56d"
      ],
      [
        "6e69c717b5d98807ff1e404a5187a9ceaf0110b83aa15a84f930928b1171825",
        "1ee7cfc3a9744d7fa380ba28604af9df33ac077724374c04588bd71fa16b177"
      ],
      [
        "404318f2d2ceb44f549c80f9d7de9879d8f7da4b81e7350c00e974ebf2daef1",
        "3934831b5af70d17a3f1da9d2931bd757e6acf2893236264fc7e0d92ff1a1cb"
      ],
      [
        "20dcb6f394fea6d549b2e75748f61b7ec03b6e52319cb14163373a9c22bb9dc",
        "106a8c96cfb95a331618b7416d1498554730499e194a58fbf63019890480fc7"
      ],
      [
        "119000f277ccee013e6bb121194ec1ab5460fb6a96eb702a14079865f4170aa",
        "1737a32f5415e8720a5606ec1dd4756f02e7c6817e3723b453d091f2d192773"
      ],
      [
        "45d0fb5cd95db76d05dec3faa12e467a308eabaad363a062353db3cd2d9b749",
        "ae08691b5b0cdd19ec499132421638f470f493320e4003d123ab1da761b965"
      ],
      [
        "1257b3e65cdfb6367c6d0942327e799bc66eb221e70c6573a9862889eb51c38",
        "593309fd45755dd2cc4afd2b9316bc4638b0c5ddb3009694fcb7b250d0c8a2f"
      ],
      [
        "186dcf9950f72e868014a8accf14aa36e82a7a2a29f86ba37f6632da4189db3",
        "55684c9f7a043fc523ed78f756f834b4db823d5e4161bd79602c17d55a5cd8c"
      ],
      [
        "58791d5569f282f5c3b01ecdc9388df7ba3ca223a2dc1eed5edaf2a1d302fb9",
        "6298d7dd51561a045bb4089deda9f40b2865589ed433e56d54554f8b45e79f0"
      ],
      [
        "13fd87144aa5aa4b24d5a7bf907d8280d15937fed262d41084898cb688fc28b",
        "3fa54367770cc4479a857411ddcabe86627b405ce1cd14ad3b2863bde13abe4"
      ],
      [
        "48118139445415f0c1879224e2dee744ed35280ff00537260402a1741ec3676",
        "4dfa39dadaabecfc54ecb7a25319444f8e952782d863790e42a9887064fc0c1"
      ],
      [
        "4ad031bb9eda84f2fe5d354c7948d41558ca657a04508654721810ee72ef158",
        "620ebd5d0086b92c6009a42777b946a351c2c7ba852b57d3c9905fc337459ef"
      ],
      [
        "4a34abb016ad8cb4575ea5bd28385d2348e5bcc0cbba90059f90f9c71f86e8b",
        "4f781829ad83f9ed1e1b6de0e5f4ac60dfdfe7f23cb4411e815817e705e52c8"
      ],
      [
        "7fc632d7512aab5356b7915dca854c8b12b369ab54f524fbce352f00eb9b9f9",
        "2ce80b944fc9158005f630b34385d50c3ad84450a9e1e529925b3211dd2a1de"
      ],
      [
        "65ed10347503cbc0216ca03f7536cca16b6abd18d332a9258685907f2e5c23f",
        "3be1a18c6bfa6f2f4898ebefad5a8e844c74626d5baa04a820d407fe28bbca6"
      ],
      [
        "1a8abba1be2e276cdd1f28c912280833a5ede1ec121738fcca47dc070dcc71d",
        "21b724378bc029a5199799df005922590d4e59cae52976f8e437bf6693eec4a"
      ],
      [
        "3a99c22dafcfe9004ebb674805736a26aeed7ed5d465ae37226dcbe270a972b",
        "5bf67552af08e1e6e2a24bf562c23225e89869cab9bef8becb3669175a3c94f"
      ],
      [
        "4a6a5e4b3501f2b7bbdd8da73ea81ffca347170bdfb6776a037cdd74c560fb4",
        "5af167ebb259c2da88740ec559ee04052bb66480b836cadd0e2590c32d7111b"
      ],
      [
        "6890d95308525f0bac9dc25cc1189eb92d29d4b3fe61bc8aee1c716ac17b1e8",
        "e6f23f78e882026b53ea4fac6950e56e3da461e52339eb43d2fdb2dade7ca9"
      ],
      [
        "748f4cf4f027efdeaed7c7f91ef3730ff2f2bb0bfc2db8f27aadde947f7d4d5",
        "3a1cbc550699411052c76293b8c41a3a8a1ecf12cbbc029a1b2b6ea986fca93"
      ],
      [
        "7321f3f581690922cd0dec40c9c352aae412ec2ccdf718f137f7786ab452cd3",
        "5be5130c9277cdb76d7409452438ec15d246b211dd1e276ee58e82a81c98fd4"
      ],
      [
        "6c4d6cb7e7ae70955224b8a912ff57ca218635a2436b36cee25dce8a5cdf51f",
        "32f8c03c6db3246946e432e4148e69f5628b200c6d7d72449df6eeac0998039"
      ],
      [
        "1dad5f2e795ea6fa5177f110989516eacf8fb37bd6a091c7c93f1d73a2fe309",
        "56b2298c538180e99dea3e171dbb5c6fba0bd0a9ed40537277c0c2373a8e2c4"
      ],
      [
        "1610605baacc9bc62c4cc923dc943347cfece7ae241e746fbe6c2c878221dbd",
        "431a82d657e0d109d00dea88cf3fa9b999845221b7b5590a20c40fc71368c1c"
      ],
      [
        "6a4f5c787fb09a5be2b04d2eafa1e6f3d3c863ee22960eb0b64f6eaf6659162",
        "14dbc3eaea6146ee7eaace5a91ed9430dad3a47e9ca2f68b455171f8fe6a7b3"
      ],
      [
        "738415b73e55412b0e582e45ff0d7bf4b1bf2922db581783fdcc75559f40e",
        "33825aeb3fd8459999eb418d15102ba5864b069c6ea517f0c6e9eab8d9aca47"
      ],
      [
        "2603e72ce53985c70782774057a17944f7b4ce224a809be4e2b5af3606aa1d8",
        "92822921809c42318f42dac4d773325f41c43069e990adac7818a45e2554dc"
      ],
      [
        "181cd967ab4615357cc96c82eae9152ce7598c1a1dfdd91a458bddb016ae9fe",
        "5d562fdaeb0e12647e230e50eaf216bed52fa73c6b7378821a3bfc4cd66d4ff"
      ],
      [
        "1121726069b9ef5954ba6490100b226e0be53fef3e071b7c58a1286174b789a",
        "4b25594cf4e9eb2d14b3f52f2661a9992234fc222c0a0d44517cb77deb9c16f"
      ],
      [
        "e543663969b915337f105f80995a77b356f1a51d8b4a4fb12d44364130e873",
        "34b2e3c009fdab4cb7349a580df2e64c0098a123280078e5da6623a9ec6b44f"
      ],
      [
        "4e2f8909bb62de5ef65600e61bbf969293815296b6e23702875e049b3ce5c45",
        "3cb81f2c21f22a7add26fa38a9ce5d9cce1bb251bd2698f90c34ff0a84f7af"
      ],
      [
        "37b546e403a1ba970c17b67c2f1361ab9c803f8d2b5cd93803014faa08861ed",
        "37079184ea46272f5809b523d060686633f7995167897a153be1772fd6566f6"
      ],
      [
        "27bddca77f7bd7f66b3693567a4238f2e6751d95b0bcb409f6b24d08f84798c",
        "6417a85cbfd6fc02df560d3963a241a986baacdfa423f65d7227ce49a96c57d"
      ],
      [
        "2de71a39aa043057d1bc66e45f804542acddf18f7a6d88c0d7fb0ca240debdf",
        "306c1ce39ab46300f7cca0f3a2fbfa77296a27e24bc66b0b8044968ec0ee413"
      ],
      [
        "307c877154364c0c03534e7327d5a88e1380ceef6481567ade37a14ee7c1a72",
        "3404bc7dbfb33b95d922d0693aaf9358f77888d7d95e773c38d83dbe2e5f995"
      ],
      [
        "79f09ff7c60850e5f5ea020722659a1ed27db4c95dca131f99552f785c8afbc",
        "40429528c099349b426ddbf129497176951a64a53db5f9d8bd2be0252cb22b2"
      ],
      [
        "4027dc6b56d446e5972f35464eeac85c5254ef377c902d9fe37aea841bb5292",
        "7c3ea37689ef679fa2f5c7e031a78e23d484a8317990fd34d44d95cc1db3717"
      ],
      [
        "645dbf78a3c228c4b7151450b5e65edb58e71f37e1e4bc5f471e0f1abd6d9c2",
        "15cfe7850f327b256e23b00627451560c5c6ab60db78d45b7ab286afb6f13ab"
      ],
      [
        "1503ca373757677ad1d911a2b599d01c46eb879d1ce21ae171c7e439846a85f",
        "583eb269b7030da6a0c324026919de3f9489d2ff6ae0e6320c36f05469ad66c"
      ],
      [
        "66e1819ba3ec4ad4ae9f7d7588d23baa004e29d3aad2393d52af204a81626ca",
        "505249980cbe6273b82ad5038fe04a981896f4117345ac1abcc67e2525c0ee4"
      ],
      [
        "5ec20dbb290254545f9292c0a8e4fbbfb80ad9aab0a0e0e9e9923f784d70ed1",
        "bdb1ca3a859227cf5d00eaae1f22584e826ed83b7ccdb65483ed5213dc4323"
      ],
      [
        "a5c1a5011f4b81c5c01ef0b07c0fbf0a166de77280f0ae241f2db6cba15194",
        "4444521fb9b33d7dfeb1247d0ee1a2b854ad166cb663d9dd2e686909362a689"
      ],
      [
        "1f35335de40e00c62642dac2fda8b30f071986ce4f11db849df11bc45ad4e0c",
        "7801a2c761b90fd4477ba0be9a775003d5dfcd959b1ed198b4681f15e7acbf"
      ],
      [
        "48db4798cf6821c1ffb8178b1d3bb6020e04186c96aaf4670972d367f4ed5f",
        "781019494df95b888f1578f1b4a3f8e125ea60eca47ef9207a10630671217a3"
      ],
      [
        "17f653d904210148a8e74d8e719a3061683c164aa6d79c902a19f185ab437bd",
        "6780e97985932c3860d810af1e065d454b1cb4be0e7ffe2d8cea7d52526e223"
      ],
      [
        "5c4d0c7432f9b0070436240f9855adae1467cdc9826952ae01b68cd52a3ad89",
        "1c5747f968ed91261b7ae9bf1023c999da9816e37de602d6a1a50d397752bff"
      ],
      [
        "6fedd7639fdaa2f7bad4ca0b391710f6f8a7e890250ae8ae4252bb8b39a1e58",
        "436a215f655a3fd3778b2335ffdc9aca6b98474e43d764c1f8362830b084f0e"
      ],
      [
        "7fbd45a889c5e9d127bb4f8474d6be7cb9796bbfff923b75e42a1ad4cae37d6",
        "484bd12622a6ba81cd53049c550d9ed682a8e765b656b1cbff9bbea637bd1f4"
      ],
      [
        "17d984d47937263f7966a3e7b1eea04071e678494bd749c9e02b48b3234f06d",
        "7b341ff08722c4e161005d0037204a7a2001fdda7af2cc1a0b04a027f115a0f"
      ],
      [
        "7f1822045db45ea07e1519c3ee1f7705915f35fe4dd8db1e8921b5d1c740edf",
        "33d41e06b93320ad1b3d9580380ec797a05dac3f1cc8008899110ebefde2f78"
      ],
      [
        "7b19453ecb74b7d0e2a66b9890ff73bfbbcd61a266abd6d82dbe665bf32f34d",
        "6dba2355420dac582b1f349609ea1c89b89bba2d1a68a0642f1dd12d86e73cb"
      ],
      [
        "273e82a15f395ddf2489a95685bec8bac62c4b459d1b28987d3cb27e4bc9128",
        "653375b48a4cf5d5b101c9ef533039bedce5dbeef3f59e8f168bdc99b06ca5f"
      ],
      [
        "3006c9e7fc6a553d8eb4e8a47ce9f10d1a39576ac255ae9e0a4ce3869e76212",
        "65fe9e2ef2aae608be309332d464f57e28f1df5de1a6a519751b056971f932e"
      ],
      [
        "5e8f384c8a4607fbe9789fcc52d54249d304d698562597d114c1d81452d3dee",
        "3c8bc78066b5d947dc1e405e326ee55ea606c7988f666748d259850fa259a22"
      ],
      [
        "7841b2102e9aa103fb53a642b3e167b21113ea44751ab38e0b5ef8312654db9",
        "71bf5c8308fcf9c4a7847494cd9bdd946fddf7d3a37e8bb0b201ff2343deb8e"
      ],
      [
        "40f68027420c11e3ade9aae041978dc18081c4f94943463aac92d887f922a62",
        "499c6062594a6c7e21a3cb91ea451813393bff365a27a08f1a515439b83cf42"
      ],
      [
        "6ce77a50d038b222634e87948df0590b79d66087b01e42b9b6d8fa30ebb1465",
        "35f5c46bb1be8555a93f155a174d54ec048c2ac8676e7c743054ddc52709d37"
      ],
      [
        "604f8b9f2dacb13d569262864063c2d4bb2b2cd716db6eeb2b1eeabc57746f6",
        "68c6799e24f3b44eec3049973445174727a66970f1614a782efa2b91ab1e457"
      ],
      [
        "73d620f3bfe77f672943d448d7dc05327adf64b8e7af50039c469d7f7c994c4",
        "4859deb36eaf0c802f0d1514602368143a33ec6ce8fd55248b59025debc6afb"
      ],
      [
        "3fd2bcd1c89d706a3647fbd354097f09c76636e93ae504973f944d8fc3bcc1",
        "677ef842cf5eb2444941f527abec567725e469469192354ad509a26ebb3d0e0"
      ],
      [
        "39222ea924ac17b533c72ffb2c47ffdc11d6a7f7c70fbde3a10fb0b8f35eb2f",
        "20dc4bd1089019bc1d7379b4feb3eae6eb5af59e9f253845da9fd633057e952"
      ],
      [
        "326f58994e1347f62e4102183215b5db956378d2f61f14aba4dec94577f53c",
        "7a03284c296003bbe05178a1d82efdb7b8125511d63e20e50aed789c2e52e1"
      ],
      [
        "53aa8939c74d4ee58f03bc88bace5a45c7bfcf27466201da05dc6723a5f5632",
        "2e32535ca7732904a048183247b04b426ecf9b39fc393a9cebe92fb1dc7a7f1"
      ],
      [
        "6cee1a03145e93b3e826e6067005f09c06099c98198c91c222407ba5c8c132e",
        "beaecad1274e7c6e5476a100c271aa1a6f86ee5a9fa5c2f26124d5886fa63"
      ],
      [
        "3ec659b8175e1be1bd5a252108714776b813e330393f587814f5f1f32a73332",
        "529a5cf9f8c237ae69a94217d173c8d19c156952041f5c980da557990863fa7"
      ],
      [
        "3d66ec5963d0c534d4139c8cef2e1ac48b3e7965fafabf58be26f903318af4e",
        "3d3f2de7a95f59b683725ee6283cbaf31f97c4b600df9a4621413223a468740"
      ],
      [
        "7fb38ace8e0932fac2ea0d3eb676db8d684db1817e2e4d59da7996ce398b4a",
        "68f92bd5768cdd4710249f9d49ef1d5654e497b9a4ba10bd2971366d83fb400"
      ],
      [
        "1c4a49314d6b4969cdd142c76ceb7682bfb868ace7f7568b0fc8635bda5a9fb",
        "5fc0519f1f4cc10b5771312458748c036313b87707ed0540026ac64a5955aa9"
      ],
      [
        "3073c95d08d3b97caea5f0be16b2789bee766f76b7e5499f8ce8f96abb0f344",
        "52a8974b4eb9a1f6a0ae2c83cb4715bf18d73f057255fcb3f63b74f7e78f590"
      ],
      [
        "44485b16d597a5de3604df6f7ed7e00b8aeef9e7e8dea8688255153b8bb16aa",
        "6cccb0ba170123266f24b5d93a744397dc2c44820edc4f8f5b9a0f5c9b3b940"
      ],
      [
        "7618f77b7b32d512688dd62e0b48231d9574c6361e8be353a7dc04f7c3a115e",
        "78ffcd16d80636381ca231aae70d99c9e20298b4f5388fd823ea9fa2b8ddfd9"
      ],
      [
        "7dc82fee1ef95cf5b3720fcc07f63246654bfe39762627839da40e51c75654d",
        "4c0ccdd70955da74558de20c88352df8a02aa97e4d5971c500e884740a8cb62"
      ],
      [
        "7fa5d460dc10cbb418b444d9bde97e92c70a99a222b99f244dccee7e62cc04c",
        "636163901baa5b7576c38c43407af578b8c4607e01e86011ae2dde587a89f84"
      ],
      [
        "758930d46006623a756c89bd0cc378f6a3c1f43c9a0edbb42274c35e75c16d2",
        "1d74dd9f81c2fec811b8cbd6168a745b0a111932b2a345265ef2853b50b6245"
      ],
      [
        "7332ee0626b044d664ef228f8cb84df7c643e52f6a2591ae1c9007ad61ec16e",
        "229bd8e630572cbdee54283234cf3e9f060e6382f99943bf234119d47b54470"
      ],
      [
        "78a16ef803aa20a075bb2f66c61bb2dae5698bebb94a0995fa74c3d53de1614",
        "246d588b68edb6fed96c128349908c42dcd64c46341b205e79f4aed9b5d3675"
      ],
      [
        "6e1933939bd03b67bba753cc0cbe7d2f25bad68c993887ef8c9e2fcd59b0647",
        "599413f7c204a11a5ce315eab11299ab7326603412bb00bc1c59ff75a37d6b4"
      ],
      [
        "4a79957a5a1888ad063b51c69565a2b48e8eb917183e220a1c8d3374526d30e",
        "1f092de0e069bba7fc5386e2e9a114c1618f88c4b95e220cd35ffe96f99fcad"
      ],
      [
        "3148aa3df9ece39aca84f59489f2710522216f14be6055ee0027529d1d55e2d",
        "617e9a52a92975db0ba1977f71116f7058a0d31b869ac7f3ee2fd80b0c5100c"
      ],
      [
        "5c1188e72384160ae39d07328346cda4f6c12d227448e6236f04dc971625287",
        "1643006eb3a3bc6aafd5f685cf054f2a572e6ca58c0118bcec0b833741f116d"
      ],
      [
        "3f72efc93c9b71adc4c51d8fc69d3940b20d08733af2b7d05140fdb1d1c1004",
        "7399259987c8f4ebfab46e522380707e58427d3962ee0c2a91760813f76d232"
      ],
      [
        "3129b34c03c51aa8f611e91d5cfcc9bd3ef108ee66e6d3ee35a0e0e50055bb",
        "563b18b5650085efb4cf179a029e6afff27b1d3091cd28eaa68d24fa1f801c6"
      ],
      [
        "16eac0f9fb4c67cf89a7fa4ee615bbe731d8edcb709a1b9b50c7d873a530f52",
        "7ff8288b6e199ca8f316192881424a37fb080c29daa76b1f0edaccaf580a80e"
      ],
      [
        "75f6b6028c43ce832f65d7e8e620d43b16cba215b4b94df5b60fc24e9655ee4",
        "35e9ccfaed2293a8b94b28de03bcb13eb64a26c831e26cc61a39b97969a2ff0"
      ],
      [
        "3c6152fe093bd6316897917ec56a218640ec1b2148f21db9b14fc7a5ff362e8",
        "6eef2df27ae7d63a28856b07b73e7aad7ca94f317201a1e675ffc6f9a1710dd"
      ],
      [
        "54e01b5fe4fd96052aad55b3f26b1d254dfc7e2525fffb9ae0a77eb8cc5579",
        "7c3d39232ab333675b219abc766ed9b4782c840e6b046614dedb8a619696eb0"
      ],
      [
        "d1e63f8ea8a76429cf254a6d3b668761f0dc572d4bfac4fd56d9eaf58fb6c0",
        "2bd0a84d3908a63085824c9329a0983913006ba155b56a58eb3f9becab29c45"
      ],
      [
        "2d6122f2a702edd4da7385b1580796a71d13bd72be94cfb3fec01149c006c2d",
        "70eb282fae992efa6f5915e578b640653549f23385ef3a29ab29b1b9b8ad63b"
      ],
      [
        "752fec14beaadb5ddbba6b3a17fcb86579fa588ef407fad0ea07dbb22a640d3",
        "3feb6728eca21a1e84e8f9f23010387a53a96a1cb62d86fb37996150a1299ef"
      ],
      [
        "63f94a92f27acde8f5ed949b459506f51d70c85bcc61a34d647264ecc53c65e",
        "37e5dce0646ee66f4fdb93b82d54d83a054948fa7d7fa74ab6b36246fc7383e"
      ],
      [
        "d6aa909287a2f05b9528690c741702c4c5f4d486c19a46c38215f52ef79c7b",
        "5ebe1128dd81093df4aca0df365d58adab848d1be1a94b95eeb649afd66a018"
      ],
      [
        "12866812b3053e2f7a9572bdaf5ef2b48c6fb62a0eed9ff0356df50e7d05557",
        "6785f7eb2cd1c120e4c7167b46861d10117040a2e9f2ca86a71e9d67df90613"
      ],
      [
        "46a730d05330b1b13673cb8a1b8f45460035e4a9f1a1751cfba099c4355c1c",
        "76fb0ec6cd16a8141cdcd875c8b2de9fce42d296072643d148ac7e7fa7472df"
      ],
      [
        "4bd4380a22900bd34835e0a908eacf4b6edb61eda0cf483f9212453b37e7516",
        "5e9551cd20d8d7ddbf4366880b7d5267385afa1966ff30da4baaf273b009d29"
      ],
      [
        "71f1994ad40baa2922424ae222663a64f93d8b67929e9a10f9e4c1ab19f3833",
        "85320fe68ec0d37cc19fdfd03589d66906ffa4046c80e1b094a85f27676346"
      ],
      [
        "5a63b1bf5232f28f808765c6be7ce1f81c52145b39f01c879fae0f4303bee61",
        "3bc5d6df68bb6d0577bf9ae2ae59ec0e9b2dc7dd56ea179fb38a41e853db950"
      ],
      [
        "161ded55ff1087032381e6c1449704f63ad2d88df82dfc44a71890fa09b3941",
        "78a52e0013842037274ea75daaf8eb4afc04ccc4b07bfaf3f5ee47d165e01b"
      ],
      [
        "1bfce5229c5fbff5c0f452a22317fcfcd9262f23df41840f84fe7d44cfba1a1",
        "66b387872c00e63c73006a955d42cf49c46c5708fc9d1579b9ae38341b24a3d"
      ],
      [
        "56d47dadc9cbd1dcb2ee3efcd5d4af5e6aea71df10815c68b54a14e81d11b44",
        "47e966ba54df48e9b612a903685e0060a67e4725402e8cb4cf654e54e813a3e"
      ],
      [
        "4b1c44438afd4ddf20a2cf612df2ee494ce84c7274c5529e857693e73018491",
        "430403bd31d8f0677e06abff7159384560f27b9622943fea1a3192f14bf40d4"
      ],
      [
        "7f7281728fc2214aa1dbf13176a4624b53814734abd570eb6ef7c7e32379606",
        "312da47be347fb3fa2c9089b38df372560dcace2effeeacab4d96ab11567295"
      ],
      [
        "16a28884a1be8183e0d3fc0db84a9afbf47126fd3be548c2a584aaafbfa7dfe",
        "7c3f57b3b895564ba562c1cd80b71fda6d2e611665c6ab87744f5390858fe24"
      ],
      [
        "323339f37b327a731232a9580e79952063c7c232bd1380146d8a83c285f4b8b",
        "4f16be1d983c7232f92cce6b9690695978d42cecc8eeb8c206e125d1098a265"
      ],
      [
        "624d26cbaa197e104eb83cebf2adeed09a5cdad359993fe5e3529d4d0def21d",
        "261b7da3cfb55c788977e0d8d640e3e93ae5a325d962ce85c816d7d32cfc430"
      ],
      [
        "f24ecb7ee83a3e28dab54a330dc93d0429a7aea36412e922dce8fbff40d60d",
        "b043e36a258d1df1d21b0cc7be9c4dcae1bd4ed326c110e668ac23d86805a6"
      ],
      [
        "686cea46b710bde1231483bfdbc700cfa3da6ecd5841c0e0c782f9ea24328ec",
        "7eb7407aa58edd6911c7c7e8d1e03bb52ead4a2415a0c33325872ff3a521dd6"
      ],
      [
        "3866ee1186264549df3dfcdf8705c0380c9372eef6d4081c2454d3aded1720e",
        "634c6d3e8eb8af652a4be73e3b613452c2213104ca875b66b4b15ee5b1716af"
      ],
      [
        "484c687cd2969a1d20a58cdfb9a60f280a473284503b1ecff5de514aaf8206b",
        "34d44d26b7427e51a646d1b924084762f5b461685450f21d6a472de565bebd8"
      ],
      [
        "203561333771fa0fe22c4033349f7b877d15b0542a5598e81e067968768247a",
        "2b6a533aff6e2163a36a2a89cb7415848bef48db40f952ffd380f47676707c2"
      ],
      [
        "2ffa6cca6233695760251206fc5e34c8d3692498589478cdd3d5b09f0b7c05d",
        "6c57d605478fa9626c4ed769554d075daa53e1a1d0bd4d94174d3bfeeb11ad6"
      ],
      [
        "5dccf0fa46a5571f204d0b033b45f299cbb3d9f80fded57253ea4f1c64faaef",
        "30a38e131ee8756ee5ea2a3e16618a5dbc28b5b9311308bf037ecc2039dfc7d"
      ],
      [
        "57b0a2eaebeafd950221facdd24790d7d1ab8883e5c5d55635f0d14a1ee4741",
        "7b41cc478fa6be38417271db8ed12efc0da6982552c1496025d2df0576bf4ad"
      ],
      [
        "611b5725101f611c387ccaa13889ecf3bb5595071a179ce350029bfca4ad7f1",
        "3129755977abc8995fec7eec1123a1561e429fde37ff36af002d3211831ecf4"
      ],
      [
        "1c06bbd0c52fdab9fcaf680c7a93fb821e538a2ed79f00f3c34d5afb9ea6b31",
        "3873d3bdfe0be0157bbc141198dc95497823cc222986d24c594b87bd48dc527"
      ],
      [
        "275cdbabc989c615130d36dabfa55ca9d539ed5f67c187444b0a9a12e5b7234",
        "2b7f723e68e579e551115d56f0ae71a3b787b843cc04a35b9f11084b006521"
      ],
      [
        "6cc702eb20f8b5940c7da71f8b1801f55c8c2d8e2e4a3c6c983f00bc1ffdd95",
        "5d15b3727bc66f3aba6d589acdd139fae115232eb845abe61fbdfc51341352e"
      ],
      [
        "44defb418700cee8c9bd696b872adb005490512d8bba081f8f99a9f15cc981c",
        "3b2072cdb1d919b2b65b5cb3557f0a3381d7ca293c267ca4a38f83e77bcc96e"
      ],
      [
        "fd83ce77b1578b3a9b8c3cbeaddb1504d2fd4a19c901c21ac65961224e4966",
        "110cbe64fc10c6b9c66f15ca406a35f50b723b35d83c5eb9797a57f8395f4f9"
      ],
      [
        "9dc6ff90e341875e113bbfb507724dc7095a280d2f32cb6ba61a1e0c2d2aef",
        "4aeb622896c852c2747454e8f172c9482955a42ecbe522d6ce07ecde79d0a51"
      ],
      [
        "71c58b0e47b9dd9107ebd8a8c8fa9f0534e78231bac612c1ddc7a94edf33eb7",
        "7f90edaf4792bf8334adbaa0f4ee7c654312725af188682d75f34874c4eccb9"
      ],
      [
        "1f6de1f14988778ceb2dfe844f92394f1f1e72fd1581ceb3bf336c95ce50345",
        "4f6007ed4e022d2ee9fe4ca8207c5f6c766c4f3b85260e941fb24ad0dcbf0bc"
      ],
      [
        "3ddc3ac25ede4a67a97547ed27dc920239b585fb3624177e2e8d59eba678115",
        "a9afd8f8bb759cbd1dff2addc63f47da4ba1291ea34229c09c0637dc5c8d24"
      ],
      [
        "c56b0269d8431556e471cab9d70edda3a37b391696f107b2dc370631de51d",
        "729c52f6b134f733eb750c14bd9f95c077f0f6f6ff4005701e5bedc6544599d"
      ],
      [
        "44d32ce19ac6807cb22e4f25fe1486a36a13926f147fbfa054b63ff0446177d",
        "212a21e8c124c9cd37c80d2dd66913ceaa6b6f666522f115c39382b2d5925e8"
      ],
      [
        "35dfc16f3ae6ccc06a267bf6d931601e52f3e45359ffc513570b65b96adc4f",
        "74311d10f4bece01b5ae65a6affe5c931463aa1b73a3320eeb41bbb7bb1ff62"
      ],
      [
        "e0acd9d2d907031b319b80121dc90699d003d220ea785d50e5033cdb3b1a03",
        "3911ba78d6e507485d6374b0f7d2e6198f6462a7d6d3cf046404a07af690357"
      ],
      [
        "3c57918ca254c0cb7dac251ef4e10c7d82327969552eae15d26c4c52660922a",
        "5fd5f5ff3f14e671548074114c72c48409df8a2e71fc8aa3c8acb506e2a88df"
      ],
      [
        "222ad8b61e219ba2b581f606b7c996516850a46a3db72fe1f72b5a9be6c324c",
        "72015a5e2db648112abd284fd867b59fc5606645177d26cf6e9a655c9912d42"
      ],
      [
        "3c86d5d774bc614469768ad38f7be9a53e9a233942c5c553b82e49aae684764",
        "480febea8229e130dedffff89c11f3c43e11724e6bd89d5566d78752859d41c"
      ],
      [
        "adb73bb8352d0c10175df371f7868ef2c9e0c79ac788430c480c0f7d85c187",
        "60b564785248111502e6f39c4994d6293fac22bc25f4d764b2fb1957d3c9bd8"
      ],
      [
        "3836ab8b46cf4f453a22532c886940b982029b29c42adca90ded5bf77e6bcb9",
        "7b15e91d6355f147b171a90b064a9d8b2d7bf3699bbf4987664c61c950d8996"
      ],
      [
        "12ed96af1a97c45ec31f1531e96f6fb28a03ba52ab8484545fbe0dddc97bb32",
        "6d1f522b6c6cad0940cff8e23decc72bb8d4164696af031415508b025aa8be1"
      ],
      [
        "27382994ae5878223ef802e9b4882f481a1b4008f1eec8484483471f7aa742b",
        "c31750d242b3975b0026a0e86ccdd17d0f680a8c6f53f197fc25eb1f777917"
      ],
      [
        "431677eba3715455bc235557518a74f3b111a88844ef13e159ad44bc16de3e6",
        "30000e1eb6a17d9df776981e65c6e500fded1ac12003adc9446b269812c9197"
      ],
      [
        "4b563e6f42589671579eabfa2cda5502b361c46a5ac8d45c8ed44741a925b33",
        "627bdb41678443fdd1aa607709e9699b652308615f4bea760a3b79ee0d9ab5c"
      ],
      [
        "2932fd3f81fc973ca9def6b7f1bb50f980fe589187cfe9e9f52ba4d356cf2c8",
        "1e6bfd00fa976c4770263a227048214c38850fe0f059e7b3d2c7871ef07d68f"
      ],
      [
        "e44e4f3d96d9dec775b996be57e57fdc28e7c68023109b221c414a244a0dbc",
        "58b1e52fa274812e5184e00e9ad812bec2463140adfb4bea3b2d665867dcc9"
      ],
      [
        "7fcb89be1f4bec745887bb891e53fefd665c53d00a9e74de16b8a7e1f7adfb5",
        "74af0b06633f779897e199609c71cc5649bbb65bc2c0abd4c678f0480c198d1"
      ],
      [
        "62a381ffb904ea3ff4d451d4c8459457cdbc3dc2fd2da646a95d8c1e90c0b7b",
        "1ba058658e09db9e319fa73de8ab4a992b71e4efc22c273725bdcab84e2a315"
      ],
      [
        "1b0fbb7a84c67e668450a54449c7a46261a2d355589f8b84ebfbaf9a77ee938",
        "44f8fffa33dd33a6146c35d196595e22cc4a215f61ee9197cd751400970a1b"
      ],
      [
        "78fe920bd96a356d4d95ee34adafe8fecf071d3107c36f047b4024ddc4b3eea",
        "6162f29607fdbec10181fbac6e57d5cb41b922c5791fb24bd28bcdd75d16c41"
      ],
      [
        "5629b849e026e65d119ac11821d7ab7efd9c52226f75c7427505d6818bb0c8d",
        "1539c0f90970ee8b490e45bbe5568170e5708521a0e59f976be680595906feb"
      ],
      [
        "62bc853f349bac8c6e5921d27ba85dbd9ba20a375d70a7bc008928f3e123b04",
        "6acfeb1de05ba43c3ef1a9110a983a320e77b3ca294abbc04aeca19b194f26f"
      ],
      [
        "4cf4bed663464418285cbae359b5d84ec76b5997d24f3640984c7663421190f",
        "941f818e3e3e8fb1568da85217d17f9250ebc948379014d900a7b1a848494"
      ],
      [
        "52ff3d9ffe9a302f6dfaaf74bab57c08027d5cb699a69b30830540c0a2d47a1",
        "987dd8876873778d933fbfed37aab2f7d6f669c37024f926b1edcb2ca55782"
      ],
      [
        "1109ee32f0bc53de6bfa457060b366e909d7c18061ec9845f46ac715496897f",
        "38f36f172bdfd454b9285f86e6bdece8fdffc95182c7d801b03c671cc55139b"
      ],
      [
        "4b4482f1d84efe23dadf3bb10df3dcaa251312dcdd604f616f1eb540e1f3232",
        "7c9c149dcae9135f940fb54482f9c3cd8193721643a6e23157b8020410d439c"
      ],
      [
        "69cb459b9e415b7581ca163611c470d875971d5d7949de732d1f0f200544a73",
        "a7136fa9dd00c0469863b7def3f83a5611ed628810d7e807e7a873da5a9897"
      ],
      [
        "b66a4e32ac9a4baa8f64780acd94ed3628b2b0ea874ba4dece629af65f9e62",
        "24328ba9996a24389658e3467b8b90dc3927ef8419fe28b3f55b1c1aaa51915"
      ],
      [
        "5ecc3080062dd451236de0e4eb91c5c75100733364bc5469f5fa76f79021ecb",
        "6da4abb9031a27b5be94529324fad8026e7d871570780081b0f424d4fe543c9"
      ],
      [
        "1e3146f00880bb22486d5bc73e54367d54251f4002bcf342d0393b05a4b9ce0",
        "23b6fb8e945d3205f633ba724202db5a99305f807137edf942cd60eef867699"
      ],
      [
        "2e1da8013285598b899f026c6974185db12c97b4c63509769d3d4ad1d18a4e5",
        "1e7e7b668674d1593c39d58bc7bccbf568208732b3519bc2cdf93db34366862"
      ],
      [
        "d26c3f389d81709506f184b53871497c8d36c5c9eee8e3737358204c1acba3",
        "34649c3d39f3b825947fedbca215ae30c5a5995e93b1c8efca4944cf85a082a"
      ],
      [
        "91300478a83595d548f32f259033291fc7d083953b0b8bde88c7559660c563",
        "e5d2bff57fc6551e9b80c06ac7314a71907cdcc66ce82f2cce721a670df10a"
      ],
      [
        "1f7abcb9d462c63ffe92aa56619ae8590089cca4d93ee3e5f34a63882452cc7",
        "7e9f85c7b7ca6e9a4f3a026d1048adbeef69ea9d876c6f647c257b879a81bdd"
      ],
      [
        "4d2caa1323012e4c83b0ad387308b8aef5637bc35ddd882e7f5e41cf2ca410f",
        "47150e808c81a540b6f8864e9d6636589cacaa516f82caaa96506edfbd6f0e"
      ],
      [
        "3c10a6083c38351deb3e6d1b386827d0acf48979b66b95249eb8700ec26b069",
        "47e34bfe561d903cffdd1d849b85aa3cbd31cb4a9bbd8cc2e5fd2f95016cabc"
      ],
      [
        "758bd54868eec045d0b4d3d2bc415d24bce13fee47cefdfda46425c109b657",
        "3392a7c66ea3bd7b044680bbe9f78ae86752097404c067e9d2572f55330df83"
      ],
      [
        "19e718e0ca1d2d6fadbc6006ee7dda7a385430e29f5e239cdd4bb7c3fdcb2f8",
        "5c68249b7fe03ea2e13481a63b6cd4bf74ce42009a89fee0b3f8f968b3ec709"
      ],
      [
        "28077f57ea62401806367e6d54fe45d02de5b072db787ffdcc3854e12a3e855",
        "14f3762689072f5fb41d03e94b01808c739f6d42b7b785b0e464100b150efd2"
      ],
      [
        "3b8a8cefd017363ce867265af3293cec081fa589fe561830f0078778cbd338f",
        "69ccf2383cb7b4f9c806d72535812483e7c5e9a1a5928529d64ca7e085e758d"
      ],
      [
        "77878f388d22161a2953e5aca6bac1ea480e102f329574b4b201640d44a296b",
        "7eb35706a90a03aff7c2fecca72659136547cee98038746db5aba16fd7178df"
      ],
      [
        "97332e6da70961f2ef31b7b628f1018d21db8db015922a301fca7d6fc6a8e6",
        "2e37b06f639fc7a82601b744570a2619e543cbfaf60e474107fcaf4686d3223"
      ],
      [
        "a81518d452d3aac48bf0386c3ff170ef4e684a4def242c964e129c64f4d647",
        "37506e44c85908ec7b7adda9547fbdcc2e3605151fefa77fbf127ce3bc938f2"
      ],
      [
        "e80336b2220b1d666074f6b0dac85353d0e4c2e8bd0f37055a2236a6a9fadc",
        "1cae76d73eda7a5964c5d9d3ad6748aff51f5543c56441d2fdb7b444a39846a"
      ],
      [
        "2c01fd8430ecb44e066f352c4f697fc9fda177dbe162f82862d7b9ea8c918de",
        "6e1dfa99640fdf5b30603d34c7c97c1aa6e6b7f3a2c52a21fc64b0fcac7d591"
      ],
      [
        "744e37b511cd0ddcfe15f3581947014c159de81ed055d15a13c7a2d1fa39f0f",
        "685caa8ff6979a6c63640ac638a3f9c75737f2031bd55322a47384357af164d"
      ],
      [
        "40e627ff84e1a7a9068b4368770f5956128a4d9e9e33e9cf5e24d9a242149fd",
        "2465bd6cb20bbdf810e2bc5c3c458cecf4f3aa163a7ac99c2579e5f33417f2e"
      ],
      [
        "5f635af7f554a17bceb6ccb6e637abf89ab6dadd399189b0a0390e87b1896bc",
        "2aa6238a69f89665646c0e3ca2ba5f709cc6e14351cf71e1b00ec45201417a2"
      ],
      [
        "5edad3063c9fa8305978d7e6a4e037c9fa519b8023c7608dfc3b66e5c1e8985",
        "49f405d07d7d01919da51159ecdad1031a5ac208c026fdfc14d38f633d92183"
      ],
      [
        "2fdf2e8a45858c12926a1f25a62255fb2d02d0149a15ef669f859806683e649",
        "61cfb686bb31e2524470d4ad2ae09e3cc91b16305a21d748098feb1d8ce3b3d"
      ],
      [
        "ecdbd7c37f1dffa3943977278da3bb429afdf948b4ea6cdebace3d3be82381",
        "190b67fb34f7f3ad6afd3d6b6427aa327547d8ac0fb4deeb0feeba1f63d6c60"
      ],
      [
        "233021b483f578dfa5222f8cccba5766ceee0ac65f6d4a3b1673b302a21fb3c",
        "7d4b6d44d175d4b593f06f5a6dcba2cdbc4eaa2097abaf613123546866cf4ef"
      ],
      [
        "42db4e953c2a7a743de9fe20c5798f2247f51db4eabc6f40e86c13909a310ce",
        "12c1a0764a0b9f3666e431923ce15e7fcd0ded5ab153f0b48d362cca1604e65"
      ],
      [
        "30d539e2b545fb957e40e2255f6463b52d227c9808472cee6a3d521aa283a44",
        "5f9eccf747fe6313570f99e845db32b40070acee9ce9e34da7f3c29ca53a07a"
      ],
      [
        "4bd64e5ade3e2733580a6116b4af328751198e7128f9acfe3a3496b545efb5a",
        "4d584768900dabfc0dbaa086632b8051bb3905ef79b84d96c01514441d0cc93"
      ],
      [
        "62d6e771f02e591557197d13c3e77dfa2d1794ac1808407bd8227c4be31b466",
        "5c6f5607c1808e899ba36a425911fa8566b7ea9cc80de8a80538c0fceb837c0"
      ],
      [
        "5ce406218cb2852b1d2fe1836b19462f664631785216e87ffbce26030e2101f",
        "5225f107743c255ab50e7be4a090fe39478d1ef4ff558468559d8cfa87bb94"
      ],
      [
        "670286486e8dda3dc66b0ed3149be7697d3e06c8279844079daa7e42d5af728",
        "26becabe7430380c56e320f5ae3329569cae7b0af06fd5327ee23979d200eb0"
      ],
      [
        "3ef448df33a4394c43e93e5850cd0c5a6dcb18ae1cd865d00fe8ede9336a9f5",
        "56711f6ab7e0e4f7365ac34e284ac2879f40208c46f6febcc1dcf7146ecf015"
      ],
      [
        "4b63fc130288e92f2d6ba238caa7a6364804e29829ac037c57df32fbf762bc3",
        "1eb8c80af55278b4113286c038fff2bfad2da62763bb03426506b869139da0e"
      ],
      [
        "4e7e998557b29a95f805a6e2e26efc1e970108272d4755738c04f28572295c0",
        "97cfcc2f447bde61bde71049d8200a74a3028b21703bc139143d81a3623f09"
      ],
      [
        "574b67898f02964c408f68e9470e7b615be037e40b824e6617f89cb56c21219",
        "49392d5f8e6740a1b0b7444f56d7a17363f8656c6e4c628678c86223f2e46c8"
      ],
      [
        "7e8cb50ea5d5c1b09e219e7305bcb601d99b6d7185b1c388aa8e36fe1e56554",
        "47fefa308645455c12ccb5817da338f0c4f423b341aff4a9d158891a4fd69ba"
      ],
      [
        "67266dea9e71b4ed2bf24a597a823dd048cf31e725db511edceac72998c9ef6",
        "39babd65850befde1f7c28e41dbdbb4caf82bbcf3bcb5b33161f1c2960b2d8"
      ],
      [
        "63e99c2cb9c74eb9227d48065e27abb8f606df8fc83b2c44e4ea38b046bad2b",
        "60494a53dd13ecf34e08079d343c88fb655d6d810785af81f08d5aa9bcdcf9"
      ],
      [
        "3cf0600b0f5a2a4eb78c487cd385350e8c7848e3f6983231881d7f1bbe28543",
        "56dee4288528de609976ef6b903b652127c37b0590e91a2fdbebc3f11df2628"
      ],
      [
        "758f09245fa4b8b23d290ee2b3bfcede199b4fdb11f3cf2502a8ceedd61b129",
        "622d9baadfde781e985d9722e0a04715666769a4cc7a9bea0b96d6386be1746"
      ],
      [
        "38e1a45b81492aa95d7abea2b08b8c14dc0b8a41108b036871fb737910ae18c",
        "145c611262656385e5ed6243568cd3f9f59dbfed7a01ba11e22bb8bb272e08e"
      ],
      [
        "206e54ca53a2f155bd4fc45bf2edb77798ae6623defd4cf22f2dd4a7d119dad",
        "6c94e7f0825ad81680e4cdbcaaaf4df806d57a0d1fb2331926c3fe2b79d22e8"
      ],
      [
        "56e98d2862893caebf66180e84badf19ffc8b53041eaaa313ae7286a8fac3d",
        "526306f9c01afd6e0c1198ea5de17630f5a39c4ecd02d8e6f0d613c355995c6"
      ],
      [
        "4fa56f376c83db33f9dab2656558f3399099ec1de5e3018b7a6932dba8aa378",
        "3fa0984c931c9e38113e0c0e47e4401562761f92a7a23b45168f4e80ff5b54d"
      ],
      [
        "450cfaadfecdb8a2fbd4b95c44cb1db723ee5ac9677c9c188b3d7c8eff4ca58",
        "1a552bdfc0c81be734f1f6ca9a6dd3ab4daa61c11fb53ebb7046eee25d617c7"
      ],
      [
        "6fe20e5c8a8004e33eafc84d16ef770f2f0b7bace19adaaa150f987d295a34d",
        "28a35040a2ebe9a14a162d3208d5eabc6e2f3a8310f926bd80be65aa71775e2"
      ],
      [
        "1bd65f45a35bf62ae8f9ffcbd7de2976b90518b6820c219f039c50043bb1edf",
        "fb5f0f8659f9b6ed7cb0ddd7999506d0c20b26bbe69d1915a31842cfac41eb"
      ],
      [
        "4ba4cc166be8dec764910f75b45f74b40c690c74709e90f3aa372f0bd2d6997",
        "40301cf5c1751f4b971e46c4ede85fcac5c59a5ce5ae7c48151f27b24b219c"
      ],
      [
        "21cfbc678f5a279ebb6ed124273c8df37eaf12a2d04180403ae6b5ec0b1e1ef",
        "4478ed6a346d899ad7b0b10350270aad39ddd5b68529297e4c91a54357f0a7f"
      ],
      [
        "350bfefbe3d864eaadac9cc1195c14159bb736be743aed7380d2384cadd2046",
        "5e2a4b3ad0e1d7b9b8ef72b10d68a80e5ee691d7db591fcfbaad6240d41da8b"
      ],
      [
        "529acd569127f73c8d34345f87e96cebfb48ee12a00a3861cda209337ed94e6",
        "3120671a89b705e5bfd99b0e7fd2118b4914a3ac309b3d74527cacb5ad7491"
      ],
      [
        "55d3d7956a97d10e65a4d8ffeba40deaf0db0b57f8e022cdb3df6df613f5c6d",
        "159e59a6f92f48fcf85aa96c1a03749a4c4e2cf9e2bc94dd36796daebd9b8b9"
      ],
      [
        "405f019ee8f2e972a005c549b0884b5051f63d1e78480b73208dc07d8c65a1f",
        "4301a3d0c285ad309ff24a12c100ead7f48ba1368143712f32ac141ab4d9e8d"
      ],
      [
        "376d59b298d982f02dccad0edd5bbd4e5e8fad7898750675ed0856850a7babe",
        "5233b12bbc50564eb61cc098a17d3d97f06ec7a230380e4c5d3b725cc318eba"
      ],
      [
        "2f55624af6109ef04b2ed035a44a904ace8627f55889f011f768aabf4de9a38",
        "7f64209ce7dfb63337ccf3d8c14f4093295f86996cabfee23b1655549aca089"
      ],
      [
        "3b8965e942bed2714bc2e685fb103496e1e3595ac6a343d6df45fb5ef6979ed",
        "5b7cac7a165cb69ae103dd9052fb39c00ed0aad47989005aee53972d82d45b5"
      ],
      [
        "7abfe3accdec1eae1a50049efdd9a8eb7c2921a08e8bf1fe606e9d5a4039ec4",
        "3af178e7e831f8148244d2d2b284a32991852db6212ad0a9d77540ef648a5fe"
      ],
      [
        "4983196df6ad7d6f0a8d76f86af3863ad8611374a03fc0fd00793181dbde9d",
        "204c1f91b70f975a21d24a8face664e496f00f602daaafa69a3b56098a4cf89"
      ],
      [
        "79e2b91c1531a3b16dbd53e72d94e16bf265cbec261658151acfaea3718ea72",
        "3d9bdb47e8b148c1c5e9e694ffbc2cf71aac74ae1a85e8d8c3f77e580f962eb"
      ],
      [
        "297efceec61b3be17565843cae465c52524b4ecd9331a4170f54f7de8c4556c",
        "6ccef1733624cc8b973ac63dd54e7a53604929affe81c3439525ae5ed6af993"
      ],
      [
        "44f04b1966264a23ccdc870c8563ad2efcd4c8087b5469b90e792287a5581c7",
        "1c417f0e9829fa3d3cbb7c3cf4dc7aac04c5bf66ff3f86b833a42c533aed1fc"
      ],
      [
        "6ff83f5d8b51db3be0bda80eed2e2adb7037f2f58f705e88f0f98197431ac26",
        "64f59b8428894c2b7afd740866065ded42e716c7d48accd3f117f22768ed9fd"
      ],
      [
        "14aa8187c9559f77cd1cf96b2dfc949182529936f2b0b4050ea56e134073b24",
        "5f36508c68b1dc586f3fd3f4e2bd29c6d8258491b8a6aa19ede811ce0d3d0a1"
      ],
      [
        "95e8882a68c5000d1c2be7c0b43e7f2a6f8de906485241f0285a5c73a27a83",
        "1e4cb67207ab73bc1e5d19fa2146fde6d03021393b77a55df4ddda1fd28f5b1"
      ],
      [
        "2ae0704dacb3da47d564514b4c3543505b403ba09a248c6e74593cba1867ff5",
        "5a4b5818088dc9ef4066b90a8893ae80fc89584f987ec1928ef9d72cea2bd67"
      ],
      [
        "61a10898a76fb99989e51c0e823cb60b95ec7ccccb917c42b2b28014f5fd94d",
        "23d8ec1de45366d3b86c64c2da05a2ce3d171adf52ca5522e652ffd0eeee795"
      ],
      [
        "79884133c879cf07734976fd64de220c5a972e04c2a3afb74c362d6c3beecbf",
        "2aaa0e6d4891b792b5643fdf09873343cd0e3fbba3cbd0601b481a4083f32b6"
      ],
      [
        "45f73d2fa82be6c5ccd0f62d2237efe8727c479967d27cce28e42b9a44bad5b",
        "2fa4932215f72d56d8be5205c5851c9b3e5f2a14468e4a7acace5437c6b27dd"
      ],
      [
        "37f53f771850f52f9c8f87b53c6bf0c93c2bed76f5fd1d5697356d0b2325007",
        "50f1a052b79b446fbc7b93ffa1a4515f6c3be3a76a2b0bc5eb8ff327549960c"
      ],
      [
        "71bd6d23e0d2f312d47582efa609101f15b9ccc571fca8ac4fe3457c67fbc9b",
        "3b3fdf86bd4c7fc26d60540a6439b4d179dcbf7b91efb0ddc60dfbff9a148c6"
      ],
      [
        "78219ba049438385b829c13a4993874a4a326c4143de0dd581c7b9956f99b06",
        "5505f1268dcdd4ee01b77abac3bfdcbf3f0513ab097c69ff777b4a631aaf256"
      ],
      [
        "b81e924a86536dcf68bc5a2ca2065a61103ba6c9eb0ae4cf8cce9dbe286f15",
        "653a6dfb51acfe8a844fb8362795e5549d424aed88d3a090366a44f840b5b83"
      ],
      [
        "441c0d7b7aa705046dc0e07ba5f33a7d9df23f694a05192ff8c2d7be2aa3fdc",
        "4c06568c0902bb99d428bfa0a946ed0f0ca0a51fbf07cad88e06e9c78e38a59"
      ],
      [
        "2569c8c78b6d6b92533f29f767c95720d377fa63ad5a3b9827ee0a74b0488aa",
        "4b59c81d3cfe08834f946d9d57614f5366e0bcd9349475aaaebe01341196fe0"
      ],
      [
        "3f2fa285a0471647b214eac652bbad9d58a9f2dd2e812aff0210d0d8a6eb32f",
        "4cdb18e1c2848c2b52c1a6557165bd1a8f55c2f7562f5cc0b326f73c25b696c"
      ],
      [
        "5bb5141ab4fcc5290ae9151b8045a2cd8391547ce7b3b33cbbb10f8fb538092",
        "5a36bfd52acc6a83a9913b937ec086cc27fed030b5fa70dbc5d3c12c9515f56"
      ],
      [
        "3f3fed272edf91aa7f8ca5d70005d390fbc67830ffc69c5fa3ae17582d2771",
        "459057e0883c44d8776fa217405f443e5954f08c4a5db68e437becaa664a999"
      ],
      [
        "5237ca6656237a717a739a4509f70db1b9dedbb6cd232f60c9bd8c4563a6b1f",
        "56c7799dd02896dbe7d69dd8bb9718270549592099569d107b7b49c34bf5a49"
      ],
      [
        "1cf6b8499ac881e0b2fc7def9bc1a28937033b2fc52de99e75909a620c7a281",
        "5769cf4f735366fa386b6858043dc99a100f86fbc77b16d57d77766197ba27a"
      ],
      [
        "1b74b8a6b86dbf9638cdb0601e1a332b8d880753423d38c3394902c57f15e40",
        "6bb2dc10d2ecbb913219d0ebdc8d3337d644ed8b6c4e70637ef4c7e50887488"
      ],
      [
        "61e4da415661bba52a4737e2bcde1a837787c4796b2e1854778534f1582c29b",
        "27c43e632cb7652e8508c9c38e3b4ad0d3dd6ba748d42dc84ec2685e64b9aad"
      ],
      [
        "7c460a204d23f20ce86596dae6ac9b36734e4a9f7c5b43262c97a36c6a41c6e",
        "481a11f9300ab4c4bf6924c5ca884728cc361247377065920966785d043fbbf"
      ],
      [
        "124ff5e55e4effa40daa5b9618d75c49c8b6fad95cbe8c0bfdd83cb9bed8316",
        "33a2ea15d0f71f58a00de71acd7f22ccf9002115e49dd1f7631faa0d32f9987"
      ],
      [
        "61c9f8fc86715e95ff43583a865c5a6515f93381839d557ef884a68637eaf4c",
        "5877daaa42bbab9083b571e12648a9d62ced4470d71653092b6546f4a5acceb"
      ],
      [
        "70a6b9a9e5d1fcc07dd9ebef6d8f5fcf04c6cb34932d0fe2335330ac6dc8d3d",
        "3f0cbd332ac56922e886656bee74f6e9bb4bb88f7af7bba9098678af1f38fc"
      ],
      [
        "41db8a0f1ea78443a39e08a54323743c8897eed1ddc28f41aec6f2655040d9f",
        "7d4bf32f8f4719c2e4af8b7889f3b65cfdd033dc2f971798a12170f2b26efce"
      ],
      [
        "62f035e01acdfe841104942d6c8c07f0fbd618cb85998ea24bcc24cfac1f8",
        "1caa886104b7d753fda93645a746989794cd825c62473b526ea34b3d51b5771"
      ],
      [
        "441c6f016d270e86c19843727b83b864cec060cafc813b23d7e41e5abb1a60a",
        "29fece4e40400f3acae0586f4fc8ed535e805e472123ec38d662d8a0b01c086"
      ],
      [
        "2c791ba0fb0b66177815c98191fa6188dba9c795e34a7c3c8a19086215e3cee",
        "11123151389d4b330db6a665a560407e7cd8c3807c749e2b0cffd9c3074ba77"
      ],
      [
        "5292da4ca71ae75ed0554c267747e39c7a129b3b863e1af3ebb3e368439c4ea",
        "63af6a5016deea8cc674c44f16c63c1db31f09af4fb4d2ea7917c28116661fc"
      ],
      [
        "3367388d5d1b7758dc3d92e244f227bb8a54e3d9909e7b7dd62ab5965e3efc7",
        "7ffb4833071e4b03ea755ccb9938487a478248fe9b1158a08f1ac298801c092"
      ],
      [
        "95c863314b7f18090f8eee602403be823a367a1b416d54c32e5f914e67d922",
        "159c2824f899171deee23e0ed520d4825bd667983df0a8d45d3a1f7156d91f9"
      ],
      [
        "621c6e08b3c57404644ad49ac7629832c141273fa1f323781b3395393fe985c",
        "65d1eb0140652958c4371ebec791e03317d6b2e689d90e304666f1b610783dd"
      ],
      [
        "54313129bf13993952cd2b31ed06013aba85e74c1b8a00e062031f32188a84e",
        "680129efc9eb8ec07fc180e8f6877e5f0f9f44e3000a2c586ed4ce49d12a313"
      ],
      [
        "21ea57a1c8286bb45872e78617853c47b89091670ba51c124afa3362e7260d",
        "7087e5c1536df233ec9bfe2f983e8d7622892b9bf64c450c9823898e2cc2fc8"
      ],
      [
        "3793b05b99e7a57d88db4ed0dbc3b771285abcd9052da50f88595354409f3f3",
        "12164105041c056f127e737c7cd63981e05f246bd2b6b65d1f427019c7c3801"
      ],
      [
        "befd345cef5fcae22ac37dacd6b9128cc58cbba3e3fd774e11b421c2ba392",
        "6209d25f24f88f7876ca604db23d05f78e6b3b67fb033f2f1bee221f352b8c8"
      ],
      [
        "15fa536045fda4c65ff74f10b4e669ce88b9996c6772288289d3ad725987fa6",
        "30e0c2124a35e265e931ccc66ce5ac3697d982814beb407144ff6762cb691df"
      ],
      [
        "38b795bd77ac573576dc204857a488cac2cce19809882631ca2069598c577c8",
        "786ba555d55ebef688b068bb9186a34a08cb00bdfef51619bbf911890ae9a13"
      ],
      [
        "6c66853592196c3eb8d9526dc155205e2c64097adf8684bb0e15eb460ce1c72",
        "1bb4ebf654f4250c8dd1061a4e1b464b31a8a9999ac9960446ef8108a66871a"
      ],
      [
        "5b08dfbc87ad9c00b88e78816973ad2f9c10c70f2156908892cc7b7a2a1fd30",
        "1151f407a77e2556073173d8f5c9ff561d8a23742121ca15f7d0ac391af50ea"
      ],
      [
        "309190eba106aa6ead54b5ca5817969aa68b4b4c627700799a49fc6bdd32ba1",
        "505b6a2bc7b0d78ca6ce2abe7dfb7312369918a4599cccf8a615f6701cfd851"
      ],
      [
        "89cc205966af08acc8910d563af7443d5dfbb5d88dae79c013c678c65dcecc",
        "1f8cf955694b246a423ac725791231257b88936e00347ecaa1e17045c0ab540"
      ],
      [
        "480086b61a80c36cf1e1a350baf554e58ee8d9333186b70c9c512fb9e9d5a84",
        "511edfe58f8d36a6170df743731da1ff525cfd5108be20e30ac4183d1281570"
      ],
      [
        "3caf14fb1d2e90a13ad4eb091250fe37133aabf6029633e905e5a93ead41dbb",
        "49122aff6059dfda19e4b973aba5ebe3804c91728936c6381c1ed1ea9380920"
      ],
      [
        "66d1b8fb2cabc46cd79741ce1cb7326077ad8ea3227a6427244bdd3806bdadd",
        "4a52eb74f4d5371ba3265dffd61c844f9e68d4ff0b44dc4936182f9280bb66b"
      ],
      [
        "373330c5afd53c31257fcc9050fef873e15ea9f81d9810f30744309b04e02b3",
        "5889806607b3dc97a9c5b0c8a2f16d1792099a22866b879ca480cb89a11ef5c"
      ],
      [
        "26840d0ec69a22c6818ff64b8b14633b531508c866e21d1dc9239778ae9e8c7",
        "157971f9a6e3a24d3b307be0e7c8cd352e2eb5cad33cf276270c0f309ee63fc"
      ],
      [
        "ebb84848f1c38c19a754d1b5d9460e39624dadbb30800987c9419c0f933b9f",
        "517b297cf32f4064e6d6c8e761ba8db89809604a701c7b3aa1a9c6beb370ea7"
      ],
      [
        "25780380bc0795ed0dca727c55240f1d63593e552d224adb40df2d3721c0f66",
        "10215fb5a893e0275e9f1f66b217dde35addee91ed0e8f7d79531a2ff57b8c8"
      ],
      [
        "243e1581cd1abfbf18c31c19a4c3d1cedfe69a40bb57b607c9af2717eefc742",
        "1296c27929f14535718c3a4ebe045f00afdc60afc74c7d398d8ce1b6609dc0f"
      ],
      [
        "48babb8649e054bc8e0b902c89e6940c265f48464520649502ef1064eb94562",
        "3235be7852b0526d1a16f6969ec0e5b0e09cedaadc65863dea4e47f4f398264"
      ],
      [
        "592db7c27e63489ef4bcef2eafce89f40067cd9a1ba48bc3dc76b5fc62ad9ca",
        "48b7711b570cd9ac65910e75e752f4b751fdbfb4091a28f59b8c046d3d9f8bc"
      ],
      [
        "31d133456222586ae42a9ec7ce8539ee04afbe0b2ed00a2564dab0798d9b55d",
        "a77c52fa1fd718db5c83e7fda6d7d4d9aafef9ad95cad621470f2b753729e5"
      ],
      [
        "4651668379883521e7983aafcb93811b4a72ef2975b3277773746708ef3e3fc",
        "512507f3f544d80ba5d47f73b571881e8d70d7b1d305b9704bdad036b7abc47"
      ],
      [
        "26069e359b2e847affaef604f772f36224608b7642245d0e643889ed231bddc",
        "75ae1ec379f074ebc91270077c74b4d34347ce183b676b4dbe100bfff143b9e"
      ],
      [
        "3196d01d1fa11dc3803b4813c4bbc6326869f61410f2bd14bc0f570d875aebe",
        "20313217cac79875bd2a503db1e86d1e5559911667a02524759344468d9561d"
      ],
      [
        "483256607f75f06fb126addc60cadddd602154cc4782bcc08351a48745d0b97",
        "2950a7e500ebbe9775f08be37cc2e62ccf9030de18948d1bab07a4a9173f75d"
      ],
      [
        "65f07b6050a2fc6eebe2c29ffa62f764060f7f9d3c82d2cb5e4e368aaa442c9",
        "562c9654b646cb84a213b41de203c871b3eae0a05c9c105a66a53c319c06373"
      ],
      [
        "284870f6181c43f3b01d94baa9c5b6ada0deb861145523ad9169580eb7bed35",
        "5e03e6c40c1cfa3cafb01fd0622349871832a9d35499d06408a83edc1b76d02"
      ],
      [
        "32229810a52137f0e6c3d37595c46f6132822d4b05f42674b48d7a7ac3ad85",
        "7babde959a0cf2c53ee59fc52c77c3adf899453f077f441965629f9aead30cd"
      ],
      [
        "1ea8b98a6b85e74e0a2fbc18b206e290f3ed94ce99ca665e8e2351dfade990a",
        "478e93c4724115fb1648c8d5347422adbc1a0bbf962b2312e14aec80e1be742"
      ],
      [
        "270cbaa08c79140c85b864475a0bf569cc03ac785e57f543dc444f37ce746cf",
        "3a9b8d894016680ae9d1bf3deb931d8987d4d8d8bfed45b81ccc595ec79046b"
      ],
      [
        "6943922708b8ae5b40dd7031ef2e487abc4ac39a3591368285e83d6c9c51f4d",
        "5f157c37d09634e8cbfbef90ea50af59815d011e419a691c67ca3402b5efc33"
      ],
      [
        "48ac6a80979fab4912cf0cb557d917a0bd68825d8658ec100496eaae6ff62e1",
        "2b6931350ab183402e39476340eb1177b7006f7a552915581e29a79bd7203a0"
      ],
      [
        "e3adf9517d92ef22d1e2a787740a292ba32d5ca69faa9e8675f63ed816dce5",
        "36bccf69bb12dadd610145a3399213248d193660d8dc90a2e206f23bf2c7997"
      ],
      [
        "5e6c8ae5afb2fa470f767581f3d578cf6a49547e4b78665edfd45776948bef8",
        "6cbfc11953dd7e195d2ce74e52a60df524767b44c4608bdd755be4bc85eb74c"
      ],
      [
        "15a576a1242d39300f0db3ad770983825988da0457718ecd596c63a0a0eb4a6",
        "69a42e5f6f5a63349b57683a4609bba90f556a1680fa1ec3b02ee7d3211f903"
      ],
      [
        "274cd14e4fbf2ed07402e8ad8075b320c5f76b7ea45ea36af523e95ed63ab50",
        "6ca640f9557c5f2d8b27f6ce95b108880ff4e4816b26b70b6506114389ce656"
      ],
      [
        "4d8284e132e2fe81c5f71be1e3c79ab51b229e2c56c323e207cda179999d123",
        "116cfc00e9fbee1cf16af6282123cdf20eed13021c2037ef4c86f94eb6e6cba"
      ],
      [
        "4056194fb5643e97991942ef5b63cadd89080bf57a01489c4398aca03f0980a",
        "2e2cddb434fa6f6da7859c3d518f0ced8795eea043a6c9613fb3e020103339f"
      ],
      [
        "5d119d5c5ce532afc0875e0ee9b026d878c8773d34237f90a0d0670da6f01b3",
        "4a79fc025ce076b6a4742fbcc8cad313d0a8220c58024a41a5a674c0947e64b"
      ],
      [
        "11800ce4061d99b9d53fd4138802335258f7798c5a935c9979f5a949ce1d483",
        "36745a4741a5c7290eaa8f2a3f9ec955ccb7ca323272e5d35d35c2a724ffac8"
      ],
      [
        "4302525bceb97fa642fd5560a4a39fba3d2c06f68e6aff3332ff1854439ebb3",
        "e31edfd081ce82f8177b2d7d96e69851d09e908c2517114ffb37ee12c0ac64"
      ],
      [
        "2f5fcbb96f0a66fd3bdfbcc78bda361cb812570f50e7c476533d56eee01c0e3",
        "527428a34855b5695c479d8fb7e831a299f7897f36682a74169cc60d160df2d"
      ],
      [
        "52167df045ad0dc999b98de3d035aced9da4434211149b8cf4bf20e774580cf",
        "19051d2a1ad3fab190c5dfaf45188b49b4e90cca22aae54f0a785562d3d3f41"
      ],
      [
        "541b5332491dbdb2b6f6bccceb7634970c046963891fae936dd950f4432b961",
        "78fa54da996a51e3a9c06091d58c2405a806649da2bb1f323807c4eec50eda2"
      ],
      [
        "5f11e973da659b7738f87ca5bd4f3bd02207dd3c8d978f0d3e83fe81030febd",
        "137aba7027069f62d25caed416e13537687bb1428e71e5f0a0c52d52f2e65bc"
      ],
      [
        "15ec941ee6c2110b819b5541be52981c09d83484c9dc735c43f39f5778718b4",
        "4561826142dc5b56acfcf605a78a4090472bb61235bcd605a765e05d0a7e549"
      ],
      [
        "68ba398736d659522f484406110b43c68158bf4992094acf797a38979c587a4",
        "7c1d9e1702e28afddf22fed7a7a79df4315c174d0c6c4f4c75bc77d9b56777f"
      ],
      [
        "67889cea31c81a429fbae643a4fce0ecd690a5c32b99397e39ed6d7a08702df",
        "7ea277c80b671146c9e455b98f42f45b941ac95ca2d15c8fa9ea82ee9b45e01"
      ],
      [
        "596f2c68390ac26505d3c2eca5c77d46f8f3acbed192a2649d8c525a58d2334",
        "49f3bd8c62c610d5c19c52d970bde24b270c4ff7ae900453b909e72483974a0"
      ],
      [
        "567779fb8b0afe592cea284629e3621ccfae3c4d7d3dc559c9fed750591a395",
        "6010bdc33f1cdb374facefff537e7910b72a1120502f312a7ce41df0d552ddd"
      ],
      [
        "cebed0233e810aa6a29a8b0829d28f1c92f303d14dd73d6b12da98117dfc7",
        "4bdd51e1192a00df23aa8d0673e4915877ca41ddb8c9eaf21d39dd167fde7b7"
      ],
      [
        "4c7085f066adeb6781596771972b188177e63f2e2b3788d03e033cdd5af1f06",
        "2929ee89f525862b0cedb3ab9b5166e1680cb77fb4668f10a6a3d76b5434566"
      ],
      [
        "760e341bd836899c226176f47685f69438270c150c6fe7744cd723cd1e72359",
        "1bf09f2f1aac1a10ce8bdf20d5d178db747f01a4aa0aa8a5e4bfeef562cd94e"
      ],
      [
        "6016b94c00b54920027ef64902c61478244b1936337d2ad41d9a8d43dd6a4b2",
        "3bf3dd9bce7f6d6f120de87fcbce6219340b59c2c1d75ee0d45105d33aab1cd"
      ],
      [
        "4929e44ff692eb944d1045bee96e750219cda3bda0500029f0df49a1db30b5b",
        "2e138dcbd092242699004b4ce98764ffe4e892841f56830af298581cd1e523f"
      ],
      [
        "5972d0e526311bacb70a04e88969b6c63c7399b578f0dc28bbd00d65ef01da7",
        "76b22bca9ac12d26530e7b0757e646beb3bbc5680d0f3f82fb8ee57ed4b5e39"
      ],
      [
        "2ca0a42a26e26934ca2d48db960b4719113d87c5e57fb437d557c5eb4e03ac7",
        "62778c02561d4ec5d83a132afd7763a8349207c6b5d01fba70b56ba660cba2e"
      ],
      [
        "5137ee53f076e21a2c23da09f63c0d275408c31e4634a6b6373be5cf13e6c00",
        "14fb446c077beb78e04de3282a63bfde12f9af85caaca4ddfab506cee31c0c1"
      ],
      [
        "7d944853d1627b63f560aeda33acf640d35a4ee4d23a744957a2dae9d5b7c6c",
        "bcb411a210710acbcb9ea12680d89e3e4e652228b6786d3886e95f4d9e6970"
      ],
      [
        "37d412c2ffb173a728477446b60b2b702d07a5243cb5fc8963e623a5ee75843",
        "672c79968908f92cd0cb0b4c65ba86e8f359b015623a89441e1bf859bba84cb"
      ],
      [
        "5b37f472aa80398bff12cc74c8ee784c4fc89757292580d3a498bff17e9f114",
        "7d79da1aab9cfef58a5f3d1c9ec466956a45f8d2af0c1da6dd4c93f720fae6e"
      ],
      [
        "25c09b3f1188c562571536202eb0f5fc4b9a7590417b8ea58b4343685d88a63",
        "3d5b817c73b37e9a1d24ca923351359b42ced2f3cafbcac8c2d6322dc767bb"
      ],
      [
        "32e60904e73f9756f71e0a918d302aeca17cad4acacc81bab15702ab5ff78f0",
        "bcf4c0204f8275072f98a65b09ac58b87cdc9c70c4edfe99fe18870a3a5459"
      ],
      [
        "49c35575996c1517d2daed90d2fe4a58e674d6b4aaa7288d0642c8bf59e562f",
        "57eeee00adea4ca80eeabab57852cbf03f1a57e21872cd44221e0550b9193b8"
      ],
      [
        "10e1776b4c2a867bf1b028c6edec224cc6616c747e272f49e69b67b02a893dd",
        "8d45d62ec8e627b56950f2f7622a0438647f9e9f28e723e4a37cebc039a1b0"
      ],
      [
        "79a93a75ecbe943acc964fd39ecfc971dc6555b2bc335e7b53f52f4eb16cd36",
        "146132a68ce2ca8b48363612226771ac547eb3cf52b6eb7981718faac08aa3c"
      ],
      [
        "6b22d32e0590e169504e7f19864fd646d0994e7ed3e578a5b88f6e095913439",
        "68c3b22d859fb85e5c8fa0a8aea932285945b230957e603394333e9ad5acd82"
      ],
      [
        "71ce5ec8286eb8c93b8481c6d19cf0a288ef4da4397e9c80f65023e516bc097",
        "54470babc742780cd8a05499026e738ccbf81d4170d1731734de68a8e5b402c"
      ],
      [
        "27beb13a43bc6a1f6ce046da438b0beac5899ff4d57962dcfb6476b563f74b",
        "14074e9e93ee45394dfbe833998b9d1691961f8ba3166224b36404448c61bb3"
      ],
      [
        "6b1de6c8f161aa6509a1dcacf2c0aa1bcf6ee9d9b40e032a9d72f77a6fa298c",
        "5e9312eb5b59d6cbadd7d3dcbc39f1b5bd9a8346fdcfdf1107bada6f9cc048"
      ],
      [
        "32670fc3fa43bf39974ba72ea51f0d045d92d084a81fe5282dfc8309aa900b9",
        "518fee521bf1af62356aac3b7e53fdbf57121e030c6e9572b3de69912ca4eb4"
      ],
      [
        "4b9ca363eabed9c66091a347375f7065cd28f49f914447de7cc1461f1375f1e",
        "3a1a3a2e5e7e72476befe2571ece708052d740d02cbe6fed58740968ae609c4"
      ],
      [
        "4cc6da42863a3deca62fa218b7a3b50e034eb4bafd393eccba3f4cbe192ef10",
        "20bfa683c884f203713953b26d2821287ecd305fa2cb70570474533fc07f918"
      ],
      [
        "87705353c44a5ccec8de65cf5433be6b3d9bd21eea49b60e6c907cf1a67a6a",
        "112804b13eee56e3b01aff75fa08fa8374c44fc461aed8a30ad54acd09c24eb"
      ],
      [
        "6cf6eeeb9d339c0a05f72fd5af73fc7588e6d957100ee8999109437bc126cae",
        "54fa257cea22032eac272fcd034dadf2e00d602ef9e519cf7072023c130aad1"
      ],
      [
        "19b32925048c5519d929650c833661b452ef7be7963fab0b6b328ab7dd7a28a",
        "1bd0c14a10bf9b88ea61011c0b2e64d07da151c6203800d5a5d12063838a510"
      ],
      [
        "12a5fc5559428bc3b4eff97b21b63668b866e0722807f1db1f19696bacd9b0d",
        "4c2eb07f0c24047a3d73b560144f3fd32c99d6dbd9fc7cd2fd2a72a6e4b24c7"
      ],
      [
        "13662b7a7d390aa76eb86a7c3bff6d9913eb28db6bd1a7c42de5cdad2e35ce2",
        "40626aded7f56f82cc431ae30527b096f57fbfbc04d3e12a5abae3edf301cf1"
      ],
      [
        "255825bd49b8a2cce114360bd9c8fe8c641af64c8e7710107213cfcb006f43d",
        "3619cce4482335232f9e76a1460be9d296f2d468d26e4f95a78c71524fe59cc"
      ],
      [
        "7f83009eeed4f12f54d341bbf06066480cfcdf51dda103ac54d4bcecf6b3b31",
        "4269519d28faafd7fd68bebfd8404d71ba05d62c4bb6d65d24aa6802fb84ab6"
      ],
      [
        "2f325650eb316646b4eec903fe44828fcb11054f1bd42ca3a77f7e734110b35",
        "44f976082271016f9048e22c507d97d628722bb431f8d5cc1890524e6c386bf"
      ],
      [
        "750b166bb6edc0ee80fae39c7c106879036738df2d79fb2294e1c21e9a24d6b",
        "54f8aa297a1afafe2a17a3254f45861167414327e918d17003c6aad01d0b24c"
      ],
      [
        "3aedb10db9cf3285cdeee375879396fac1fb50dd259e1716f8c01e66f67ca72",
        "7feb9400f621f58c21601f23b7ec7c94a9b6b193c1cd74a8a60846aedadd359"
      ],
      [
        "4ab7151702de76faa493e7a0b1ac20ee4d10c33b83fec9477547cb1236973eb",
        "63f1f122e3ef3acc46b0915ac69c3f5772879799cad889a817f55f5853d1235"
      ],
      [
        "1675ead0d20e5bc3a7a7331999a87ac4c916ae29669e54197bb02aa6364520f",
        "4d1122da90d49e491922d9b533a6a668e2f65a2737ebb391ebb29fb7c1f8a9d"
      ],
      [
        "2f7148111ef53c613157aeec12e16a20f13481da4390b6ce18a85d1d8547087",
        "2eeda779ab395597651d2a0b833ccf53b10280750139916ae2baf4ec57c633d"
      ],
      [
        "4439c7810e7b2ba772b701ec3acdca0b80c9df23047710b87f7dc3f13b337d3",
        "5029cfe704c602a8a4662af0a5860ec03fb88f046d0e3400f2ce7638014c621"
      ],
      [
        "2248eec40b5732a6a488b681f093643af7937071bc73118acae295a32b51b05",
        "1577e4aec30a97b648de4d0b19cf8891151b4eb11f8de9c6d7312f091552e19"
      ],
      [
        "4738424e558d4e0d87a3124ca02ea24f0adc6b7a9768b0d3945ed2a6104857c",
        "33576f92aca3f0c8ae689c3c274c2de6b918940d86a6852e02fc99e35d1614"
      ],
      [
        "7829edd8b866ebf7baaf604ed13d19a9797578f44bbc51b1cd67ca53803e96b",
        "5559040a6083f2af1f9133ccaf5bc2ce06e56ddfc7dd410e9635c0116b62722"
      ],
      [
        "7f927b881f2cdc05e1a69e40bb714af47b630d1425f08ab5d574ee698f33d51",
        "26a465288e96572de303203bd38f4a03031e8158da0591cb037c0a5111d1056"
      ],
      [
        "36a65598552f8753580d1655417d645a140966e10a1e1663015f9fdfae44881",
        "33d5bbfaebf59eae72b89b1aea12ab2ba3c9617f8c3baed1ec16bdf668381b5"
      ],
      [
        "403becfa545c826782026ff409cc16c9d4fe428f1b5b6e630c92439d2fa5fd",
        "47bd6f2bf5d74f710ecb479c79b01fb774fbdad590e683a415cdedf33f71dc5"
      ],
      [
        "3a747826d241b877d3d56b16e0b810cf088eda4fd6048da174c9991a942a5eb",
        "2c7ba19b0a3486a2cdb84d4a388d34beb077a0e467ba44590166f93f6a09d2e"
      ],
      [
        "3d60cd375842714b37bda89dd1f13a7e0f3ff133b522209617d031bce05a537",
        "f77f216451ab01ad5226844d2162a7f32744688bcb4325445539e2ce5cec4"
      ],
      [
        "235bf66f67c9100e7f0e22bb299cdfaa603644b240e0770aec7e7fd163e2a65",
        "37110b3fa83ece3990afca2bea8d5ebb3c7aace60a0147f8e6ab733e2f2b4d5"
      ],
      [
        "3b796d4eb69a55471fa86108f787b3604874e92b6887a7667a6c2bfbbd9a42b",
        "4912d6dc0419732ef82cb3278415851d4e2d7ca89e0f4d7128cc9de51b810fe"
      ],
      [
        "48d53516dd51e49faa7ab46c8c10db1befd10f23c6a9d9bc3640a2f0da44518",
        "73a2fb3d064adadf21aa1362c04affc660598f38a9e069b3afb74d0a99ae9ee"
      ],
      [
        "48c32cff161ed145da0d5b73084897647abb777adf65738559ceab6939cf3e0",
        "3d99308978e828f857c382df32b472bda81e8ec8e30c8844077ba6d6d2ba903"
      ],
      [
        "2947ff091a8ec9684affbc9a62e09e598841c4a6dc638088492aa47dea57097",
        "19a2cc97975e547f97a4d02e42f89e6ced6f5a953cfccdec347867d26926541"
      ],
      [
        "1960d85f30475615f82484eba0bdafb7ea7cac3809f0518a757d66f02b01676",
        "36c8f77baabf0cc8805d993bbe62041fcf4e3239cf9d53278a4fbd91e75eeb7"
      ],
      [
        "2765f28074d21d5a055340b6d40092d2bbef807e02009fabfa08ec0b9bdf38b",
        "7fb189e0553d5df52b6843661814824b3f3cbebbd54988f042fb256c6bf30b"
      ],
      [
        "348836cb2aaa00212f4b1a4e2d7fc5417f246bf2fe5c9a16ebabda449e2e08a",
        "3f7276fd7d69e0d55ce5ee1d2d830534a27227fe0b6d8a36c93f9a78b872969"
      ],
      [
        "7afb9d34b6a42ea8c6d870e4b8191c274201dc1f93a1a2219a2392b7e345a31",
        "42bbc20dc7115e0758b364a110227b16b64ec58fc535ce5ff1a9ad8b8a09fdd"
      ],
      [
        "2cae0c2afee1767fd4c66f52e1f176d217e92e89cc19eb36d5a6c1715f641a",
        "5335efe2d9bc3667d25ea88bf76438a4d6ab9ba5c512f9da7d0529b79b62d83"
      ],
      [
        "1cc5fde334707723c3a06f00c106db88664284a2df47bb6b144d9f960aea3e2",
        "dbbf610d100316938bcd8bcd078513512ecb50d4579690dbefaa419c05980d"
      ],
      [
        "54e90cb8f3a2998d2675c5780679e06c0556b1e618f8fdf07f9a4b2466fbf1e",
        "16248676b6f06ec5e34994bc3115f85c8147b54f34d8500928f2fdc051e2089"
      ],
      [
        "525c70a2ba0dbdd68d75640f47f13d0d415ea595f7030f533f4625c2a46523b",
        "58292c8675e5e1a438f49e0c05648d9a7aa997f2f1fd77d5de1944afe5d7eea"
      ],
      [
        "54726d78d099007393348787a03107ab492e59690a46c87fb02ec554f2353bd",
        "53b54b77184ba75a3391e0ebfa6d6974db028f3f8e34bbd5460759a5848dd76"
      ],
      [
        "4ac81a66903537769d3aac6c483ccc08535cb767b6b5e1ec8017a7393ab70ae",
        "2cb22b77a8a05d26f11a4dec80eff292633aa05553a889c5ab16b6ac6e2ab17"
      ],
      [
        "21d0175349e21114988a2930b9a607d43245783cb4a0c984ce27f4c4206708",
        "59f1f49342cc5496213d3329bf4ca7fb0044337449c579bf53147a1dac9e67c"
      ],
      [
        "167f821b381f4c8adcc39789475fb55ba639e5124fe75f26dd61be396dd5e66",
        "22002c87d4cafb47ac9d27286d5cf5ff7a6715d69814118269b0729be9e4b3a"
      ],
      [
        "31010666c6db83a9f9e4db4c48173afd405783ac53852a6e38a8ff925528843",
        "1f466dc9b5d9094107c741dbf380f9fd98d8549cd50f67169901516f8cce74c"
      ],
      [
        "1ad3875769a5053388a86edc85dd80fdffbbda6a456aea497ff81a0f1f6707b",
        "2de7cdec5e2bad56a71bd2f33a4ae4c874e1ad4210a6ac32b443cfa34e85b1b"
      ],
      [
        "c489650fb7f459ce09cd05a456fc5a46b849b38a671298ed645bcdaab168b0",
        "45610d092b8af1c43ceed474cd17f7bbee65120aa6fa4d37f949e7e41f25327"
      ],
      [
        "394256a5ef4d7af5459587a0bd2edb8acaf5ecfef2563c9a04daf34a4abe4c6",
        "1ebee390dae1403c0c53994e1d064fa64e20fcb45392e209b2b99486a559ffd"
      ],
      [
        "410a1511fead6151e9bedb089b9832d0fe01fab76d3f8459929f767525aeb27",
        "361f0a5ffe09fcc3ad4eff3f5e89508ac247af80267100b69de3c59df561cfa"
      ],
      [
        "38cd437c9f659e110a869605c182ee9fdc26de36baf559d9229e258267bb734",
        "624b1128ea7739bf1cbd0e423af92a4884323c868d2ba0ee9d362946edee2d1"
      ],
      [
        "78b126e50b7042d2a019f95cb87a3213c664ca1bafe345999b1e9e2dac1e608",
        "19e398196b22f4488cbe854c614ad8c353839abc5ab3a4f3f5c03c16ba8a198"
      ],
      [
        "6d3a5ce91132f385a91823c5c8046c4b638f5fe63357424410d901457cdb867",
        "7b80bae16d2d487e122495174f7a70992bc5dafbed72bf84127ead7c57302bb"
      ],
      [
        "32d053a904dc4d88fbe7d0b96e0cbeca22a00aa5c79c753d52b0b60abf31602",
        "3af6a02e5cae6d6490354ae51185149e3fdb6d0d9caab90e95ff58aa0c40377"
      ],
      [
        "49b1fbff5bdb0aa6938b066dde0ed772c0d81f9eff52e7fe038b0ccbd78adb5",
        "1c6e57834eb14d507eed8b36c81ddf92fa91c242467061927a742fafa82b43d"
      ],
      [
        "2f28b8994ca6f234d9293d26196b43b9d1d5306844348c4a638102c05de85f5",
        "759cfb172eab065d477248b3569f4ff5791055f01e95fe71b94b8e615d73c96"
      ],
      [
        "3c2ee954ff534f856f59188fa0f29ed8a022aee0cac52d634f6dc58cd514d70",
        "22bd162e74925f0a876bd8a206b8767dfdd7c898576a73a490f138d9a7f99c6"
      ],
      [
        "5763a7cab001e1aaeabf9ab5b9b2fffe6cc2b299ab04ec4933da74d960e1ab",
        "715ee4f8ee93ab5a1dba00f0a6abc4eec47d49b61254cc27fc36a031e32f0f8"
      ],
      [
        "19976ad8d7b7f47c785408243a227401996b36e47c7a78a7bc7d4256233ba9a",
        "896b713c5d7777b0703821a73c1d9a4c3755501042120534ff13990975e1f5"
      ],
      [
        "61674b992c29827186cab5ff454758dbbed8e89bc23d0bd33193afccc3a04bc",
        "38e1020744c13903809ea30a0662fdb5226ae760cdcf10800faabec452e00f8"
      ],
      [
        "2ea2d48bcb83c0c9cda4efe11f07165cfcbc9ccd26526e5fb12556316d4b1df",
        "1d2d68b74ad384c5c4a9c85453104216357bfcdf635680b40215f0f800974cb"
      ],
      [
        "7881212050264c40c336ed3a15dd2cd868ec9a558f5b728869eab66e8b8ed54",
        "21aaefcc8ad8a161b8971d6880321781dbd939570c540da4c330922b8c81e9b"
      ],
      [
        "b6be88ce0461d20f59c5199573cda0170b61decf6e8e69a6d32f1695adc4ed",
        "5536e4808370716f2bb3423a9a49a38ddbfe91faf3b7a35eb53d3519238b6cf"
      ],
      [
        "e5972af1655eb6dde2e8c77cc58044299922441b5ee41ceaf5cafedc765bcc",
        "550282f37a4783dd60801c237045992d6fbe82a5902e7d837ea25f6f98c7b3a"
      ],
      [
        "7efc1aad1f580d8f50274f1c114c40056be19a8c96fa8c4cb5bf85e1e7f3e4",
        "2689f1c3898b114d668be6413643ee9f879913d40c262541fd0316264c60a4f"
      ],
      [
        "7939db98037f59b0113e9d60051f75ac9c3cfd1a3eb535c73e2d945068c6c5c",
        "410914ca8bbf3c65cdf3e9772ca790c19131c50068d34b7346c10260a578a8e"
      ],
      [
        "225b77ad00a2b83d26690190b74867326eca4f55bfbc3a13be036225ca3b1b5",
        "411faafef89042ce6beb64309fdaff70fa53e9d32d79a21e7f82f80e79ff05e"
      ],
      [
        "1501e64c99c8b6658b0479f2c05c9142d246eaabfccf2fcec8dc4399539d8e1",
        "3bab1e3339e42c9ee66c65b0b20236fdd9362d3ce786ad3a9779ab578af50a8"
      ],
      [
        "59b907b941f24fb8ea2458153e55f07534b388e835af7b69f3c9f54392a335",
        "1d5438c4f2f68a417f3d56f916d899a6ffe910f5f2989ca31687f1b10f60db8"
      ],
      [
        "2887d08a26f484546f360e33abbf7a998b7170a5b30070938b84f072c676bf3",
        "62a78e8d00e5d3a59e2fc424ffa08961567ba1ef24c8531cd7bceee6074a535"
      ],
      [
        "6e3cc8076b3d45377929033af35aab0c6d19ae4fd47c0daf844079ca04c46eb",
        "7b90f338e4d848aa8f19d0b5c3bca916a2a9024acbf14bddb278bca2aa39e5f"
      ],
      [
        "34844dacdd3ec54a3af328bb9d67715ab33425e194ac9977ca02ef22e8f7a88",
        "3c1affc6372f32a1634748124f9e1a03c4f0c993971da0dc28888b0801279d"
      ],
      [
        "436b192e03a49796cf9bc5e93c88268b71c9c24f9c3a85322bba634ebea309d",
        "67a8091ef69d62abcb28ce5df4dc7d53f8dc2b9690344f75ecd03a6d9386044"
      ],
      [
        "592d25b68baff87a6d7fd41ff0dadbddc1bd1316683de3b2d677501c0eb14e4",
        "27ad1e1099683f54589010faeefb19e38569ace43653be8787a42b0591e7bc5"
      ],
      [
        "89a5111ae911512ba62e87b97f643c0219702f235c70f62c6678a129302009",
        "557fa3d98e9ce7b83b47545013a4498f3de43787fb66b1a54521222242f7c1b"
      ],
      [
        "1c9b5e53377e72da5066cb08566bbf9ec31ec1877f455d932cd9b1aa375d34e",
        "72f79555a8bc207863f32d482fca54692825449fd8963fcea3de3a8183a739a"
      ],
      [
        "574a6e05eb14591729515be239ea8c1fa9e12d4049d42876f76c8ff37bca03",
        "5f99b3af43ca68c1c73e8190d5f73c8de162ba643d7d5f0cd73cfa8135db6d3"
      ],
      [
        "513fc5c2e16505b2b25a2f284e167d5401194bcac0dc3ecf8b7c9acb560daa1",
        "687ee7a1a8954d08d3856e1a16ded808e419e789736d3f55f79f7693bad69f5"
      ],
      [
        "53d48bd1205274b1c2b0a0ceb3d21c5fcd7c8892a784931603240b288a598b9",
        "35387abd7ea59c9b956de44d36533cad1f6668c438d666651695ff3862159be"
      ],
      [
        "213eb1ea99e08825110dd61094eb6e8145119dc1c507636f068730b1e086d44",
        "744f6853f4f02f4f042468d0739e0c9f64df720b87ed77d1979547084ef7a89"
      ],
      [
        "735ef017d091ca23264ad0aa7bb9b2be3309b4539605e79ed4a652ccb2fbe3c",
        "7f0ccc7a5747c4e921fff97d431169f690763427e2cfd1ad74d7a0308d7faa9"
      ],
      [
        "3f36babc5a30070b610ed97db44997e6d9115c9c0579ad8f75d295a17130001",
        "79047908a2474e32d5c712a07bf5c4ad522590bb5d6cefda410d30528e12ca8"
      ],
      [
        "51c04907ae88a5926b242fb2862cb1f2c651a94e6caad5bff8601c079fded74",
        "10a585a269f460aed43f54c7de13cdf623fc8de5957526997278be939ef32ad"
      ],
      [
        "c1e1bd626a735aa2c065831317217ecce68e377eb1f67e54ce2e97bc2ef2dc",
        "53c5af23a9b482f420be6dfd37b6886154cfd130794098e1f51c1885ac2556a"
      ],
      [
        "5aff3b30775ae4758e604a4a6262803a545f5ef4e7855fa245ac6a6431a9ece",
        "39a4799e5519047f29333bee9c86c99bfa8056d4aa381c396c4a44331fe795f"
      ],
      [
        "3d753e9723701a8e9d99b91bb93dee2eda7ffa5072fb2cd5c5fd99aebcdb299",
        "15798bf5c17d6d5880fed1553af32dd8d8baf2888c715a886575448a24c7975"
      ],
      [
        "6593e5078466b07a4222d2e544da826d2c583c9cc5f2eaea148b129b00d4aa0",
        "11b352b08a0a61d3cd67d1dc08069dec3bde907b3da0f56de5011b956bf8744"
      ],
      [
        "7a6eb353c5be9ff03fe4a06c01fb71aad2b38144179a291ebcbb2c2417cca65",
        "3de3ecb12f2fa699b46a9d399abf77ca17bebc3e491bfb2542dd0fba991e2bb"
      ],
      [
        "2c7ead583d6c32162091034a9eddfa775b4e84b8bdbea939edb2a80dcf64f6",
        "461790ce40d9c276d962b2a1e9a74d66e9d7335962e234e8a2fc6963d31722d"
      ],
      [
        "34285af023d9b4c2c2b88e8704bf2c05a9b553b00b2e70ff05f8c2970cb134f",
        "33fe678e7671760a83836107428dbade68c3593fbe568f3f8f1b2c568099c44"
      ],
      [
        "6222f720a24466263db6a11842f117fc4bb78da6705f140e48869db3e087441",
        "6eff5b9bf3aeedc962bc5a24b66e7bdad2153450ed53a058bf2c8dbf2907693"
      ],
      [
        "17c6ec5ea206eb97cbf53851e37ce391080e0d2bf1e5395610f79ab0503f7ce",
        "3adb71ca3523d88ceb1e365f12dfb24895453c14daf0046b2626cddadfdf5f7"
      ],
      [
        "70859f9771a713e54974ce11cdaf44b0dcc3e9befa0c0834908d877eeaafd27",
        "d18f794bf0cc0623b711e7450030424e52326c45ba9b03341883ae4828a5f8"
      ],
      [
        "2a820cfd0fd4ab0871e7b303cd545a3086caf8fa818c087a4017197da74efbf",
        "5f992683ff37f6c041b84bfc01503d333ac9763505cc8f69473da01812969d1"
      ],
      [
        "5b0526de2c07fe7cd73e3884f642d57a0ac5e13c68590ed03a14e530616e8c1",
        "eec69d0cbd92c9fca31ec967dba848bec368e792d6678797946a5e34fe3487"
      ],
      [
        "6cf6b3efee707210cb3a72f1e885c3d0953aefb43e5e148c740aa1641725c61",
        "911cb630b898e2c1a9115f9e45bafe3b819edfb1eab6e15612d14289939984"
      ],
      [
        "74e913de55f1e46143cb2ecfc580f8d3d3908f200281322b84e21c989cda293",
        "761d2736c9ac7670ba905bc2629c6c0dbe988820a4454ff415ba68710f7df92"
      ],
      [
        "44084305e0c911a40b7cbefe5f13cffe9a99375d1a584c4a2200958050af7a9",
        "249c83877371564708ea525b64b1e7e12785460d83364446531c9adcacba5f0"
      ],
      [
        "2bf71ad4d1bee1a67fb300477029f54bdb0e09f78bf2ac2e8afc7465a7adbcc",
        "6244dd6cad282539049be57487bfd9900bb0d5da805d02b535096368fcb4cd5"
      ],
      [
        "3a62d8f763b62def36e4089458046a49c5ecb91b861549530773e0548ff2bb",
        "6a10a03ba61e6ac657270465c09aa9526cf1ebe96bdecdf0e7000476a47b9eb"
      ],
      [
        "284eed3a17c51e0677d4fe897f056abe9def8af07a4630e6ca5723e2aa6677",
        "516a06ac1d5626ed03d2eee9de6f60f0311eca703a99b0fb31b9c66b01c27c7"
      ],
      [
        "2a2c63b16cccd685f731d06fe93ce2cffb358d34d03dda9a7368185c1eb0c32",
        "7180baca0ba81284809f92eca1654cd76b925a9242e5d5e0f18d0a55d13c6ec"
      ],
      [
        "5f9466017ec09769611389ea5370ad68dda936d3f5816c9e928ff9574abf9a7",
        "6619b5b145bb5f4f29deb7a4cd68ef4da3995312fa6537f0d01684da4267ece"
      ],
      [
        "74f229babe01b4962b3307589c1a13019134b1db6822698388bebb55d21c30f",
        "156ae857ab3279f754facba0db36398dffec8c31e5e160473198f2f891b7531"
      ],
      [
        "334b9fe3a5fd99bc966ddd1309698fd32afd1f235062f2c275b6616a185de45",
        "221a60053583cc0607f6f2e6966b62fc9dac00538bb7eb1148e007a92116d2"
      ],
      [
        "7ad710ba002a67c731efbaba2149d16fec5d2f7aa3d126fd9886172e9f4ea30",
        "3a10f8e902a7a13aec94d66415347e1314f9bac83a7db176096b809b25ffb86"
      ],
      [
        "4306dd0a184a3283c3097ff8f7434cec80912e9dc04b7df21ba73fda9f8e6d8",
        "6d42bd3d1a8dbddafd09e872e2aa3891ae79ec939dc1b382196bc21c4ab749"
      ],
      [
        "1c3f2124e1135c32a426d1d14e471edd9e0f2c7bd703ee123cbbd608e8c4be7",
        "3cc607a3c3f1ab68dd5fa56c65996002721b8ad8ad4b0dd9e5b1467d316583"
      ],
      [
        "294af33272ffcee0b56a436de1b73759cbddebef4c07888b42c2f92b0b68e1",
        "d837164311d5dca8d37b99ef9eb22708643c83d1cbdfe852f63ea07b06fbad"
      ],
      [
        "753bdb5439a19bbffdfa02b1dc24e8368f22d0a8276b109c11e6feb26f56f39",
        "6ed396231af93647633eab467f1a034f38e76823eb85baf97cae56e2dcd9f75"
      ],
      [
        "5674f0cb892b733fc0b50e121d8679afed0a925c32594cc65ffe83bebe7748e",
        "7fbf0325dd38dd94905adab2c52758552292a6a103d9edfcb11938828e828c8"
      ],
      [
        "4a8f053573a0a74251059d0229d89b6660407ba0b491779fd10f87a5117c81f",
        "21b70112485398bf67ec9d733df24a1df30dea718a93b786f41ed04e3ae3c5e"
      ],
      [
        "726c01ec4a08df8fc8de173311f50d4f3b97c5a9cf68c1536146f827db95ae8",
        "15013cafadefa7f1c4e4dfdd70bd4d3979dd18bd7f0332572ce2a3fd8773d12"
      ],
      [
        "38ac0fbfa98937257460db7e6645d7e5112b6fce7234813fc8a704e8ade8da2",
        "73c0109f86048aad08c443f781ae60ad13b99f7b9cfdf3128fe6d6eeb799a7b"
      ],
      [
        "6f6d3a38621582ace092eb50ecfe9eff265df141ebdcab8653299116fcea291",
        "4a1bf3f39bc919c8f1b720a0b1ce952cad17f2ba98308ee6b76dd9b6f3d7b75"
      ],
      [
        "6a307fc28e1df8d9ad01766419e097797d65cb674436fa1c8f012d3de2c2a1f",
        "26911a635ba824db004875d79dd84834a97ac12643e42829015bf88c1fd6f05"
      ],
      [
        "2a74860e3336d6db916555894cc8028f41508812925db1925457afe40257155",
        "5f8da573f4c39816ce2dba8a20224223a7cfec53117ec78973930c0e9b60244"
      ],
      [
        "4d2b49e1ed0799f719b8269f092cb489a466a645bc0ccabafdc678864c176d7",
        "5410083df7d256f18cbf5697ae5e52c31e075d8a3b27e21d6f5177ca882f6c1"
      ],
      [
        "110ecb9fbf6c333d168cee473cc5ad98809b6cb9eb5d1f6cd28ab5fab504fd3",
        "7e3c54d7533d9f8c3310f219dab0cc3ea4d39b418a748eeffd6bae2b8637a43"
      ],
      [
        "5be4d711b80da70e6d3ac493250bbfd16f20b25f31919b3a91cf14ffbac1096",
        "7f55a0919f082e8885f1515e83c5b39b6022404503507498e1b4422d79c43e2"
      ],
      [
        "2605125b95ca4ba93a21cbbba5762898a7cf9e988f07ab9e64cb3868e3b139d",
        "62f0ccf55b9fc0eaf9736fc8ee484e2acdbe259813af9803cf815829a5e9d3b"
      ],
      [
        "1092bbbf206f2a3068167c3dd99a72de31e206f6c504c071c8214d105ff814d",
        "309f489f68a62089f53b96df5d4fbc3ecc5a1a42eb7ece0e49bad17ad490ff4"
      ],
      [
        "2abdee9409d9c92559ca3f4e6bddd649c31aa09b90bfcb4a612af491241e18d",
        "3ffa8eac180a29de3f8a69efca84bac046f921f5725e96a6ff0530be1436aaf"
      ],
      [
        "376313f27d00bb1aae7ec991745efe6ee28c6b50de0c6cd9845cc4bb4f83543",
        "6a8e0a9389ba528b156fa94ac090a895d7b795818d4941c29415d9e2984c547"
      ],
      [
        "a80380c71bd466a696b3f0fbf02817c9459d9798f4f3899cf32edf647fe066",
        "6a09805e814e7cdfc76eba4b79f1df5ae559e0f0aba9f728d3cba4ea5c57471"
      ],
      [
        "223694b921d247d989a79b9b2b2f07496036c40cb043eab074a9d6a2cd2ffed",
        "c247217f1b1df35e30d9e15fdaadf42d6fb0edd3a5a7e265d4cdc426c120aa"
      ],
      [
        "102333620df278c6714bbc880fc087db58c1b9b4d77ed4d61b32a74bfc7c3e2",
        "6a77d37727ccf71c2caeb151faf4404d4b94e9047f9f0a7c3966367f3b53c65"
      ],
      [
        "891626f466536929ee7eadcd18b41925706dedab7528ed5f0f7abf039eb9d2",
        "5f73d11c141c933a35b2d0d06e5cbae614a20d17dc3b439f8bcdc3413c5ea37"
      ],
      [
        "215c23fd3f073f870e5e80303967391bf173f8adcdbeec72d131c557babc203",
        "10634332e9d9439a321597dc5b0fac9ff478834c3d6e281735f21a4a5e13266"
      ],
      [
        "21ea0bdc1332bc36e6aeb43be9071651c27e4ea2eadec636c8d818d4af72a36",
        "3a523d9643dccc6bb9c7c58413312caa3e60ba9c7c7f0177e0f3f469a3241e3"
      ],
      [
        "60deaed1bffb6190beed40caaf2bfab5e43d3707aff7ad3f278d571aa247eae",
        "e41f71ff254c1418e6a66992af307789fe04d6606fb2670900bb1a089fd879"
      ],
      [
        "1e1fac4a1646253fb1332fadc21fbdd3e3a24a840d129400f520ae4116a4cf5",
        "69c406f9f46576afad68808de0ab7e8922b6226af748e721d9097e21f1800f3"
      ],
      [
        "5db0ddcdf79ffe74d6454c12d2bc60b06776db03c75dc413f5be42ea9a91b5e",
        "134c3d6c699841f17306835bb193785228ffe7ab212a01a861c56b086a18cec"
      ],
      [
        "626814e320fb5bea505b248fd1c1389ad586c1cfe04923fe2f83173e915f4f8",
        "7ae407a926e887206a8b85cf485f1f327c9bb8ccbb6897024e2d122877d8ee0"
      ],
      [
        "23186237dc7d3b570cea645282ad4c359731bbfa54e7f036426bf6493812cd",
        "7d1fbab7e61a22d3b00993290d9f4cd5d820061573e787f66c2cff9a18e1eaf"
      ],
      [
        "54302dcb0e6cc1c6e44cca8f61a63bb2ca65048d53fb325d36ff12c49a58202",
        "1b77b3e37d13504b348046268d8ae25ce98ad783c25561a879dcc77e99c2426"
      ],
      [
        "13961b56b9fc0e412e468c385c22bd0680a25624ec211ffbb6bc877b2a6926c",
        "62f7f7792c77cd981fad13cb6863fe099c4d971c1374109185eae99943f16e9"
      ],
      [
        "47abd7308c70659af3f00fafe6837298af3cb530b6c2ba710ffd07a6bc1ae98",
        "75d0c8a7377aa9f0663d0c124a5659750847afabc29e39893fd27534a4a03cb"
      ],
      [
        "2c6276b764fb398fa555857dbe0ce0ec18fab7a233bf23851295739801f0585",
        "5d8f4897ce44007ec5bfcb9aeb78b8f6e1d40a514f72d213c9300d2770d2b8c"
      ]
    ];
  }
});

// node_modules/starknet/dist/utils/ellipticCurve.js
var require_ellipticCurve = __commonJS({
  "node_modules/starknet/dist/utils/ellipticCurve.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verify = exports.sign = exports.getKeyPairFromPublicKey = exports.getStarkKey = exports.getKeyPair = exports.genKeyPair = exports.ec = void 0;
    var elliptic_1 = require_elliptic();
    var hash_js_1 = __importDefault(require_hash());
    var minimalistic_assert_1 = __importDefault(require_minimalistic_assert());
    var constants_1 = require_constants();
    var encode_1 = require_encode();
    var number_1 = require_number();
    exports.ec = new elliptic_1.ec(new elliptic_1.curves.PresetCurve({
      type: "short",
      prime: null,
      p: constants_1.FIELD_PRIME,
      a: "00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001",
      b: "06f21413 efbe40de 150e596d 72f7a8c5 609ad26c 15c915c1 f4cdfcb9 9cee9e89",
      n: constants_1.EC_ORDER,
      hash: hash_js_1.default.sha256,
      gRed: false,
      g: constants_1.CONSTANT_POINTS[1]
    }));
    function fixMessage(msg) {
      var pureHex = msg.replace(/^0x0*/, "");
      if (pureHex.length <= 62) {
        return pureHex;
      }
      (0, minimalistic_assert_1.default)(pureHex.length === 63);
      return "".concat(pureHex, "0");
    }
    exports.genKeyPair = exports.ec.genKeyPair.bind(exports.ec);
    function getKeyPair(pk) {
      var pkBn = (0, number_1.toBN)(pk);
      return exports.ec.keyFromPrivate((0, encode_1.removeHexPrefix)((0, number_1.toHex)(pkBn)), "hex");
    }
    exports.getKeyPair = getKeyPair;
    function getStarkKey(keyPair) {
      keyPair.getPublic(true, "hex");
      return (0, encode_1.addHexPrefix)((0, encode_1.sanitizeBytes)(keyPair.pub.getX().toString(16), 2));
    }
    exports.getStarkKey = getStarkKey;
    function getKeyPairFromPublicKey(publicKey) {
      var publicKeyBn = (0, number_1.toBN)(publicKey);
      return exports.ec.keyFromPublic((0, encode_1.removeHexPrefix)((0, number_1.toHex)(publicKeyBn)), "hex");
    }
    exports.getKeyPairFromPublicKey = getKeyPairFromPublicKey;
    function sign(keyPair, msgHash) {
      var msgHashBN = (0, number_1.toBN)((0, encode_1.addHexPrefix)(msgHash));
      (0, number_1.assertInRange)(msgHashBN, constants_1.ZERO, (0, number_1.toBN)((0, encode_1.addHexPrefix)(constants_1.MAX_ECDSA_VAL)), "msgHash");
      var msgSignature = keyPair.sign(fixMessage(msgHash));
      var r = msgSignature.r, s = msgSignature.s;
      var w = s.invm(exports.ec.n);
      (0, number_1.assertInRange)(r, constants_1.ONE, (0, number_1.toBN)((0, encode_1.addHexPrefix)(constants_1.MAX_ECDSA_VAL)), "r");
      (0, number_1.assertInRange)(s, constants_1.ONE, (0, number_1.toBN)((0, encode_1.addHexPrefix)(constants_1.EC_ORDER)), "s");
      (0, number_1.assertInRange)(w, constants_1.ONE, (0, number_1.toBN)((0, encode_1.addHexPrefix)(constants_1.MAX_ECDSA_VAL)), "w");
      return [r.toString(), s.toString()];
    }
    exports.sign = sign;
    function chunkArray(arr, n) {
      return Array(Math.ceil(arr.length / n)).fill("").map(function(_, i) {
        return arr.slice(i * n, i * n + n);
      });
    }
    function verify(keyPair, msgHash, sig) {
      var keyPairArray = Array.isArray(keyPair) ? keyPair : [keyPair];
      var msgHashBN = (0, number_1.toBN)((0, encode_1.addHexPrefix)(msgHash));
      (0, minimalistic_assert_1.default)(sig.length % 2 === 0, "Signature must be an array of length dividable by 2");
      (0, number_1.assertInRange)(msgHashBN, constants_1.ZERO, (0, number_1.toBN)((0, encode_1.addHexPrefix)(constants_1.MAX_ECDSA_VAL)), "msgHash");
      (0, minimalistic_assert_1.default)(keyPairArray.length === sig.length / 2, "Signature and keyPair length must be equal");
      return chunkArray(sig, 2).every(function(_a, i) {
        var _b;
        var _c = __read(_a, 2), r = _c[0], s = _c[1];
        var rBN = (0, number_1.toBN)(r);
        var sBN = (0, number_1.toBN)(s);
        var w = sBN.invm(exports.ec.n);
        (0, number_1.assertInRange)(rBN, constants_1.ONE, (0, number_1.toBN)((0, encode_1.addHexPrefix)(constants_1.MAX_ECDSA_VAL)), "r");
        (0, number_1.assertInRange)(sBN, constants_1.ONE, (0, number_1.toBN)((0, encode_1.addHexPrefix)(constants_1.EC_ORDER)), "s");
        (0, number_1.assertInRange)(w, constants_1.ONE, (0, number_1.toBN)((0, encode_1.addHexPrefix)(constants_1.MAX_ECDSA_VAL)), "w");
        return (_b = exports.ec.verify(fixMessage(msgHash), { r: rBN, s: sBN }, keyPairArray[i])) !== null && _b !== void 0 ? _b : false;
      });
    }
    exports.verify = verify;
  }
});

// node_modules/starknet/dist/utils/hash.js
var require_hash2 = __commonJS({
  "node_modules/starknet/dist/utils/hash.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.calculateContractAddressFromHash = exports.calculcateTransactionHash = exports.calculateDeployTransactionHash = exports.calculateTransactionHashCommon = exports.computeHashOnElements = exports.pedersen = exports.getSelectorFromName = exports.starknetKeccak = exports.feeTransactionVersion = exports.transactionVersion = void 0;
    var keccak_1 = require_keccak();
    var minimalistic_assert_1 = __importDefault(require_minimalistic_assert());
    var constants_1 = require_constants();
    var ellipticCurve_1 = require_ellipticCurve();
    var encode_1 = require_encode();
    var number_1 = require_number();
    exports.transactionVersion = 0;
    exports.feeTransactionVersion = (0, number_1.toBN)(2).pow((0, number_1.toBN)(128)).add((0, number_1.toBN)(exports.transactionVersion));
    function keccakHex(value) {
      return (0, encode_1.addHexPrefix)((0, encode_1.buf2hex)((0, keccak_1.keccak256)((0, encode_1.utf8ToArray)(value))));
    }
    function starknetKeccak(value) {
      return (0, number_1.toBN)(keccakHex(value)).and(constants_1.MASK_250);
    }
    exports.starknetKeccak = starknetKeccak;
    function getSelectorFromName(funcName) {
      return (0, number_1.toHex)(starknetKeccak(funcName));
    }
    exports.getSelectorFromName = getSelectorFromName;
    var constantPoints = constants_1.CONSTANT_POINTS.map(function(coords) {
      return ellipticCurve_1.ec.curve.point(coords[0], coords[1]);
    });
    function pedersen(input) {
      var point = constantPoints[0];
      for (var i = 0; i < input.length; i += 1) {
        var x = (0, number_1.toBN)(input[i]);
        (0, minimalistic_assert_1.default)(x.gte(constants_1.ZERO) && x.lt((0, number_1.toBN)((0, encode_1.addHexPrefix)(constants_1.FIELD_PRIME))), "Invalid input: ".concat(input[i]));
        for (var j = 0; j < 252; j += 1) {
          var pt = constantPoints[2 + i * 252 + j];
          (0, minimalistic_assert_1.default)(!point.getX().eq(pt.getX()));
          if (x.and(constants_1.ONE).toNumber() !== 0) {
            point = point.add(pt);
          }
          x = x.shrn(1);
        }
      }
      return (0, encode_1.addHexPrefix)(point.getX().toString(16));
    }
    exports.pedersen = pedersen;
    function computeHashOnElements(data) {
      return __spreadArray2(__spreadArray2([], __read(data), false), [data.length], false).reduce(function(x, y) {
        return pedersen([x, y]);
      }, 0).toString();
    }
    exports.computeHashOnElements = computeHashOnElements;
    function calculateTransactionHashCommon(txHashPrefix, version, contractAddress, entryPointSelector, calldata, maxFee, chainId, additionalData) {
      if (additionalData === void 0) {
        additionalData = [];
      }
      var calldataHash = computeHashOnElements(calldata);
      var dataToHash = __spreadArray2([
        txHashPrefix,
        version,
        contractAddress,
        entryPointSelector,
        calldataHash,
        maxFee,
        chainId
      ], __read(additionalData), false);
      return computeHashOnElements(dataToHash);
    }
    exports.calculateTransactionHashCommon = calculateTransactionHashCommon;
    function calculateDeployTransactionHash(contractAddress, constructorCalldata, version, chainId) {
      return calculateTransactionHashCommon(constants_1.TransactionHashPrefix.DEPLOY, version, contractAddress, getSelectorFromName("constructor"), constructorCalldata, constants_1.ZERO, chainId);
    }
    exports.calculateDeployTransactionHash = calculateDeployTransactionHash;
    function calculcateTransactionHash(contractAddress, version, entryPointSelector, calldata, maxFee, chainId) {
      return calculateTransactionHashCommon(constants_1.TransactionHashPrefix.INVOKE, version, contractAddress, entryPointSelector, calldata, maxFee, chainId);
    }
    exports.calculcateTransactionHash = calculcateTransactionHash;
    function calculateContractAddressFromHash(salt, classHash, constructorCalldata, deployerAddress) {
      var constructorCalldataHash = computeHashOnElements(constructorCalldata);
      var CONTRACT_ADDRESS_PREFIX = (0, number_1.toFelt)("0x535441524b4e45545f434f4e54524143545f41444452455353");
      var dataToHash = [
        CONTRACT_ADDRESS_PREFIX,
        deployerAddress,
        salt,
        classHash,
        constructorCalldataHash
      ];
      return computeHashOnElements(dataToHash);
    }
    exports.calculateContractAddressFromHash = calculateContractAddressFromHash;
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports, module) {
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2))
            return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++)
                  ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v)))
                return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0)
                e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0)
                return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            else
              e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++)
            ;
          for (len = str.length; str.charCodeAt(--len) === 48; )
            ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0)
                i += LOG_BASE;
              if (i < len) {
                if (i)
                  x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0")
                ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object")
                  FORMAT = v;
                else
                  throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true)
            return false;
          if (!BigNumber2.DEBUG)
            return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out:
            if ({}.toString.call(c) == "[object Array]") {
              if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                if (c[0] === 0) {
                  if (e === 0 && c.length === 1)
                    return true;
                  break out;
                }
                i = (e + 1) % LOG_BASE;
                if (i < 1)
                  i += LOG_BASE;
                if (String(c[0]).length == i) {
                  for (i = 0; i < c.length; i++) {
                    n = c[i];
                    if (n < 0 || n >= BASE || n !== mathfloor(n))
                      break out;
                  }
                  if (n !== 0)
                    return true;
                }
              }
            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
              return true;
            }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, P.lt);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, P.gt);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null)
              dp = DECIMAL_PLACES;
            else
              intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15)
                  c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--)
              ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
                ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
                ;
              if (i < LOG_BASE)
                e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; )
            sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null)
                    arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop())
              ;
            if (!xc[0])
              return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; )
                ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
                ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry)
              x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1))
              ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++)
              ;
            if (yc[i] > (xc[i] || 0))
              e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0)
                ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2)
                yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base)
                      n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL)
                    prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0])
                qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
                ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          if (!n.c)
            return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++)
                ;
              str = toExponential(str, e);
            } else {
              i -= ne;
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0)
                  for (str += "."; i--; str += "0")
                    ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len)
                    str += ".";
                  for (; i--; str += "0")
                    ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, method) {
          var n, i = 1, m = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            n = new BigNumber2(args[i]);
            if (!n.s) {
              m = n;
              break;
            } else if (method.call(m, n)) {
              m = n;
            }
          }
          return m;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop())
            ;
          for (j = c[0]; j >= 10; j /= 10, i++)
            ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s)
                  return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = n / pows10[d - j - 1] % 10 | 0;
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0))
                      ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++)
                    ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                }
              }
              r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                      ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++)
                      ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE)
                        xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE)
                      break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop())
                ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null)
            return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0)
            x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c))
            return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v])
            for (; v % 10 == 0; v /= 10, n--)
              ;
          if (n < 0)
            n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null)
            m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s)
              return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp)
              x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1)
              k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg)
              n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c)
                break;
              if (k) {
                if (y.c.length > k)
                  y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0)
                  break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k)
                x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp)
            return y;
          if (nIsNeg)
            y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0))
              ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0)
            for (; b--; xc[i++] = 0)
              ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b)
                ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye)
            ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1)
            y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0))
            ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0])
              return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0))
              ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c))
            return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--)
              ;
            for (v = c[0]; v >= 10; v /= 10, n++)
              ;
          }
          if (sd && x.e + 1 > n)
            n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0)
              n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3)
              s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e)
                  --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1)
                intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0)
                intPart += groupSeparator + intDigits.slice(i);
              if (isNeg)
                intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc)
            return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1)
              break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null)
            intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0)
                str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0])
              str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null)
          BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s)
            ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; )
          ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j)
          return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b)
          return a ? b ? 0 : -j : i;
        if (i != j)
          return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc)
          return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b)
          return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++)
          if (xc[i] != yc[i])
            return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z)
            ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z)
              ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports);
  }
});

// node_modules/json-bigint/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/json-bigint/lib/stringify.js"(exports, module) {
    var BigNumber = require_bignumber();
    var JSON2 = module.exports;
    (function() {
      "use strict";
      function f(n) {
        return n < 10 ? "0" + n : n;
      }
      var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function(a) {
          var c = meta[a];
          return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
      }
      function str(key, holder) {
        var i, k, v, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber || BigNumber.isBigNumber(value));
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            if (isBigNumber) {
              return value;
            } else {
              return quote(value);
            }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
          case "bigint":
            return String(value);
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length = value.length;
              for (i = 0; i < length; i += 1) {
                partial[i] = str(i, value) || "null";
              }
              v = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v;
            }
            if (rep && typeof rep === "object") {
              length = rep.length;
              for (i = 0; i < length; i += 1) {
                if (typeof rep[i] === "string") {
                  k = rep[i];
                  v = str(k, value);
                  if (v) {
                    partial.push(quote(k) + (gap ? ": " : ":") + v);
                  }
                }
              }
            } else {
              Object.keys(value).forEach(function(k2) {
                var v2 = str(k2, value);
                if (v2) {
                  partial.push(quote(k2) + (gap ? ": " : ":") + v2);
                }
              });
            }
            v = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v;
        }
      }
      if (typeof JSON2.stringify !== "function") {
        JSON2.stringify = function(value, replacer, space) {
          var i;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i = 0; i < space; i += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
    })();
  }
});

// node_modules/json-bigint/lib/parse.js
var require_parse = __commonJS({
  "node_modules/json-bigint/lib/parse.js"(exports, module) {
    var BigNumber = null;
    var suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
    var suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
    var json_parse = function(options) {
      "use strict";
      var _options = {
        strict: false,
        storeAsString: false,
        alwaysParseAsBig: false,
        useNativeBigInt: false,
        protoAction: "error",
        constructorAction: "error"
      };
      if (options !== void 0 && options !== null) {
        if (options.strict === true) {
          _options.strict = true;
        }
        if (options.storeAsString === true) {
          _options.storeAsString = true;
        }
        _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
        _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
        if (typeof options.constructorAction !== "undefined") {
          if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
            _options.constructorAction = options.constructorAction;
          } else {
            throw new Error(
              `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
            );
          }
        }
        if (typeof options.protoAction !== "undefined") {
          if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
            _options.protoAction = options.protoAction;
          } else {
            throw new Error(
              `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
            );
          }
        }
      }
      var at, ch, escapee = {
        '"': '"',
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
      }, text, error = function(m) {
        throw {
          name: "SyntaxError",
          message: m,
          at,
          text
        };
      }, next = function(c) {
        if (c && c !== ch) {
          error("Expected '" + c + "' instead of '" + ch + "'");
        }
        ch = text.charAt(at);
        at += 1;
        return ch;
      }, number = function() {
        var number2, string2 = "";
        if (ch === "-") {
          string2 = "-";
          next("-");
        }
        while (ch >= "0" && ch <= "9") {
          string2 += ch;
          next();
        }
        if (ch === ".") {
          string2 += ".";
          while (next() && ch >= "0" && ch <= "9") {
            string2 += ch;
          }
        }
        if (ch === "e" || ch === "E") {
          string2 += ch;
          next();
          if (ch === "-" || ch === "+") {
            string2 += ch;
            next();
          }
          while (ch >= "0" && ch <= "9") {
            string2 += ch;
            next();
          }
        }
        number2 = +string2;
        if (!isFinite(number2)) {
          error("Bad number");
        } else {
          if (BigNumber == null)
            BigNumber = require_bignumber();
          if (string2.length > 15)
            return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber(string2);
          else
            return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
        }
      }, string = function() {
        var hex, i, string2 = "", uffff;
        if (ch === '"') {
          var startAt = at;
          while (next()) {
            if (ch === '"') {
              if (at - 1 > startAt)
                string2 += text.substring(startAt, at - 1);
              next();
              return string2;
            }
            if (ch === "\\") {
              if (at - 1 > startAt)
                string2 += text.substring(startAt, at - 1);
              next();
              if (ch === "u") {
                uffff = 0;
                for (i = 0; i < 4; i += 1) {
                  hex = parseInt(next(), 16);
                  if (!isFinite(hex)) {
                    break;
                  }
                  uffff = uffff * 16 + hex;
                }
                string2 += String.fromCharCode(uffff);
              } else if (typeof escapee[ch] === "string") {
                string2 += escapee[ch];
              } else {
                break;
              }
              startAt = at;
            }
          }
        }
        error("Bad string");
      }, white = function() {
        while (ch && ch <= " ") {
          next();
        }
      }, word = function() {
        switch (ch) {
          case "t":
            next("t");
            next("r");
            next("u");
            next("e");
            return true;
          case "f":
            next("f");
            next("a");
            next("l");
            next("s");
            next("e");
            return false;
          case "n":
            next("n");
            next("u");
            next("l");
            next("l");
            return null;
        }
        error("Unexpected '" + ch + "'");
      }, value, array = function() {
        var array2 = [];
        if (ch === "[") {
          next("[");
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          while (ch) {
            array2.push(value());
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            next(",");
            white();
          }
        }
        error("Bad array");
      }, object = function() {
        var key, object2 = /* @__PURE__ */ Object.create(null);
        if (ch === "{") {
          next("{");
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          while (ch) {
            key = string();
            white();
            next(":");
            if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
              error('Duplicate key "' + key + '"');
            }
            if (suspectProtoRx.test(key) === true) {
              if (_options.protoAction === "error") {
                error("Object contains forbidden prototype property");
              } else if (_options.protoAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else if (suspectConstructorRx.test(key) === true) {
              if (_options.constructorAction === "error") {
                error("Object contains forbidden constructor property");
              } else if (_options.constructorAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else {
              object2[key] = value();
            }
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            next(",");
            white();
          }
        }
        error("Bad object");
      };
      value = function() {
        white();
        switch (ch) {
          case "{":
            return object();
          case "[":
            return array();
          case '"':
            return string();
          case "-":
            return number();
          default:
            return ch >= "0" && ch <= "9" ? number() : word();
        }
      };
      return function(source, reviver) {
        var result;
        text = source + "";
        at = 0;
        ch = " ";
        result = value();
        white();
        if (ch) {
          error("Syntax error");
        }
        return typeof reviver === "function" ? function walk(holder, key) {
          var k, v, value2 = holder[key];
          if (value2 && typeof value2 === "object") {
            Object.keys(value2).forEach(function(k2) {
              v = walk(value2, k2);
              if (v !== void 0) {
                value2[k2] = v;
              } else {
                delete value2[k2];
              }
            });
          }
          return reviver.call(holder, key, value2);
        }({ "": result }, "") : result;
      };
    };
    module.exports = json_parse;
  }
});

// node_modules/json-bigint/index.js
var require_json_bigint = __commonJS({
  "node_modules/json-bigint/index.js"(exports, module) {
    var json_stringify = require_stringify().stringify;
    var json_parse = require_parse();
    module.exports = function(options) {
      return {
        parse: json_parse(options),
        stringify: json_stringify
      };
    };
    module.exports.parse = json_parse();
    module.exports.stringify = json_stringify;
  }
});

// node_modules/starknet/dist/utils/json.js
var require_json = __commonJS({
  "node_modules/starknet/dist/utils/json.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var _a;
    var _b;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringifyAlwaysAsBig = exports.parseAlwaysAsBig = exports.stringify = exports.parse = void 0;
    var json_bigint_1 = __importDefault(require_json_bigint());
    var json = function(alwaysParseAsBig) {
      return (0, json_bigint_1.default)({
        alwaysParseAsBig,
        useNativeBigInt: true,
        protoAction: "preserve",
        constructorAction: "preserve"
      });
    };
    exports.parse = (_a = json(false), _a.parse), exports.stringify = _a.stringify;
    exports.parseAlwaysAsBig = (_b = json(true), _b.parse), exports.stringifyAlwaysAsBig = _b.stringify;
    exports.default = { parse: exports.parse, stringify: exports.stringify };
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports, module) {
    "use strict";
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);
    var extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);
    var extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);
    var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    var d_code = (dist) => {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    };
    var put_short = (s, w) => {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    };
    var send_bits = (s, value, length) => {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    };
    var send_code = (s, c, tree) => {
      send_bits(s, tree[c * 2], tree[c * 2 + 1]);
    };
    var bi_reverse = (code, len) => {
      let res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    };
    var bi_flush = (s) => {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    };
    var gen_bitlen = (s, desc) => {
      const tree = desc.dyn_tree;
      const max_code = desc.max_code;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const extra = desc.stat_desc.extra_bits;
      const base = desc.stat_desc.extra_base;
      const max_length = desc.stat_desc.max_length;
      let h;
      let n, m;
      let bits;
      let xbits;
      let f;
      let overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    };
    var gen_codes = (tree, max_code, bl_count) => {
      const next_code = new Array(MAX_BITS + 1);
      let code = 0;
      let bits;
      let n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        code = code + bl_count[bits - 1] << 1;
        next_code[bits] = code;
      }
      for (n = 0; n <= max_code; n++) {
        let len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    };
    var tr_static_init = () => {
      let n;
      let bits;
      let length;
      let code;
      let dist;
      const bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    };
    var init_block = (s) => {
      let n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.sym_next = s.matches = 0;
    };
    var bi_windup = (s) => {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    };
    var smaller = (tree, n, m, depth) => {
      const _n2 = n * 2;
      const _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    };
    var pqdownheap = (s, tree, k) => {
      const v = s.heap[k];
      let j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    };
    var compress_block = (s, ltree, dtree) => {
      let dist;
      let lc;
      let sx = 0;
      let code;
      let extra;
      if (s.sym_next !== 0) {
        do {
          dist = s.pending_buf[s.sym_buf + sx++] & 255;
          dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
          lc = s.pending_buf[s.sym_buf + sx++];
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (sx < s.sym_next);
      }
      send_code(s, END_BLOCK, ltree);
    };
    var build_tree = (s, desc) => {
      const tree = desc.dyn_tree;
      const stree = desc.stat_desc.static_tree;
      const has_stree = desc.stat_desc.has_stree;
      const elems = desc.stat_desc.elems;
      let n, m;
      let max_code = -1;
      let node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[1];
        s.heap[1] = s.heap[s.heap_len--];
        pqdownheap(s, tree, 1);
        m = s.heap[1];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[1] = node++;
        pqdownheap(s, tree, 1);
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[1];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    };
    var scan_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var send_tree = (s, tree, max_code) => {
      let n;
      let prevlen = -1;
      let curlen;
      let nextlen = tree[0 * 2 + 1];
      let count = 0;
      let max_count = 7;
      let min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    };
    var build_bl_tree = (s) => {
      let max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    };
    var send_all_trees = (s, lcodes, dcodes, blcodes) => {
      let rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    };
    var detect_data_type = (s) => {
      let block_mask = 4093624447;
      let n;
      for (n = 0; n <= 31; n++, block_mask >>>= 1) {
        if (block_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    };
    var static_init_done = false;
    var _tr_init = (s) => {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    };
    var _tr_stored_block = (s, buf, stored_len, last) => {
      send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
      bi_windup(s);
      put_short(s, stored_len);
      put_short(s, ~stored_len);
      if (stored_len) {
        s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
      }
      s.pending += stored_len;
    };
    var _tr_align = (s) => {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    };
    var _tr_flush_block = (s, buf, stored_len, last) => {
      let opt_lenb, static_lenb;
      let max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last) {
        bi_windup(s);
      }
    };
    var _tr_tally = (s, dist, lc) => {
      s.pending_buf[s.sym_buf + s.sym_next++] = dist;
      s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
      s.pending_buf[s.sym_buf + s.sym_next++] = lc;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.sym_next === s.sym_end;
    };
    module.exports._tr_init = _tr_init;
    module.exports._tr_stored_block = _tr_stored_block;
    module.exports._tr_flush_block = _tr_flush_block;
    module.exports._tr_tally = _tr_tally;
    module.exports._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports, module) {
    "use strict";
    var adler32 = (adler, buf, len, pos) => {
      let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    };
    module.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports, module) {
    "use strict";
    var makeTable = () => {
      let c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    };
    var crcTable = new Uint32Array(makeTable());
    var crc32 = (crc, buf, len, pos) => {
      const t = crcTable;
      const end = pos + len;
      crc ^= -1;
      for (let i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    };
    module.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports, module) {
    "use strict";
    module.exports = {
      2: "need dictionary",
      1: "stream end",
      0: "",
      "-1": "file error",
      "-2": "stream error",
      "-3": "data error",
      "-4": "insufficient memory",
      "-5": "buffer error",
      "-6": "incompatible version"
    };
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants2 = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports, module) {
    "use strict";
    module.exports = {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_MEM_ERROR: -4,
      Z_BUF_ERROR: -5,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      Z_BINARY: 0,
      Z_TEXT: 1,
      Z_UNKNOWN: 2,
      Z_DEFLATED: 8
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports, module) {
    "use strict";
    var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var {
      Z_NO_FLUSH,
      Z_PARTIAL_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_BLOCK,
      Z_OK,
      Z_STREAM_END,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_BUF_ERROR,
      Z_DEFAULT_COMPRESSION,
      Z_FILTERED,
      Z_HUFFMAN_ONLY,
      Z_RLE,
      Z_FIXED,
      Z_DEFAULT_STRATEGY,
      Z_UNKNOWN,
      Z_DEFLATED
    } = require_constants2();
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var GZIP_STATE = 57;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    var err = (strm, errorCode) => {
      strm.msg = msg[errorCode];
      return errorCode;
    };
    var rank = (f) => {
      return f * 2 - (f > 4 ? 9 : 0);
    };
    var zero = (buf) => {
      let len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    };
    var slide_hash = (s) => {
      let n, m;
      let p;
      let wsize = s.w_size;
      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = m >= wsize ? m - wsize : 0;
      } while (--n);
      n = wsize;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = m >= wsize ? m - wsize : 0;
      } while (--n);
    };
    var HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;
    var HASH = HASH_ZLIB;
    var flush_pending = (strm) => {
      const s = strm.state;
      let len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    };
    var flush_block_only = (s, last) => {
      _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    };
    var put_byte = (s, b) => {
      s.pending_buf[s.pending++] = b;
    };
    var putShortMSB = (s, b) => {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    };
    var read_buf = (strm, buf, start, size) => {
      let len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    };
    var longest_match = (s, cur_match) => {
      let chain_length = s.max_chain_length;
      let scan = s.strstart;
      let match;
      let len;
      let best_len = s.prev_length;
      let nice_match = s.nice_match;
      const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      const _win = s.window;
      const wmask = s.w_mask;
      const prev = s.prev;
      const strend = s.strstart + MAX_MATCH;
      let scan_end1 = _win[scan + best_len - 1];
      let scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    };
    var fill_window = (s) => {
      const _w_size = s.w_size;
      let n, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          if (s.insert > s.strstart) {
            s.insert = s.strstart;
          }
          slide_hash(s);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
          while (s.insert) {
            s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    };
    var deflate_stored = (s, flush) => {
      let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
      let len, left, have, last = 0;
      let used = s.strm.avail_in;
      do {
        len = 65535;
        have = s.bi_valid + 42 >> 3;
        if (s.strm.avail_out < have) {
          break;
        }
        have = s.strm.avail_out - have;
        left = s.strstart - s.block_start;
        if (len > left + s.strm.avail_in) {
          len = left + s.strm.avail_in;
        }
        if (len > have) {
          len = have;
        }
        if (len < min_block && (len === 0 && flush !== Z_FINISH || flush === Z_NO_FLUSH || len !== left + s.strm.avail_in)) {
          break;
        }
        last = flush === Z_FINISH && len === left + s.strm.avail_in ? 1 : 0;
        _tr_stored_block(s, 0, 0, last);
        s.pending_buf[s.pending - 4] = len;
        s.pending_buf[s.pending - 3] = len >> 8;
        s.pending_buf[s.pending - 2] = ~len;
        s.pending_buf[s.pending - 1] = ~len >> 8;
        flush_pending(s.strm);
        if (left) {
          if (left > len) {
            left = len;
          }
          s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
          s.strm.next_out += left;
          s.strm.avail_out -= left;
          s.strm.total_out += left;
          s.block_start += left;
          len -= left;
        }
        if (len) {
          read_buf(s.strm, s.strm.output, s.strm.next_out, len);
          s.strm.next_out += len;
          s.strm.avail_out -= len;
          s.strm.total_out += len;
        }
      } while (last === 0);
      used -= s.strm.avail_in;
      if (used) {
        if (used >= s.w_size) {
          s.matches = 2;
          s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
          s.strstart = s.w_size;
          s.insert = s.strstart;
        } else {
          if (s.window_size - s.strstart <= used) {
            s.strstart -= s.w_size;
            s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
            if (s.matches < 2) {
              s.matches++;
            }
            if (s.insert > s.strstart) {
              s.insert = s.strstart;
            }
          }
          s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
          s.strstart += used;
          s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
        }
        s.block_start = s.strstart;
      }
      if (s.high_water < s.strstart) {
        s.high_water = s.strstart;
      }
      if (last) {
        return BS_FINISH_DONE;
      }
      if (flush !== Z_NO_FLUSH && flush !== Z_FINISH && s.strm.avail_in === 0 && s.strstart === s.block_start) {
        return BS_BLOCK_DONE;
      }
      have = s.window_size - s.strstart;
      if (s.strm.avail_in > have && s.block_start >= s.w_size) {
        s.block_start -= s.w_size;
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        have += s.w_size;
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      if (have > s.strm.avail_in) {
        have = s.strm.avail_in;
      }
      if (have) {
        read_buf(s.strm, s.window, s.strstart, have);
        s.strstart += have;
        s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
      }
      if (s.high_water < s.strstart) {
        s.high_water = s.strstart;
      }
      have = s.bi_valid + 42 >> 3;
      have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
      min_block = have > s.w_size ? s.w_size : have;
      left = s.strstart - s.block_start;
      if (left >= min_block || (left || flush === Z_FINISH) && flush !== Z_NO_FLUSH && s.strm.avail_in === 0 && left <= have) {
        len = left > have ? have : left;
        last = flush === Z_FINISH && s.strm.avail_in === 0 && len === left ? 1 : 0;
        _tr_stored_block(s, s.block_start, len, last);
        s.block_start += len;
        flush_pending(s.strm);
      }
      return last ? BS_FINISH_STARTED : BS_NEED_MORE;
    };
    var deflate_fast = (s, flush) => {
      let hash_head;
      let bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
          }
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_slow = (s, flush) => {
      let hash_head;
      let bflush;
      let max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_rle = (s, flush) => {
      let bflush;
      let prev;
      let scan, strend;
      const _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = _tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    var deflate_huff = (s, flush) => {
      let bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = _tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.sym_next) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    };
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table = [
      new Config(0, 0, 0, 0, deflate_stored),
      new Config(4, 4, 8, 4, deflate_fast),
      new Config(4, 5, 16, 8, deflate_fast),
      new Config(4, 6, 32, 32, deflate_fast),
      new Config(4, 4, 16, 16, deflate_slow),
      new Config(8, 16, 32, 32, deflate_slow),
      new Config(8, 16, 128, 128, deflate_slow),
      new Config(8, 32, 128, 256, deflate_slow),
      new Config(32, 128, 258, 1024, deflate_slow),
      new Config(32, 258, 258, 4096, deflate_slow)
    ];
    var lm_init = (s) => {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    };
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
      this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
      this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new Uint16Array(MAX_BITS + 1);
      this.heap = new Uint16Array(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new Uint16Array(2 * L_CODES + 1);
      zero(this.depth);
      this.sym_buf = 0;
      this.lit_bufsize = 0;
      this.sym_next = 0;
      this.sym_end = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    var deflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const s = strm.state;
      if (!s || s.strm !== strm || s.status !== INIT_STATE && s.status !== GZIP_STATE && s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
        return 1;
      }
      return 0;
    };
    var deflateResetKeep = (strm) => {
      if (deflateStateCheck(strm)) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      const s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap === 2 ? GZIP_STATE : s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = -2;
      _tr_init(s);
      return Z_OK;
    };
    var deflateReset = (strm) => {
      const ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    };
    var deflateSetHeader = (strm, head) => {
      if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    };
    var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      let wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      const s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.status = INIT_STATE;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new Uint8Array(s.w_size * 2);
      s.head = new Uint16Array(s.hash_size);
      s.prev = new Uint16Array(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new Uint8Array(s.pending_buf_size);
      s.sym_buf = s.lit_bufsize;
      s.sym_end = (s.lit_bufsize - 1) * 3;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    };
    var deflateInit = (strm, level) => {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    };
    var deflate = (strm, flush) => {
      if (deflateStateCheck(strm) || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      const s = strm.state;
      if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      const old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === INIT_STATE && s.wrap === 0) {
        s.status = BUSY_STATE;
      }
      if (s.status === INIT_STATE) {
        let header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        let level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
      if (s.status === GZIP_STATE) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        } else {
          put_byte(
            s,
            (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
          );
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          let beg = s.pending;
          let left = (s.gzhead.extra.length & 65535) - s.gzindex;
          while (s.pending + left > s.pending_buf_size) {
            let copy = s.pending_buf_size - s.pending;
            s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy), s.pending);
            s.pending = s.pending_buf_size;
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            s.gzindex += copy;
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK;
            }
            beg = 0;
            left -= copy;
          }
          let gzhead_extra = new Uint8Array(s.gzhead.extra);
          s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
          s.pending += left;
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          s.gzindex = 0;
        }
        s.status = NAME_STATE;
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          let beg = s.pending;
          let val;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK;
              }
              beg = 0;
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          s.gzindex = 0;
        }
        s.status = COMMENT_STATE;
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          let beg = s.pending;
          let val;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              if (s.pending !== 0) {
                s.last_flush = -1;
                return Z_OK;
              }
              beg = 0;
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
        }
        s.status = HCRC_STATE;
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
            if (s.pending !== 0) {
              s.last_flush = -1;
              return Z_OK;
            }
          }
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
        }
        s.status = BUSY_STATE;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            _tr_align(s);
          } else if (flush !== Z_BLOCK) {
            _tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    };
    var deflateEnd = (strm) => {
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const status = strm.state.status;
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    };
    var deflateSetDictionary = (strm, dictionary) => {
      let dictLength = dictionary.length;
      if (deflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const s = strm.state;
      const wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        let tmpDict = new Uint8Array(s.w_size);
        tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      const avail = strm.avail_in;
      const next = strm.next_in;
      const input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        let str = s.strstart;
        let n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    };
    module.exports.deflateInit = deflateInit;
    module.exports.deflateInit2 = deflateInit2;
    module.exports.deflateReset = deflateReset;
    module.exports.deflateResetKeep = deflateResetKeep;
    module.exports.deflateSetHeader = deflateSetHeader;
    module.exports.deflate = deflate;
    module.exports.deflateEnd = deflateEnd;
    module.exports.deflateSetDictionary = deflateSetDictionary;
    module.exports.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports, module) {
    "use strict";
    var _has = (obj, key) => {
      return Object.prototype.hasOwnProperty.call(obj, key);
    };
    module.exports.assign = function(obj) {
      const sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        const source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (const p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    module.exports.flattenChunks = (chunks) => {
      let len = 0;
      for (let i = 0, l = chunks.length; i < l; i++) {
        len += chunks[i].length;
      }
      const result = new Uint8Array(len);
      for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
        let chunk = chunks[i];
        result.set(chunk, pos);
        pos += chunk.length;
      }
      return result;
    };
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports, module) {
    "use strict";
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new Uint8Array(256);
    for (let q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    module.exports.string2buf = (str) => {
      if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
        return new TextEncoder().encode(str);
      }
      let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new Uint8Array(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    var buf2binstring = (buf, len) => {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK) {
          return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
        }
      }
      let result = "";
      for (let i = 0; i < len; i++) {
        result += String.fromCharCode(buf[i]);
      }
      return result;
    };
    module.exports.buf2string = (buf, max) => {
      const len = max || buf.length;
      if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
        return new TextDecoder().decode(buf.subarray(0, max));
      }
      let i, out;
      const utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        let c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        let c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    module.exports.utf8border = (buf, max) => {
      max = max || buf.length;
      if (max > buf.length) {
        max = buf.length;
      }
      let pos = max - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf[pos]] > max ? pos : max;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports, module) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports, module) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_SYNC_FLUSH,
      Z_FULL_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_DEFAULT_COMPRESSION,
      Z_DEFAULT_STRATEGY,
      Z_DEFLATED
    } = require_constants2();
    function Deflate(options) {
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY
      }, options || {});
      let opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        let dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      let status, _flush_mode;
      if (this.ended) {
        return false;
      }
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        status = zlib_deflate.deflate(strm, _flush_mode);
        if (status === Z_STREAM_END) {
          if (strm.next_out > 0) {
            this.onData(strm.output.subarray(0, strm.next_out));
          }
          status = zlib_deflate.deflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return status === Z_OK;
        }
        if (strm.avail_out === 0) {
          this.onData(strm.output);
          continue;
        }
        if (_flush_mode > 0 && strm.next_out > 0) {
          this.onData(strm.output.subarray(0, strm.next_out));
          strm.avail_out = 0;
          continue;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        this.result = utils.flattenChunks(this.chunks);
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      const deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    module.exports.Deflate = Deflate;
    module.exports.deflate = deflate;
    module.exports.deflateRaw = deflateRaw;
    module.exports.gzip = gzip;
    module.exports.constants = require_constants2();
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports, module) {
    "use strict";
    var BAD = 16209;
    var TYPE = 16191;
    module.exports = function inflate_fast(strm, start) {
      let _in;
      let last;
      let _out;
      let beg;
      let end;
      let dmax;
      let wsize;
      let whave;
      let wnext;
      let s_window;
      let hold;
      let bits;
      let lcode;
      let dcode;
      let lmask;
      let dmask;
      let here;
      let op;
      let len;
      let dist;
      let from;
      let from_source;
      let input, output;
      const state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports, module) {
    "use strict";
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = new Uint16Array([
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ]);
    var lext = new Uint8Array([
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ]);
    var dbase = new Uint16Array([
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ]);
    var dext = new Uint8Array([
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ]);
    var inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
      const bits = opts.bits;
      let len = 0;
      let sym = 0;
      let min = 0, max = 0;
      let root = 0;
      let curr = 0;
      let drop = 0;
      let left = 0;
      let used = 0;
      let huff = 0;
      let incr;
      let fill;
      let low;
      let mask;
      let next;
      let base = null;
      let match;
      const count = new Uint16Array(MAXBITS + 1);
      const offs = new Uint16Array(MAXBITS + 1);
      let extra = null;
      let here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        match = 20;
      } else if (type === LENS) {
        base = lbase;
        extra = lext;
        match = 257;
      } else {
        base = dbase;
        extra = dext;
        match = 0;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] + 1 < match) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] >= match) {
          here_op = extra[work[sym] - match];
          here_val = base[work[sym] - match];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
    module.exports = inflate_table;
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports, module) {
    "use strict";
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var {
      Z_FINISH,
      Z_BLOCK,
      Z_TREES,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR,
      Z_BUF_ERROR,
      Z_DEFLATED
    } = require_constants2();
    var HEAD = 16180;
    var FLAGS = 16181;
    var TIME = 16182;
    var OS = 16183;
    var EXLEN = 16184;
    var EXTRA = 16185;
    var NAME = 16186;
    var COMMENT = 16187;
    var HCRC = 16188;
    var DICTID = 16189;
    var DICT = 16190;
    var TYPE = 16191;
    var TYPEDO = 16192;
    var STORED = 16193;
    var COPY_ = 16194;
    var COPY = 16195;
    var TABLE = 16196;
    var LENLENS = 16197;
    var CODELENS = 16198;
    var LEN_ = 16199;
    var LEN = 16200;
    var LENEXT = 16201;
    var DIST = 16202;
    var DISTEXT = 16203;
    var MATCH = 16204;
    var LIT = 16205;
    var CHECK = 16206;
    var LENGTH = 16207;
    var DONE = 16208;
    var BAD = 16209;
    var MEM = 16210;
    var SYNC = 16211;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    var zswap32 = (q) => {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    };
    function InflateState() {
      this.strm = null;
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new Uint16Array(320);
      this.work = new Uint16Array(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    var inflateStateCheck = (strm) => {
      if (!strm) {
        return 1;
      }
      const state = strm.state;
      if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
        return 1;
      }
      return 0;
    };
    var inflateResetKeep = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.flags = -1;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
      state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    };
    var inflateReset = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    };
    var inflateReset2 = (strm, windowBits) => {
      let wrap;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 5;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    };
    var inflateInit2 = (strm, windowBits) => {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      const state = new InflateState();
      strm.state = state;
      state.strm = strm;
      state.window = null;
      state.mode = HEAD;
      const ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    };
    var inflateInit = (strm) => {
      return inflateInit2(strm, DEF_WBITS);
    };
    var virgin = true;
    var lenfix;
    var distfix;
    var fixedtables = (state) => {
      if (virgin) {
        lenfix = new Int32Array(512);
        distfix = new Int32Array(32);
        let sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    };
    var updatewindow = (strm, src, end, copy) => {
      let dist;
      const state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new Uint8Array(state.wsize);
      }
      if (copy >= state.wsize) {
        state.window.set(src.subarray(end - state.wsize, end), 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);
        copy -= dist;
        if (copy) {
          state.window.set(src.subarray(end - copy, end), 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    };
    var inflate = (strm, flush) => {
      let state;
      let input, output;
      let next;
      let put;
      let have, left;
      let hold;
      let bits;
      let _in, _out;
      let copy;
      let from;
      let from_source;
      let here = 0;
      let here_bits, here_op, here_val;
      let last_bits, last_op, last_val;
      let len;
      let ret;
      const hbuf = new Uint8Array(4);
      let opts;
      let n;
      const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
      if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                if (state.wbits === 0) {
                  state.wbits = 15;
                }
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              }
              if (len > 15 || len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << state.wbits;
              state.flags = 0;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512 && state.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512 && state.wrap & 4) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Uint8Array(state.head.extra_len);
                    }
                    state.head.extra.set(
                      input.subarray(
                        next,
                        next + copy
                      ),
                      len
                    );
                  }
                  if (state.flags & 512 && state.wrap & 4) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512 && state.wrap & 4) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 4 && hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                output.set(input.subarray(next, next + copy), put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (state.wrap & 4 && _out) {
                  strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap & 4 && _out) {
        strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    };
    var inflateEnd = (strm) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      let state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    };
    var inflateGetHeader = (strm, head) => {
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      const state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    };
    var inflateSetDictionary = (strm, dictionary) => {
      const dictLength = dictionary.length;
      let state;
      let dictid;
      let ret;
      if (inflateStateCheck(strm)) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    };
    module.exports.inflateReset = inflateReset;
    module.exports.inflateReset2 = inflateReset2;
    module.exports.inflateResetKeep = inflateResetKeep;
    module.exports.inflateInit = inflateInit;
    module.exports.inflateInit2 = inflateInit2;
    module.exports.inflate = inflate;
    module.exports.inflateEnd = inflateEnd;
    module.exports.inflateGetHeader = inflateGetHeader;
    module.exports.inflateSetDictionary = inflateSetDictionary;
    module.exports.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports, module) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports, module) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString = Object.prototype.toString;
    var {
      Z_NO_FLUSH,
      Z_FINISH,
      Z_OK,
      Z_STREAM_END,
      Z_NEED_DICT,
      Z_STREAM_ERROR,
      Z_DATA_ERROR,
      Z_MEM_ERROR
    } = require_constants2();
    function Inflate(options) {
      this.options = utils.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ""
      }, options || {});
      const opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      let status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, flush_mode) {
      const strm = this.strm;
      const chunkSize = this.options.chunkSize;
      const dictionary = this.options.dictionary;
      let status, _flush_mode, last_avail_out;
      if (this.ended)
        return false;
      if (flush_mode === ~~flush_mode)
        _flush_mode = flush_mode;
      else
        _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (toString.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      for (; ; ) {
        if (strm.avail_out === 0) {
          strm.output = new Uint8Array(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, _flush_mode);
        if (status === Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(strm, dictionary);
          if (status === Z_OK) {
            status = zlib_inflate.inflate(strm, _flush_mode);
          } else if (status === Z_DATA_ERROR) {
            status = Z_NEED_DICT;
          }
        }
        while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
          zlib_inflate.inflateReset(strm);
          status = zlib_inflate.inflate(strm, _flush_mode);
        }
        switch (status) {
          case Z_STREAM_ERROR:
          case Z_DATA_ERROR:
          case Z_NEED_DICT:
          case Z_MEM_ERROR:
            this.onEnd(status);
            this.ended = true;
            return false;
        }
        last_avail_out = strm.avail_out;
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === Z_STREAM_END) {
            if (this.options.to === "string") {
              let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              let tail = strm.next_out - next_out_utf8;
              let utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail)
                strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
              this.onData(utf8str);
            } else {
              this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
            }
          }
        }
        if (status === Z_OK && last_avail_out === 0)
          continue;
        if (status === Z_STREAM_END) {
          status = zlib_inflate.inflateEnd(this.strm);
          this.onEnd(status);
          this.ended = true;
          return true;
        }
        if (strm.avail_in === 0)
          break;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      const inflator = new Inflate(options);
      inflator.push(input);
      if (inflator.err)
        throw inflator.msg || msg[inflator.err];
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    module.exports.Inflate = Inflate;
    module.exports.inflate = inflate;
    module.exports.inflateRaw = inflateRaw;
    module.exports.ungzip = inflate;
    module.exports.constants = require_constants2();
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports, module) {
    "use strict";
    var { Deflate, deflate, deflateRaw, gzip } = require_deflate2();
    var { Inflate, inflate, inflateRaw, ungzip } = require_inflate2();
    var constants = require_constants2();
    module.exports.Deflate = Deflate;
    module.exports.deflate = deflate;
    module.exports.deflateRaw = deflateRaw;
    module.exports.gzip = gzip;
    module.exports.Inflate = Inflate;
    module.exports.inflate = inflate;
    module.exports.inflateRaw = inflateRaw;
    module.exports.ungzip = ungzip;
    module.exports.constants = constants;
  }
});

// node_modules/starknet/dist/utils/stark.js
var require_stark = __commonJS({
  "node_modules/starknet/dist/utils/stark.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.estimatedFeeToMaxFee = exports.compileCalldata = exports.formatSignature = exports.makeAddress = exports.randomAddress = exports.compressProgram = void 0;
    var pako_1 = require_pako();
    var ellipticCurve_1 = require_ellipticCurve();
    var encode_1 = require_encode();
    var json_1 = require_json();
    var number_1 = require_number();
    function compressProgram(jsonProgram) {
      var stringified = typeof jsonProgram === "string" ? jsonProgram : (0, json_1.stringify)(jsonProgram);
      var compressedProgram = (0, pako_1.gzip)(stringified);
      return (0, encode_1.btoaUniversal)(compressedProgram);
    }
    exports.compressProgram = compressProgram;
    function randomAddress() {
      var randomKeyPair = (0, ellipticCurve_1.genKeyPair)();
      return (0, ellipticCurve_1.getStarkKey)(randomKeyPair);
    }
    exports.randomAddress = randomAddress;
    function makeAddress(input) {
      return (0, encode_1.addHexPrefix)(input).toLowerCase();
    }
    exports.makeAddress = makeAddress;
    function formatSignature(sig) {
      if (!sig)
        return [];
      try {
        return sig.map(function(x) {
          return (0, number_1.toBN)(x);
        }).map(function(x) {
          return x.toString();
        });
      } catch (e) {
        return [];
      }
    }
    exports.formatSignature = formatSignature;
    function compileCalldata(args) {
      return Object.values(args).flatMap(function(value) {
        if (Array.isArray(value))
          return __spreadArray2([(0, number_1.toBN)(value.length).toString()], __read(value.map(function(x) {
            return (0, number_1.toBN)(x).toString();
          })), false);
        if (typeof value === "object" && "type" in value)
          return Object.entries(value).filter(function(_a) {
            var _b = __read(_a, 1), k = _b[0];
            return k !== "type";
          }).map(function(_a) {
            var _b = __read(_a, 2), v = _b[1];
            return (0, number_1.toBN)(v).toString();
          });
        return (0, number_1.toBN)(value).toString();
      });
    }
    exports.compileCalldata = compileCalldata;
    function estimatedFeeToMaxFee(estimatedFee, overhead) {
      if (overhead === void 0) {
        overhead = 0.5;
      }
      var overHeadPercent = Math.round((1 + overhead) * 100);
      return (0, number_1.toBN)(estimatedFee).mul((0, number_1.toBN)(overHeadPercent)).div((0, number_1.toBN)(100));
    }
    exports.estimatedFeeToMaxFee = estimatedFeeToMaxFee;
  }
});

// node_modules/ts-custom-error/dist/custom-error.mjs
var custom_error_exports = {};
__export(custom_error_exports, {
  CustomError: () => CustomError,
  customErrorFactory: () => customErrorFactory
});
function fixProto(target, prototype) {
  var setPrototypeOf = Object.setPrototypeOf;
  setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;
}
function fixStack(target, fn) {
  if (fn === void 0) {
    fn = target.constructor;
  }
  var captureStackTrace = Error.captureStackTrace;
  captureStackTrace && captureStackTrace(target, fn);
}
function customErrorFactory(fn, parent) {
  if (parent === void 0) {
    parent = Error;
  }
  function CustomError2() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!(this instanceof CustomError2))
      return new (CustomError2.bind.apply(CustomError2, __spreadArray([void 0], args, false)))();
    parent.apply(this, args);
    Object.defineProperty(this, "name", {
      value: fn.name || parent.name,
      enumerable: false,
      configurable: true
    });
    fn.apply(this, args);
    fixStack(this, CustomError2);
  }
  return Object.defineProperties(CustomError2, {
    prototype: {
      value: Object.create(parent.prototype, {
        constructor: {
          value: CustomError2,
          writable: true,
          configurable: true
        }
      })
    }
  });
}
var __extends, CustomError, __spreadArray;
var init_custom_error = __esm({
  "node_modules/ts-custom-error/dist/custom-error.mjs"() {
    __extends = function() {
      var _extendStatics = function extendStatics(d, b) {
        _extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) {
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
          }
        };
        return _extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        _extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    CustomError = function(_super) {
      __extends(CustomError2, _super);
      function CustomError2(message, options) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message, options) || this;
        Object.defineProperty(_this, "name", {
          value: _newTarget.name,
          enumerable: false,
          configurable: true
        });
        fixProto(_this, _newTarget.prototype);
        fixStack(_this);
        return _this;
      }
      return CustomError2;
    }(Error);
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
  }
});

// node_modules/starknet/dist/provider/errors.js
var require_errors = __commonJS({
  "node_modules/starknet/dist/provider/errors.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpError = exports.GatewayError = void 0;
    var ts_custom_error_1 = (init_custom_error(), __toCommonJS(custom_error_exports));
    var GatewayError = function(_super) {
      __extends2(GatewayError2, _super);
      function GatewayError2(message, errorCode) {
        var _this = _super.call(this, message) || this;
        _this.errorCode = errorCode;
        return _this;
      }
      return GatewayError2;
    }(ts_custom_error_1.CustomError);
    exports.GatewayError = GatewayError;
    var HttpError = function(_super) {
      __extends2(HttpError2, _super);
      function HttpError2(message, errorCode) {
        var _this = _super.call(this, message) || this;
        _this.errorCode = errorCode;
        return _this;
      }
      return HttpError2;
    }(ts_custom_error_1.CustomError);
    exports.HttpError = HttpError;
  }
});

// node_modules/starknet/dist/provider/interface.js
var require_interface = __commonJS({
  "node_modules/starknet/dist/provider/interface.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProviderInterface = void 0;
    var ProviderInterface = function() {
      function ProviderInterface2() {
      }
      return ProviderInterface2;
    }();
    exports.ProviderInterface = ProviderInterface;
  }
});

// node_modules/starknet/dist/provider/utils.js
var require_utils = __commonJS({
  "node_modules/starknet/dist/provider/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getFormattedBlockIdentifier = exports.getBlockIdentifier = exports.txIdentifier = exports.formatHash = void 0;
    var number_1 = require_number();
    function formatHash(hashValue) {
      if (typeof hashValue === "string")
        return hashValue;
      return (0, number_1.toHex)((0, number_1.toBN)(hashValue));
    }
    exports.formatHash = formatHash;
    function txIdentifier(txHash, txId) {
      if (!txHash) {
        return "transactionId=".concat(JSON.stringify(txId));
      }
      var hashString = formatHash(txHash);
      return "transactionHash=".concat(hashString);
    }
    exports.txIdentifier = txIdentifier;
    function getBlockIdentifier(blockIdentifier) {
      if (blockIdentifier === null || blockIdentifier === "latest") {
        return { type: "BLOCK_NUMBER", data: "latest" };
      }
      if (blockIdentifier === "pending") {
        return { type: "BLOCK_NUMBER", data: "pending" };
      }
      if (typeof blockIdentifier === "number" || typeof blockIdentifier === "bigint") {
        return { type: "BLOCK_NUMBER", data: blockIdentifier };
      }
      if (typeof blockIdentifier === "string" && blockIdentifier.startsWith("0x")) {
        return { type: "BLOCK_HASH", data: blockIdentifier };
      }
      if (typeof blockIdentifier === "string" && !Number.isNaN(parseInt(blockIdentifier, 10))) {
        return { type: "BLOCK_NUMBER", data: parseInt(blockIdentifier, 10) };
      }
      if (typeof blockIdentifier === "string") {
        throw new Error("Invalid block identifier: ".concat(blockIdentifier));
      }
      return { type: "BLOCK_HASH", data: blockIdentifier };
    }
    exports.getBlockIdentifier = getBlockIdentifier;
    function getFormattedBlockIdentifier(blockIdentifier) {
      if (blockIdentifier === void 0) {
        blockIdentifier = null;
      }
      var blockIdentifierObject = getBlockIdentifier(blockIdentifier);
      if (blockIdentifierObject.type === "BLOCK_NUMBER" && blockIdentifierObject.data === null) {
        return "";
      }
      if (blockIdentifierObject.type === "BLOCK_NUMBER") {
        return "blockNumber=".concat(blockIdentifierObject.data);
      }
      return "blockHash=".concat((0, number_1.toHex)((0, number_1.toBN)(blockIdentifierObject.data)));
    }
    exports.getFormattedBlockIdentifier = getFormattedBlockIdentifier;
  }
});

// node_modules/starknet/dist/provider/default.js
var require_default = __commonJS({
  "node_modules/starknet/dist/provider/default.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Provider = void 0;
    var url_join_1 = __importDefault(require_url_join());
    var constants_1 = require_constants();
    var hash_1 = require_hash2();
    var json_1 = require_json();
    var number_1 = require_number();
    var stark_1 = require_stark();
    var errors_1 = require_errors();
    var interface_1 = require_interface();
    var utils_1 = require_utils();
    function wait(delay) {
      return new Promise(function(res) {
        setTimeout(res, delay);
      });
    }
    function isEmptyQueryObject(obj) {
      return obj === void 0 || Object.keys(obj).length === 0 || Object.keys(obj).length === 1 && Object.entries(obj).every(function(_a) {
        var _b = __read(_a, 2), k = _b[0], v = _b[1];
        return k === "blockIdentifier" && v === null;
      });
    }
    var Provider = function() {
      function Provider2(optionsOrProvider) {
        if (optionsOrProvider === void 0) {
          optionsOrProvider = { network: "goerli-alpha" };
        }
        var _a;
        if (optionsOrProvider instanceof interface_1.ProviderInterface) {
          this.baseUrl = optionsOrProvider.baseUrl;
          this.feederGatewayUrl = optionsOrProvider.feederGatewayUrl;
          this.gatewayUrl = optionsOrProvider.gatewayUrl;
          this.chainId = (_a = optionsOrProvider.chainId) !== null && _a !== void 0 ? _a : Provider2.getChainIdFromBaseUrl(optionsOrProvider.baseUrl);
        } else {
          var baseUrl = "baseUrl" in optionsOrProvider ? optionsOrProvider.baseUrl : Provider2.getNetworkFromName(optionsOrProvider.network);
          this.baseUrl = baseUrl;
          this.chainId = Provider2.getChainIdFromBaseUrl(baseUrl);
          this.feederGatewayUrl = (0, url_join_1.default)(baseUrl, "feeder_gateway");
          this.gatewayUrl = (0, url_join_1.default)(baseUrl, "gateway");
        }
      }
      Provider2.getNetworkFromName = function(name) {
        switch (name) {
          case "mainnet-alpha":
            return "https://alpha-mainnet.starknet.io";
          case "goerli-alpha":
          default:
            return "https://alpha4.starknet.io";
        }
      };
      Provider2.getChainIdFromBaseUrl = function(baseUrl) {
        try {
          var url = new URL(baseUrl);
          if (url.host.includes("mainnet.starknet.io")) {
            return constants_1.StarknetChainId.MAINNET;
          }
        } catch (_a) {
          console.error("Could not parse baseUrl: ".concat(baseUrl));
        }
        return constants_1.StarknetChainId.TESTNET;
      };
      Provider2.prototype.getFetchUrl = function(endpoint) {
        var gatewayUrlEndpoints = ["add_transaction"];
        return gatewayUrlEndpoints.includes(endpoint) ? this.gatewayUrl : this.feederGatewayUrl;
      };
      Provider2.prototype.getFetchMethod = function(endpoint) {
        var postMethodEndpoints = ["add_transaction", "call_contract", "estimate_fee"];
        return postMethodEndpoints.includes(endpoint) ? "POST" : "GET";
      };
      Provider2.prototype.getQueryString = function(query) {
        if (isEmptyQueryObject(query)) {
          return "";
        }
        var queryString = Object.entries(query).map(function(_a) {
          var _b = __read(_a, 2), key = _b[0], value = _b[1];
          if (key === "blockIdentifier") {
            return "".concat((0, utils_1.getFormattedBlockIdentifier)(value));
          }
          return "".concat(key, "=").concat(value);
        }).join("&");
        return "?".concat(queryString);
      };
      Provider2.prototype.getHeaders = function(method) {
        if (method === "POST") {
          return {
            "Content-Type": "application/json"
          };
        }
        return void 0;
      };
      Provider2.prototype.fetchEndpoint = function(endpoint) {
        var _a = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          _a[_i - 1] = arguments[_i];
        }
        var _b = __read(_a, 2), query = _b[0], request = _b[1];
        return __awaiter(this, void 0, void 0, function() {
          var baseUrl, method, queryString, headers, url, res, textResponse, responseBody, errorCode, err_1;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                baseUrl = this.getFetchUrl(endpoint);
                method = this.getFetchMethod(endpoint);
                queryString = this.getQueryString(query);
                headers = this.getHeaders(method);
                url = (0, url_join_1.default)(baseUrl, endpoint, queryString);
                _c.label = 1;
              case 1:
                _c.trys.push([1, 4, , 5]);
                return [4, fetch(url, {
                  method,
                  body: (0, json_1.stringify)(request),
                  headers
                })];
              case 2:
                res = _c.sent();
                return [4, res.text()];
              case 3:
                textResponse = _c.sent();
                if (!res.ok) {
                  responseBody = void 0;
                  try {
                    responseBody = (0, json_1.parse)(textResponse);
                  } catch (_d) {
                    throw new errors_1.HttpError(res.statusText, res.status);
                  }
                  errorCode = responseBody.code || (responseBody === null || responseBody === void 0 ? void 0 : responseBody.status_code);
                  throw new errors_1.GatewayError(responseBody.message, errorCode);
                }
                if (endpoint === "estimate_fee") {
                  return [2, (0, json_1.parseAlwaysAsBig)(textResponse, function(_, v) {
                    if (v && typeof v === "bigint") {
                      return (0, number_1.toBN)(v.toString());
                    }
                    return v;
                  })];
                }
                return [2, (0, json_1.parse)(textResponse)];
              case 4:
                err_1 = _c.sent();
                if (err_1 instanceof errors_1.GatewayError || err_1 instanceof errors_1.HttpError) {
                  throw err_1;
                }
                if (err_1 instanceof Error) {
                  throw Error("Could not ".concat(method, " from endpoint `").concat(url, "`: ").concat(err_1.message));
                }
                throw err_1;
              case 5:
                return [2];
            }
          });
        });
      };
      Provider2.prototype.getContractAddresses = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, this.fetchEndpoint("get_contract_addresses")];
          });
        });
      };
      Provider2.prototype.callContract = function(_a, _b) {
        var contractAddress = _a.contractAddress, entrypoint = _a.entrypoint, _c = _a.calldata, calldata = _c === void 0 ? [] : _c;
        var _d = _b === void 0 ? {} : _b, _e = _d.blockIdentifier, blockIdentifier = _e === void 0 ? "pending" : _e;
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_f) {
            return [2, this.fetchEndpoint("call_contract", { blockIdentifier }, {
              signature: [],
              contract_address: contractAddress,
              entry_point_selector: (0, hash_1.getSelectorFromName)(entrypoint),
              calldata
            })];
          });
        });
      };
      Provider2.prototype.getBlock = function(blockIdentifier) {
        if (blockIdentifier === void 0) {
          blockIdentifier = null;
        }
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, this.fetchEndpoint("get_block", { blockIdentifier })];
          });
        });
      };
      Provider2.prototype.getCode = function(contractAddress, blockIdentifier) {
        if (blockIdentifier === void 0) {
          blockIdentifier = "pending";
        }
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, this.fetchEndpoint("get_code", { blockIdentifier, contractAddress })];
          });
        });
      };
      Provider2.prototype.getStorageAt = function(contractAddress, key, blockIdentifier) {
        if (blockIdentifier === void 0) {
          blockIdentifier = "pending";
        }
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, this.fetchEndpoint("get_storage_at", { blockIdentifier, contractAddress, key })];
          });
        });
      };
      Provider2.prototype.getTransactionStatus = function(txHash) {
        return __awaiter(this, void 0, void 0, function() {
          var txHashHex;
          return __generator(this, function(_a) {
            txHashHex = (0, number_1.toHex)((0, number_1.toBN)(txHash));
            return [2, this.fetchEndpoint("get_transaction_status", { transactionHash: txHashHex })];
          });
        });
      };
      Provider2.prototype.getTransactionReceipt = function(txHash) {
        return __awaiter(this, void 0, void 0, function() {
          var txHashHex;
          return __generator(this, function(_a) {
            txHashHex = (0, number_1.toHex)((0, number_1.toBN)(txHash));
            return [2, this.fetchEndpoint("get_transaction_receipt", { transactionHash: txHashHex })];
          });
        });
      };
      Provider2.prototype.getTransaction = function(txHash) {
        return __awaiter(this, void 0, void 0, function() {
          var txHashHex;
          return __generator(this, function(_a) {
            txHashHex = (0, number_1.toHex)((0, number_1.toBN)(txHash));
            return [2, this.fetchEndpoint("get_transaction", { transactionHash: txHashHex })];
          });
        });
      };
      Provider2.prototype.getTransactionTrace = function(txHash) {
        return __awaiter(this, void 0, void 0, function() {
          var txHashHex;
          return __generator(this, function(_a) {
            txHashHex = (0, number_1.toHex)((0, number_1.toBN)(txHash));
            return [2, this.fetchEndpoint("get_transaction_trace", { transactionHash: txHashHex })];
          });
        });
      };
      Provider2.prototype.declareContract = function(payload) {
        var parsedContract = typeof payload.contract === "string" ? (0, json_1.parse)(payload.contract) : payload.contract;
        var contractDefinition = __assign(__assign({}, parsedContract), { program: (0, stark_1.compressProgram)(parsedContract.program) });
        return this.fetchEndpoint("add_transaction", void 0, {
          type: "DECLARE",
          contract_class: contractDefinition,
          nonce: (0, number_1.toHex)(constants_1.ZERO),
          signature: [],
          sender_address: (0, number_1.toHex)(constants_1.ONE)
        });
      };
      Provider2.prototype.deployContract = function(payload, _abi) {
        var _a, _b;
        var parsedContract = typeof payload.contract === "string" ? (0, json_1.parse)(payload.contract) : payload.contract;
        var contractDefinition = __assign(__assign({}, parsedContract), { program: (0, stark_1.compressProgram)(parsedContract.program) });
        return this.fetchEndpoint("add_transaction", void 0, {
          type: "DEPLOY",
          contract_address_salt: (_a = payload.addressSalt) !== null && _a !== void 0 ? _a : (0, stark_1.randomAddress)(),
          constructor_calldata: (0, number_1.bigNumberishArrayToDecimalStringArray)((_b = payload.constructorCalldata) !== null && _b !== void 0 ? _b : []),
          contract_definition: contractDefinition
        });
      };
      Provider2.prototype.invokeFunction = function(invocation, _abi) {
        var _a, _b;
        return this.fetchEndpoint("add_transaction", void 0, {
          type: "INVOKE_FUNCTION",
          contract_address: invocation.contractAddress,
          entry_point_selector: (0, hash_1.getSelectorFromName)(invocation.entrypoint),
          calldata: (0, number_1.bigNumberishArrayToDecimalStringArray)((_a = invocation.calldata) !== null && _a !== void 0 ? _a : []),
          signature: (0, number_1.bigNumberishArrayToDecimalStringArray)((_b = invocation.signature) !== null && _b !== void 0 ? _b : [])
        });
      };
      Provider2.prototype.waitForTransaction = function(txHash, retryInterval) {
        if (retryInterval === void 0) {
          retryInterval = 8e3;
        }
        return __awaiter(this, void 0, void 0, function() {
          var onchain, res, successStates, errorStates, message, error;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                onchain = false;
                _a.label = 1;
              case 1:
                if (!!onchain)
                  return [3, 4];
                return [4, wait(retryInterval)];
              case 2:
                _a.sent();
                return [4, this.getTransactionStatus(txHash)];
              case 3:
                res = _a.sent();
                successStates = ["ACCEPTED_ON_L1", "ACCEPTED_ON_L2", "PENDING"];
                errorStates = ["REJECTED", "NOT_RECEIVED"];
                if (successStates.includes(res.tx_status)) {
                  onchain = true;
                } else if (errorStates.includes(res.tx_status)) {
                  message = res.tx_failure_reason ? "".concat(res.tx_status, ": ").concat(res.tx_failure_reason.code, "\n").concat(res.tx_failure_reason.error_message) : res.tx_status;
                  error = new Error(message);
                  error.response = res;
                  throw error;
                }
                return [3, 1];
              case 4:
                return [2];
            }
          });
        });
      };
      Provider2.prototype.waitForTx = function(txHash, retryInterval) {
        if (retryInterval === void 0) {
          retryInterval = 8e3;
        }
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, this.waitForTransaction(txHash, retryInterval)];
          });
        });
      };
      return Provider2;
    }();
    exports.Provider = Provider;
  }
});

// node_modules/starknet/dist/provider/index.js
var require_provider = __commonJS({
  "node_modules/starknet/dist/provider/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultProvider = void 0;
    var default_1 = require_default();
    __exportStar(require_default(), exports);
    __exportStar(require_errors(), exports);
    __exportStar(require_interface(), exports);
    exports.defaultProvider = new default_1.Provider();
  }
});

// node_modules/starknet/dist/contract/default.js
var require_default2 = __commonJS({
  "node_modules/starknet/dist/contract/default.js"(exports) {
    "use strict";
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Contract = void 0;
    var bn_js_1 = __importDefault(require_bn());
    var minimalistic_assert_1 = __importDefault(require_minimalistic_assert());
    var provider_1 = require_provider();
    var number_1 = require_number();
    function parseFelt(candidate) {
      try {
        return (0, number_1.toBN)(candidate);
      } catch (e) {
        throw Error("Couldnt parse felt");
      }
    }
    function buildCall(contract, functionAbi) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, contract.call(functionAbi.name, args)];
          });
        });
      };
    }
    function buildInvoke(contract, functionAbi) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function() {
          var inputs, inputsLength, options;
          return __generator(this, function(_a) {
            inputs = functionAbi.inputs;
            inputsLength = inputs.reduce(function(acc, input) {
              if (!/_len$/.test(input.name)) {
                return acc + 1;
              }
              return acc;
            }, 0);
            options = {};
            if (inputsLength + 1 === args.length && typeof args[args.length - 1] === "object") {
              Object.assign(options, args.pop());
            }
            return [2, contract.invoke(functionAbi.name, args, options)];
          });
        });
      };
    }
    function buildDefault(contract, functionAbi) {
      if (functionAbi.stateMutability === "view") {
        return buildCall(contract, functionAbi);
      }
      return buildInvoke(contract, functionAbi);
    }
    function buildPopulate(contract, functionAbi) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return contract.populate(functionAbi.name, args);
      };
    }
    function buildEstimate(contract, functionAbi) {
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return contract.estimate(functionAbi.name, args);
      };
    }
    var Contract = function() {
      function Contract2(abi, address, providerOrAccount) {
        if (providerOrAccount === void 0) {
          providerOrAccount = provider_1.defaultProvider;
        }
        var _this = this;
        this.address = address;
        this.providerOrAccount = providerOrAccount;
        this.abi = abi;
        this.structs = abi.filter(function(abiEntry) {
          return abiEntry.type === "struct";
        }).reduce(function(acc, abiEntry) {
          var _a;
          return __assign(__assign({}, acc), (_a = {}, _a[abiEntry.name] = abiEntry, _a));
        }, {});
        Object.defineProperty(this, "functions", {
          enumerable: true,
          value: {},
          writable: false
        });
        Object.defineProperty(this, "callStatic", {
          enumerable: true,
          value: {},
          writable: false
        });
        Object.defineProperty(this, "populateTransaction", {
          enumerable: true,
          value: {},
          writable: false
        });
        Object.defineProperty(this, "estimateFee", {
          enumerable: true,
          value: {},
          writable: false
        });
        this.abi.forEach(function(abiElement) {
          if (abiElement.type !== "function") {
            return;
          }
          var signature = abiElement.name;
          if (!_this[signature]) {
            Object.defineProperty(_this, signature, {
              enumerable: true,
              value: buildDefault(_this, abiElement),
              writable: false
            });
          }
          if (!_this.functions[signature]) {
            Object.defineProperty(_this.functions, signature, {
              enumerable: true,
              value: buildDefault(_this, abiElement),
              writable: false
            });
          }
          if (!_this.callStatic[signature]) {
            Object.defineProperty(_this.callStatic, signature, {
              enumerable: true,
              value: buildCall(_this, abiElement),
              writable: false
            });
          }
          if (!_this.populateTransaction[signature]) {
            Object.defineProperty(_this.populateTransaction, signature, {
              enumerable: true,
              value: buildPopulate(_this, abiElement),
              writable: false
            });
          }
          if (!_this.estimateFee[signature]) {
            Object.defineProperty(_this.estimateFee, signature, {
              enumerable: true,
              value: buildEstimate(_this, abiElement),
              writable: false
            });
          }
        });
      }
      Contract2.prototype.attach = function(address) {
        this.address = address;
      };
      Contract2.prototype.connect = function(providerOrAccount) {
        this.providerOrAccount = providerOrAccount;
      };
      Contract2.prototype.deployed = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!this.deployTransactionHash)
                  return [3, 2];
                return [4, this.providerOrAccount.waitForTransaction(this.deployTransactionHash)];
              case 1:
                _a.sent();
                this.deployTransactionHash = void 0;
                _a.label = 2;
              case 2:
                return [2, this];
            }
          });
        });
      };
      Contract2.prototype.validateMethodAndArgs = function(type, method, args) {
        var _this = this;
        if (args === void 0) {
          args = [];
        }
        var invokeableFunctionNames = this.abi.filter(function(abi) {
          if (abi.type !== "function")
            return false;
          var isView = abi.stateMutability === "view";
          return type === "INVOKE" ? !isView : isView;
        }).map(function(abi) {
          return abi.name;
        });
        (0, minimalistic_assert_1.default)(invokeableFunctionNames.includes(method), "".concat(type === "INVOKE" ? "invokeable" : "viewable", " method not found in abi"));
        var methodAbi = this.abi.find(function(abi) {
          return abi.name === method && abi.type === "function";
        });
        var argPosition = 0;
        methodAbi.inputs.forEach(function(input) {
          if (/_len$/.test(input.name)) {
            return;
          }
          if (input.type === "felt") {
            (0, minimalistic_assert_1.default)(typeof args[argPosition] === "string" || typeof args[argPosition] === "number" || args[argPosition] instanceof bn_js_1.default, "arg ".concat(input.name, " should be a felt (string, number, BigNumber)"));
            argPosition += 1;
          } else if (input.type in _this.structs && typeof args[argPosition] === "object") {
            if (Array.isArray(args[argPosition])) {
              var structMembersLength = _this.calculateStructMembers(input.type);
              (0, minimalistic_assert_1.default)(args[argPosition].length === structMembersLength, "arg should be of length ".concat(structMembersLength));
            } else {
              _this.structs[input.type].members.forEach(function(_a) {
                var name = _a.name;
                (0, minimalistic_assert_1.default)(Object.keys(args[argPosition]).includes(name), "arg should have a property ".concat(name));
              });
            }
            argPosition += 1;
          } else {
            (0, minimalistic_assert_1.default)(Array.isArray(args[argPosition]), "arg ".concat(input.name, " should be an Array"));
            if (input.type === "felt*") {
              args[argPosition].forEach(function(felt) {
                (0, minimalistic_assert_1.default)(typeof felt === "string" || typeof felt === "number" || felt instanceof bn_js_1.default, "arg ".concat(input.name, " should be an array of string, number or BigNumber"));
              });
              argPosition += 1;
            } else if (/\(felt/.test(input.type)) {
              var tupleLength = input.type.split(",").length;
              (0, minimalistic_assert_1.default)(args[argPosition].length === tupleLength, "arg ".concat(input.name, " should have ").concat(tupleLength, " elements in tuple"));
              args[argPosition].forEach(function(felt) {
                (0, minimalistic_assert_1.default)(typeof felt === "string" || typeof felt === "number" || felt instanceof bn_js_1.default, "arg ".concat(input.name, " should be an array of string, number or BigNumber"));
              });
              argPosition += 1;
            } else {
              var arrayType_1 = input.type.replace("*", "");
              args[argPosition].forEach(function(struct) {
                _this.structs[arrayType_1].members.forEach(function(_a) {
                  var name = _a.name;
                  if (Array.isArray(struct)) {
                    var structMembersLength2 = _this.calculateStructMembers(arrayType_1);
                    (0, minimalistic_assert_1.default)(struct.length === structMembersLength2, "arg should be of length ".concat(structMembersLength2));
                  } else {
                    (0, minimalistic_assert_1.default)(Object.keys(struct).includes(name), "arg ".concat(input.name, " should be an array of ").concat(arrayType_1));
                  }
                });
              });
              argPosition += 1;
            }
          }
        });
      };
      Contract2.prototype.calculateStructMembers = function(struct) {
        var _this = this;
        return this.structs[struct].members.reduce(function(acc, member) {
          if (member.type === "felt") {
            return acc + 1;
          }
          return acc + _this.calculateStructMembers(member.type);
        }, 0);
      };
      Contract2.prototype.parseCalldataValue = function(element, type) {
        var _this = this;
        if (element === void 0) {
          throw Error("Missing element in calldata");
        }
        if (Array.isArray(element)) {
          var structMemberNum = this.calculateStructMembers(type);
          if (element.length !== structMemberNum) {
            throw Error("Missing element in calldata");
          }
          return element.map(function(el) {
            return (0, number_1.toFelt)(el);
          });
        }
        if (this.structs[type] && this.structs[type].members.length) {
          return this.structs[type].members.reduce(function(acc, member) {
            var parsedData = _this.parseCalldataValue(element[member.name], member.type);
            if (typeof parsedData === "string") {
              acc.push(parsedData);
            } else {
              acc.push.apply(acc, __spreadArray2([], __read(parsedData), false));
            }
            return acc;
          }, []);
        }
        return (0, number_1.toFelt)(element);
      };
      Contract2.prototype.parseResponseStruct = function(responseIterator, type) {
        var _this = this;
        if (type in this.structs && this.structs[type]) {
          return this.structs[type].members.reduce(function(acc, el) {
            acc[el.name] = _this.parseResponseStruct(responseIterator, el.type);
            return acc;
          }, {});
        }
        return parseFelt(responseIterator.next().value);
      };
      Contract2.prototype.parseCalldataField = function(argsIterator, input) {
        var _this = this;
        var name = input.name, type = input.type;
        var value = argsIterator.next().value;
        var parsedCalldata = [];
        switch (true) {
          case /\*/.test(type):
            if (Array.isArray(value)) {
              parsedCalldata.push((0, number_1.toFelt)(value.length));
              return value.reduce(function(acc, el) {
                if (/felt/.test(type)) {
                  acc.push((0, number_1.toFelt)(el));
                } else {
                  acc.push.apply(acc, __spreadArray2([], __read(_this.parseCalldataValue(el, type.replace("*", ""))), false));
                }
                return acc;
              }, parsedCalldata);
            }
            throw Error("Expected ".concat(name, " to be array"));
          case type in this.structs:
            return this.parseCalldataValue(value, type);
          case /\(felt/.test(type):
            if (Array.isArray(value)) {
              return value.map(function(el) {
                return (0, number_1.toFelt)(el);
              });
            }
            throw Error("Expected ".concat(name, " to be array"));
          default:
            return (0, number_1.toFelt)(value);
        }
      };
      Contract2.prototype.compileCalldata = function(args, inputs) {
        var _this = this;
        var argsIterator = args[Symbol.iterator]();
        return inputs.reduce(function(acc, input) {
          if (/_len$/.test(input.name)) {
            return acc;
          }
          var parsedData = _this.parseCalldataField(argsIterator, input);
          if (Array.isArray(parsedData)) {
            acc.push.apply(acc, __spreadArray2([], __read(parsedData), false));
          } else {
            acc.push(parsedData);
          }
          return acc;
        }, []);
      };
      Contract2.prototype.parseResponseField = function(responseIterator, output, parsedResult) {
        var name = output.name, type = output.type;
        var parsedDataArr = [];
        switch (true) {
          case /_len$/.test(name):
            return parseFelt(responseIterator.next().value).toNumber();
          case /\(felt/.test(type):
            return type.split(",").reduce(function(acc) {
              acc.push(parseFelt(responseIterator.next().value));
              return acc;
            }, []);
          case /\*/.test(type):
            if (parsedResult && parsedResult["".concat(name, "_len")]) {
              var arrLen = parsedResult["".concat(name, "_len")];
              while (parsedDataArr.length < arrLen) {
                parsedDataArr.push(this.parseResponseStruct(responseIterator, output.type.replace("*", "")));
              }
            }
            return parsedDataArr;
          case type in this.structs:
            return this.parseResponseStruct(responseIterator, type);
          default:
            return parseFelt(responseIterator.next().value);
        }
      };
      Contract2.prototype.parseResponse = function(method, response) {
        var _this = this;
        var outputs = this.abi.find(function(abi) {
          return abi.name === method;
        }).outputs;
        var responseIterator = response.flat()[Symbol.iterator]();
        var resultObject = outputs.flat().reduce(function(acc, output) {
          acc[output.name] = _this.parseResponseField(responseIterator, output, acc);
          if (acc[output.name] && acc["".concat(output.name, "_len")]) {
            delete acc["".concat(output.name, "_len")];
          }
          return acc;
        }, {});
        return Object.entries(resultObject).reduce(function(acc, _a) {
          var _b = __read(_a, 2), key = _b[0], value = _b[1];
          acc.push(value);
          acc[key] = value;
          return acc;
        }, []);
      };
      Contract2.prototype.invoke = function(method, args, options) {
        if (args === void 0) {
          args = [];
        }
        if (options === void 0) {
          options = {};
        }
        (0, minimalistic_assert_1.default)(this.address !== null, "contract isnt connected to an address");
        this.validateMethodAndArgs("INVOKE", method, args);
        var inputs = this.abi.find(function(abi) {
          return abi.name === method;
        }).inputs;
        var inputsLength = inputs.reduce(function(acc, input) {
          if (!/_len$/.test(input.name)) {
            return acc + 1;
          }
          return acc;
        }, 0);
        if (args.length !== inputsLength) {
          throw Error("Invalid number of arguments, expected ".concat(inputsLength, " arguments, but got ").concat(args.length));
        }
        var calldata = this.compileCalldata(args, inputs);
        var invocation = {
          contractAddress: this.address,
          calldata,
          entrypoint: method
        };
        if ("execute" in this.providerOrAccount) {
          return this.providerOrAccount.execute(invocation, void 0, {
            maxFee: options.maxFee,
            nonce: options.nonce
          });
        }
        return this.providerOrAccount.invokeFunction(__assign(__assign({}, invocation), { signature: options.signature || [] }));
      };
      Contract2.prototype.call = function(method, args, _a) {
        if (args === void 0) {
          args = [];
        }
        var _b = _a === void 0 ? {} : _a, _c = _b.blockIdentifier, blockIdentifier = _c === void 0 ? "pending" : _c;
        return __awaiter(this, void 0, void 0, function() {
          var inputs, calldata;
          var _this = this;
          return __generator(this, function(_d) {
            (0, minimalistic_assert_1.default)(this.address !== null, "contract isnt connected to an address");
            this.validateMethodAndArgs("CALL", method, args);
            inputs = this.abi.find(function(abi) {
              return abi.name === method;
            }).inputs;
            calldata = this.compileCalldata(args, inputs);
            return [2, this.providerOrAccount.callContract({
              contractAddress: this.address,
              calldata,
              entrypoint: method
            }, { blockIdentifier }).then(function(x) {
              return _this.parseResponse(method, x.result);
            })];
          });
        });
      };
      Contract2.prototype.estimate = function(method, args) {
        if (args === void 0) {
          args = [];
        }
        return __awaiter(this, void 0, void 0, function() {
          var invocation;
          var _a;
          return __generator(this, function(_b) {
            (0, minimalistic_assert_1.default)(this.address !== null, "contract isnt connected to an address");
            this.validateMethodAndArgs("INVOKE", method, args);
            invocation = (_a = this.populateTransaction)[method].apply(_a, __spreadArray2([], __read(args), false));
            if ("estimateFee" in this.providerOrAccount) {
              return [2, this.providerOrAccount.estimateFee(invocation)];
            }
            throw Error("Contract must be connected to the account contract to estimate");
          });
        });
      };
      Contract2.prototype.populate = function(method, args) {
        if (args === void 0) {
          args = [];
        }
        var inputs = this.abi.find(function(abi) {
          return abi.name === method;
        }).inputs;
        return {
          contractAddress: this.address,
          entrypoint: method,
          calldata: this.compileCalldata(args, inputs),
          signature: []
        };
      };
      return Contract2;
    }();
    exports.Contract = Contract;
  }
});

// node_modules/starknet/dist/contract/interface.js
var require_interface2 = __commonJS({
  "node_modules/starknet/dist/contract/interface.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContractInterface = void 0;
    var ContractInterface = function() {
      function ContractInterface2() {
      }
      return ContractInterface2;
    }();
    exports.ContractInterface = ContractInterface;
  }
});

// node_modules/starknet/dist/contract/contractFactory.js
var require_contractFactory = __commonJS({
  "node_modules/starknet/dist/contract/contractFactory.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContractFactory = void 0;
    var minimalistic_assert_1 = __importDefault(require_minimalistic_assert());
    var provider_1 = require_provider();
    var default_1 = require_default2();
    var ContractFactory = function() {
      function ContractFactory2(compiledContract, providerOrAccount, abi) {
        if (providerOrAccount === void 0) {
          providerOrAccount = provider_1.defaultProvider;
        }
        if (abi === void 0) {
          abi = compiledContract.abi;
        }
        this.abi = abi;
        this.compiledContract = compiledContract;
        this.providerOrAccount = providerOrAccount;
      }
      ContractFactory2.prototype.deploy = function(constructorCalldata, addressSalt) {
        return __awaiter(this, void 0, void 0, function() {
          var _a, address, code, transaction_hash, contractInstance;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this.providerOrAccount.deployContract({
                  contract: this.compiledContract,
                  constructorCalldata,
                  addressSalt
                })];
              case 1:
                _a = _b.sent(), address = _a.address, code = _a.code, transaction_hash = _a.transaction_hash;
                (0, minimalistic_assert_1.default)(code === "TRANSACTION_RECEIVED" && Boolean(address), "Deployment of the contract failed");
                contractInstance = new default_1.Contract(this.compiledContract.abi, address, this.providerOrAccount);
                contractInstance.deployTransactionHash = transaction_hash;
                return [2, contractInstance];
            }
          });
        });
      };
      ContractFactory2.prototype.connect = function(providerOrAccount) {
        this.providerOrAccount = providerOrAccount;
        return this;
      };
      ContractFactory2.prototype.attach = function(address) {
        return new default_1.Contract(this.abi, address, this.providerOrAccount);
      };
      return ContractFactory2;
    }();
    exports.ContractFactory = ContractFactory;
  }
});

// node_modules/starknet/dist/contract/index.js
var require_contract = __commonJS({
  "node_modules/starknet/dist/contract/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_default2(), exports);
    __exportStar(require_interface2(), exports);
    __exportStar(require_contractFactory(), exports);
  }
});

// node_modules/starknet/dist/types/lib.js
var require_lib = __commonJS({
  "node_modules/starknet/dist/types/lib.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/starknet/dist/types/api.js
var require_api = __commonJS({
  "node_modules/starknet/dist/types/api.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/starknet/dist/types/signer.js
var require_signer = __commonJS({
  "node_modules/starknet/dist/types/signer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/starknet/dist/types/contract.js
var require_contract2 = __commonJS({
  "node_modules/starknet/dist/types/contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/starknet/dist/types/account.js
var require_account = __commonJS({
  "node_modules/starknet/dist/types/account.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/starknet/dist/types/index.js
var require_types = __commonJS({
  "node_modules/starknet/dist/types/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_lib(), exports);
    __exportStar(require_api(), exports);
    __exportStar(require_signer(), exports);
    __exportStar(require_contract2(), exports);
    __exportStar(require_account(), exports);
  }
});

// node_modules/starknet/dist/signer/interface.js
var require_interface3 = __commonJS({
  "node_modules/starknet/dist/signer/interface.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SignerInterface = void 0;
    var SignerInterface = function() {
      function SignerInterface2() {
      }
      return SignerInterface2;
    }();
    exports.SignerInterface = SignerInterface;
  }
});

// node_modules/starknet/dist/utils/transaction.js
var require_transaction = __commonJS({
  "node_modules/starknet/dist/utils/transaction.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.fromCallsToExecuteCalldataWithNonce = exports.fromCallsToExecuteCalldata = exports.transformCallsToMulticallArrays = void 0;
    var hash_1 = require_hash2();
    var number_1 = require_number();
    var transformCallsToMulticallArrays = function(calls) {
      var callArray = [];
      var calldata = [];
      calls.forEach(function(call) {
        var data = call.calldata || [];
        callArray.push({
          to: (0, number_1.toBN)(call.contractAddress).toString(10),
          selector: (0, number_1.toBN)((0, hash_1.getSelectorFromName)(call.entrypoint)).toString(10),
          data_offset: calldata.length.toString(),
          data_len: data.length.toString()
        });
        calldata.push.apply(calldata, __spreadArray2([], __read(data), false));
      });
      return {
        callArray,
        calldata: (0, number_1.bigNumberishArrayToDecimalStringArray)(calldata)
      };
    };
    exports.transformCallsToMulticallArrays = transformCallsToMulticallArrays;
    var fromCallsToExecuteCalldata = function(calls) {
      var _a = (0, exports.transformCallsToMulticallArrays)(calls), callArray = _a.callArray, calldata = _a.calldata;
      return __spreadArray2(__spreadArray2(__spreadArray2([
        callArray.length.toString()
      ], __read(callArray.map(function(_a2) {
        var to = _a2.to, selector = _a2.selector, data_offset = _a2.data_offset, data_len = _a2.data_len;
        return [to, selector, data_offset, data_len];
      }).flat()), false), [
        calldata.length.toString()
      ], false), __read(calldata), false);
    };
    exports.fromCallsToExecuteCalldata = fromCallsToExecuteCalldata;
    var fromCallsToExecuteCalldataWithNonce = function(calls, nonce) {
      return __spreadArray2(__spreadArray2([], __read((0, exports.fromCallsToExecuteCalldata)(calls)), false), [(0, number_1.toBN)(nonce).toString()], false);
    };
    exports.fromCallsToExecuteCalldataWithNonce = fromCallsToExecuteCalldataWithNonce;
  }
});

// node_modules/starknet/dist/utils/shortString.js
var require_shortString = __commonJS({
  "node_modules/starknet/dist/utils/shortString.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeShortString = exports.encodeShortString = exports.isShortString = exports.isASCII = void 0;
    var encode_1 = require_encode();
    function isASCII(str) {
      return /^[\x00-\x7F]*$/.test(str);
    }
    exports.isASCII = isASCII;
    function isShortString(str) {
      return str.length <= 31;
    }
    exports.isShortString = isShortString;
    function encodeShortString(str) {
      if (!isASCII(str))
        throw new Error("".concat(str, " is not an ASCII string"));
      if (!isShortString(str))
        throw new Error("".concat(str, " is too long"));
      return (0, encode_1.addHexPrefix)(str.replace(/./g, function(char) {
        return char.charCodeAt(0).toString(16);
      }));
    }
    exports.encodeShortString = encodeShortString;
    function decodeShortString(str) {
      return (0, encode_1.removeHexPrefix)(str).replace(/.{2}/g, function(hex) {
        return String.fromCharCode(parseInt(hex, 16));
      });
    }
    exports.decodeShortString = decodeShortString;
  }
});

// node_modules/starknet/dist/utils/typedData/utils.js
var require_utils2 = __commonJS({
  "node_modules/starknet/dist/utils/typedData/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTypedData = void 0;
    var validateTypedData = function(data) {
      var typedData = data;
      var valid = Boolean(typedData.types && typedData.primaryType && typedData.message);
      return valid;
    };
    exports.validateTypedData = validateTypedData;
  }
});

// node_modules/starknet/dist/utils/typedData/types.js
var require_types2 = __commonJS({
  "node_modules/starknet/dist/utils/typedData/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/starknet/dist/utils/typedData/index.js
var require_typedData = __commonJS({
  "node_modules/starknet/dist/utils/typedData/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getMessageHash = exports.getStructHash = exports.encodeData = exports.getTypeHash = exports.encodeType = exports.getDependencies = void 0;
    var hash_1 = require_hash2();
    var number_1 = require_number();
    var shortString_1 = require_shortString();
    var utils_1 = require_utils2();
    __exportStar(require_types2(), exports);
    function getHex(value) {
      try {
        return (0, number_1.toHex)((0, number_1.toBN)(value));
      } catch (e) {
        if (typeof value === "string") {
          return (0, number_1.toHex)((0, number_1.toBN)((0, shortString_1.encodeShortString)(value)));
        }
        throw new Error("Invalid BigNumberish: ".concat(value));
      }
    }
    var getDependencies = function(typedData, type, dependencies) {
      if (dependencies === void 0) {
        dependencies = [];
      }
      if (!(0, utils_1.validateTypedData)(typedData)) {
        throw new Error("Typed data does not match JSON schema");
      }
      if (dependencies.includes(type)) {
        return dependencies;
      }
      if (!typedData.types[type]) {
        return dependencies;
      }
      return __spreadArray2([
        type
      ], __read(typedData.types[type].reduce(function(previous, t) {
        return __spreadArray2(__spreadArray2([], __read(previous), false), __read((0, exports.getDependencies)(typedData, t.type, previous).filter(function(dependency) {
          return !previous.includes(dependency);
        })), false);
      }, [])), false);
    };
    exports.getDependencies = getDependencies;
    var encodeType = function(typedData, type) {
      var _a = __read((0, exports.getDependencies)(typedData, type)), primary = _a[0], dependencies = _a.slice(1);
      var types = __spreadArray2([primary], __read(dependencies.sort()), false);
      return types.map(function(dependency) {
        return "".concat(dependency, "(").concat(typedData.types[dependency].map(function(t) {
          return "".concat(t.name, ":").concat(t.type);
        }), ")");
      }).join("");
    };
    exports.encodeType = encodeType;
    var getTypeHash = function(typedData, type) {
      return (0, hash_1.getSelectorFromName)((0, exports.encodeType)(typedData, type));
    };
    exports.getTypeHash = getTypeHash;
    var encodeValue = function(typedData, type, data) {
      if (typedData.types[type]) {
        return [type, (0, exports.getStructHash)(typedData, type, data)];
      }
      if (type === "felt*") {
        return ["felt*", (0, hash_1.computeHashOnElements)(data)];
      }
      return [type, getHex(data)];
    };
    var encodeData = function(typedData, type, data) {
      var _a = __read(typedData.types[type].reduce(function(_a2, field) {
        var _b = __read(_a2, 2), ts = _b[0], vs = _b[1];
        if (data[field.name] === void 0 || data[field.name] === null) {
          throw new Error("Cannot encode data: missing data for '".concat(field.name, "'"));
        }
        var value = data[field.name];
        var _c = __read(encodeValue(typedData, field.type, value), 2), t = _c[0], encodedValue = _c[1];
        return [
          __spreadArray2(__spreadArray2([], __read(ts), false), [t], false),
          __spreadArray2(__spreadArray2([], __read(vs), false), [encodedValue], false)
        ];
      }, [["felt"], [(0, exports.getTypeHash)(typedData, type)]]), 2), types = _a[0], values = _a[1];
      return [types, values];
    };
    exports.encodeData = encodeData;
    var getStructHash = function(typedData, type, data) {
      return (0, hash_1.computeHashOnElements)((0, exports.encodeData)(typedData, type, data)[1]);
    };
    exports.getStructHash = getStructHash;
    var getMessageHash = function(typedData, account) {
      var message = [
        (0, shortString_1.encodeShortString)("StarkNet Message"),
        (0, exports.getStructHash)(typedData, "StarkNetDomain", typedData.domain),
        account,
        (0, exports.getStructHash)(typedData, typedData.primaryType, typedData.message)
      ];
      return (0, hash_1.computeHashOnElements)(message);
    };
    exports.getMessageHash = getMessageHash;
  }
});

// node_modules/starknet/dist/signer/default.js
var require_default3 = __commonJS({
  "node_modules/starknet/dist/signer/default.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Signer = void 0;
    var ellipticCurve_1 = require_ellipticCurve();
    var hash_1 = require_hash2();
    var transaction_1 = require_transaction();
    var typedData_1 = require_typedData();
    var Signer = function() {
      function Signer2(keyPair) {
        this.keyPair = keyPair;
      }
      Signer2.prototype.getPubKey = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, (0, ellipticCurve_1.getStarkKey)(this.keyPair)];
          });
        });
      };
      Signer2.prototype.signTransaction = function(transactions, transactionsDetail, abis) {
        return __awaiter(this, void 0, void 0, function() {
          var calldata, msgHash;
          return __generator(this, function(_a) {
            if (abis && abis.length !== transactions.length) {
              throw new Error("ABI must be provided for each transaction or no transaction");
            }
            calldata = (0, transaction_1.fromCallsToExecuteCalldataWithNonce)(transactions, transactionsDetail.nonce);
            msgHash = (0, hash_1.calculcateTransactionHash)(transactionsDetail.walletAddress, transactionsDetail.version, (0, hash_1.getSelectorFromName)("__execute__"), calldata, transactionsDetail.maxFee, transactionsDetail.chainId);
            return [2, (0, ellipticCurve_1.sign)(this.keyPair, msgHash)];
          });
        });
      };
      Signer2.prototype.signMessage = function(typedData, accountAddress) {
        return __awaiter(this, void 0, void 0, function() {
          var msgHash;
          return __generator(this, function(_a) {
            msgHash = (0, typedData_1.getMessageHash)(typedData, accountAddress);
            return [2, (0, ellipticCurve_1.sign)(this.keyPair, msgHash)];
          });
        });
      };
      return Signer2;
    }();
    exports.Signer = Signer;
  }
});

// node_modules/starknet/dist/signer/index.js
var require_signer2 = __commonJS({
  "node_modules/starknet/dist/signer/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_interface3(), exports);
    __exportStar(require_default3(), exports);
  }
});

// node_modules/starknet/dist/account/default.js
var require_default4 = __commonJS({
  "node_modules/starknet/dist/account/default.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports && exports.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray2 = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Account = void 0;
    var minimalistic_assert_1 = __importDefault(require_minimalistic_assert());
    var constants_1 = require_constants();
    var provider_1 = require_provider();
    var signer_1 = require_signer2();
    var ellipticCurve_1 = require_ellipticCurve();
    var hash_1 = require_hash2();
    var number_1 = require_number();
    var shortString_1 = require_shortString();
    var stark_1 = require_stark();
    var transaction_1 = require_transaction();
    var typedData_1 = require_typedData();
    var Account = function(_super) {
      __extends2(Account2, _super);
      function Account2(provider, address, keyPairOrSigner) {
        var _this = _super.call(this, provider) || this;
        _this.signer = "getPubKey" in keyPairOrSigner ? keyPairOrSigner : new signer_1.Signer(keyPairOrSigner);
        _this.address = address;
        return _this;
      }
      Account2.prototype.getNonce = function() {
        return __awaiter(this, void 0, void 0, function() {
          var result;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.callContract({
                  contractAddress: this.address,
                  entrypoint: "get_nonce"
                })];
              case 1:
                result = _a.sent().result;
                return [2, (0, number_1.toHex)((0, number_1.toBN)(result[0]))];
            }
          });
        });
      };
      Account2.prototype.estimateFee = function(calls, _a) {
        var _b = _a === void 0 ? {} : _a, providedNonce = _b.nonce, _c = _b.blockIdentifier, blockIdentifier = _c === void 0 ? "pending" : _c;
        return __awaiter(this, void 0, void 0, function() {
          var transactions, nonce, _d, version, signerDetails, signature, calldata, fetchedEstimate, suggestedMaxFee;
          return __generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                transactions = Array.isArray(calls) ? calls : [calls];
                if (!(providedNonce !== null && providedNonce !== void 0))
                  return [3, 1];
                _d = providedNonce;
                return [3, 3];
              case 1:
                return [4, this.getNonce()];
              case 2:
                _d = _e.sent();
                _e.label = 3;
              case 3:
                nonce = _d;
                version = (0, number_1.toBN)(hash_1.feeTransactionVersion);
                signerDetails = {
                  walletAddress: this.address,
                  nonce: (0, number_1.toBN)(nonce),
                  maxFee: constants_1.ZERO,
                  version,
                  chainId: this.chainId
                };
                return [4, this.signer.signTransaction(transactions, signerDetails)];
              case 4:
                signature = _e.sent();
                calldata = (0, transaction_1.fromCallsToExecuteCalldataWithNonce)(transactions, nonce);
                return [4, this.fetchEndpoint("estimate_fee", { blockIdentifier }, {
                  contract_address: this.address,
                  entry_point_selector: (0, hash_1.getSelectorFromName)("__execute__"),
                  calldata,
                  version: (0, number_1.toHex)(version),
                  signature: (0, number_1.bigNumberishArrayToDecimalStringArray)(signature)
                })];
              case 5:
                fetchedEstimate = _e.sent();
                suggestedMaxFee = (0, stark_1.estimatedFeeToMaxFee)(fetchedEstimate.amount);
                return [2, __assign(__assign({}, fetchedEstimate), { suggestedMaxFee })];
            }
          });
        });
      };
      Account2.prototype.execute = function(calls, abis, transactionsDetail) {
        var _a;
        if (abis === void 0) {
          abis = void 0;
        }
        if (transactionsDetail === void 0) {
          transactionsDetail = {};
        }
        return __awaiter(this, void 0, void 0, function() {
          var transactions, nonce, _b, _c, maxFee, suggestedMaxFee, signerDetails, signature, calldata;
          return __generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                transactions = Array.isArray(calls) ? calls : [calls];
                _b = number_1.toBN;
                if (!((_a = transactionsDetail.nonce) !== null && _a !== void 0))
                  return [3, 1];
                _c = _a;
                return [3, 3];
              case 1:
                return [4, this.getNonce()];
              case 2:
                _c = _d.sent();
                _d.label = 3;
              case 3:
                nonce = _b.apply(void 0, [_c]);
                maxFee = "0";
                if (!(transactionsDetail.maxFee || transactionsDetail.maxFee === 0))
                  return [3, 4];
                maxFee = transactionsDetail.maxFee;
                return [3, 6];
              case 4:
                return [4, this.estimateFee(transactions, { nonce })];
              case 5:
                suggestedMaxFee = _d.sent().suggestedMaxFee;
                maxFee = suggestedMaxFee.toString();
                _d.label = 6;
              case 6:
                signerDetails = {
                  walletAddress: this.address,
                  nonce,
                  maxFee,
                  version: (0, number_1.toBN)(hash_1.transactionVersion),
                  chainId: this.chainId
                };
                return [4, this.signer.signTransaction(transactions, signerDetails, abis)];
              case 7:
                signature = _d.sent();
                calldata = (0, transaction_1.fromCallsToExecuteCalldataWithNonce)(transactions, nonce);
                return [2, this.fetchEndpoint("add_transaction", void 0, {
                  type: "INVOKE_FUNCTION",
                  contract_address: this.address,
                  entry_point_selector: (0, hash_1.getSelectorFromName)("__execute__"),
                  calldata,
                  signature: (0, number_1.bigNumberishArrayToDecimalStringArray)(signature),
                  max_fee: (0, number_1.toHex)((0, number_1.toBN)(maxFee))
                })];
            }
          });
        });
      };
      Account2.prototype.LEGACY_addTransaction = function(transaction) {
        return __awaiter(this, void 0, void 0, function() {
          function hashMulticall(account, transactions, nonce, maxFee) {
            var hashArray = transactions.map(function(_a) {
              var contract_address = _a.contract_address, entry_point_selector = _a.entry_point_selector, calldata2 = _a.calldata;
              return [
                contract_address,
                entry_point_selector,
                (0, hash_1.computeHashOnElements)(calldata2 || [])
              ];
            }).map(number_1.bigNumberishArrayToDecimalStringArray).map(hash_1.computeHashOnElements);
            return (0, hash_1.computeHashOnElements)([
              (0, shortString_1.encodeShortString)("StarkNet Transaction"),
              account,
              (0, hash_1.computeHashOnElements)(hashArray),
              nonce,
              maxFee,
              hash_1.transactionVersion
            ]);
          }
          var nonceBn, result, msgHash, signature, transformCallsToMulticallArrays, fromCallsToExecuteCalldata2, calldata;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (transaction.type === "DEPLOY")
                  throw new Error("No DEPLOYS");
                if (transaction.type === "DECLARE")
                  throw new Error("No DECLARES");
                (0, minimalistic_assert_1.default)(!transaction.signature, "Adding signatures to a signer transaction currently isn't supported");
                if (!transaction.nonce)
                  return [3, 1];
                nonceBn = (0, number_1.toBN)(transaction.nonce);
                return [3, 3];
              case 1:
                return [4, this.callContract({
                  contractAddress: this.address,
                  entrypoint: "get_nonce"
                })];
              case 2:
                result = _a.sent().result;
                nonceBn = (0, number_1.toBN)(result[0]);
                _a.label = 3;
              case 3:
                msgHash = hashMulticall(this.address, [transaction], nonceBn.toString(), "0");
                if (!("keyPair" in this.signer)) {
                  throw new Error("No keyPair");
                }
                signature = (0, ellipticCurve_1.sign)(this.signer.keyPair, msgHash);
                transformCallsToMulticallArrays = function(calls) {
                  var callArray = [];
                  var calldata2 = [];
                  calls.forEach(function(call) {
                    var data = call.calldata || [];
                    callArray.push({
                      to: (0, number_1.toBN)(call.contract_address).toString(10),
                      selector: (0, number_1.toBN)(call.entry_point_selector).toString(10),
                      data_offset: calldata2.length.toString(),
                      data_len: data.length.toString()
                    });
                    calldata2.push.apply(calldata2, __spreadArray2([], __read(data), false));
                  });
                  return {
                    callArray,
                    calldata: (0, number_1.bigNumberishArrayToDecimalStringArray)(calldata2)
                  };
                };
                fromCallsToExecuteCalldata2 = function(calls) {
                  var _a2 = transformCallsToMulticallArrays(calls), callArray = _a2.callArray, calldata2 = _a2.calldata;
                  return __spreadArray2(__spreadArray2(__spreadArray2([
                    callArray.length.toString()
                  ], __read(callArray.map(function(_a3) {
                    var to = _a3.to, selector = _a3.selector, data_offset = _a3.data_offset, data_len = _a3.data_len;
                    return [to, selector, data_offset, data_len];
                  }).flat()), false), [
                    calldata2.length.toString()
                  ], false), __read(calldata2), false);
                };
                calldata = __spreadArray2(__spreadArray2([], __read(fromCallsToExecuteCalldata2([transaction])), false), [nonceBn.toString()], false);
                return [2, this.fetchEndpoint("add_transaction", void 0, {
                  type: "INVOKE_FUNCTION",
                  contract_address: this.address,
                  entry_point_selector: (0, hash_1.getSelectorFromName)("__execute__"),
                  calldata,
                  signature: (0, number_1.bigNumberishArrayToDecimalStringArray)(signature)
                })];
            }
          });
        });
      };
      Account2.prototype.signMessage = function(typedData) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, this.signer.signMessage(typedData, this.address)];
          });
        });
      };
      Account2.prototype.hashMessage = function(typedData) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [2, (0, typedData_1.getMessageHash)(typedData, this.address)];
          });
        });
      };
      Account2.prototype.verifyMessageHash = function(hash, signature) {
        return __awaiter(this, void 0, void 0, function() {
          var _a;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                _b.trys.push([0, 2, , 3]);
                return [4, this.callContract({
                  contractAddress: this.address,
                  entrypoint: "is_valid_signature",
                  calldata: (0, stark_1.compileCalldata)({
                    hash: (0, number_1.toBN)(hash).toString(),
                    signature: signature.map(function(x) {
                      return (0, number_1.toBN)(x).toString();
                    })
                  })
                })];
              case 1:
                _b.sent();
                return [2, true];
              case 2:
                _a = _b.sent();
                return [2, false];
              case 3:
                return [2];
            }
          });
        });
      };
      Account2.prototype.verifyMessage = function(typedData, signature) {
        return __awaiter(this, void 0, void 0, function() {
          var hash;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, this.hashMessage(typedData)];
              case 1:
                hash = _a.sent();
                return [2, this.verifyMessageHash(hash, signature)];
            }
          });
        });
      };
      return Account2;
    }(provider_1.Provider);
    exports.Account = Account;
  }
});

// node_modules/starknet/dist/account/interface.js
var require_interface4 = __commonJS({
  "node_modules/starknet/dist/account/interface.js"(exports) {
    "use strict";
    var __extends2 = exports && exports.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccountInterface = void 0;
    var provider_1 = require_provider();
    var AccountInterface = function(_super) {
      __extends2(AccountInterface2, _super);
      function AccountInterface2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return AccountInterface2;
    }(provider_1.ProviderInterface);
    exports.AccountInterface = AccountInterface;
  }
});

// node_modules/starknet/dist/account/index.js
var require_account2 = __commonJS({
  "node_modules/starknet/dist/account/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_default4(), exports);
    __exportStar(require_interface4(), exports);
  }
});

// node_modules/starknet/dist/utils/address.js
var require_address = __commonJS({
  "node_modules/starknet/dist/utils/address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateChecksumAddress = exports.getChecksumAddress = exports.validateAndParseAddress = exports.addAddressPadding = void 0;
    var bytes_1 = (init_lib(), __toCommonJS(lib_exports));
    var constants_1 = require_constants();
    var encode_1 = require_encode();
    var hash_1 = require_hash2();
    var number_1 = require_number();
    function addAddressPadding(address) {
      return (0, encode_1.addHexPrefix)((0, encode_1.removeHexPrefix)((0, number_1.toHex)((0, number_1.toBN)(address))).padStart(64, "0"));
    }
    exports.addAddressPadding = addAddressPadding;
    function validateAndParseAddress(address) {
      (0, number_1.assertInRange)(address, constants_1.ZERO, constants_1.MASK_251, "Starknet Address");
      var result = addAddressPadding(address);
      if (!result.match(/^(0x)?[0-9a-fA-F]{64}$/)) {
        throw new Error("Invalid Address Format");
      }
      return result;
    }
    exports.validateAndParseAddress = validateAndParseAddress;
    function getChecksumAddress(address) {
      var chars = (0, encode_1.removeHexPrefix)(validateAndParseAddress(address)).toLowerCase().split("");
      var hashed = (0, bytes_1.arrayify)((0, hash_1.pedersen)([0, address]), { hexPad: "left" });
      for (var i = 0; i < chars.length; i += 2) {
        if (hashed[i >> 1] >> 4 >= 8) {
          chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 15) >= 8) {
          chars[i + 1] = chars[i + 1].toUpperCase();
        }
      }
      return (0, encode_1.addHexPrefix)(chars.join(""));
    }
    exports.getChecksumAddress = getChecksumAddress;
    function validateChecksumAddress(address) {
      return getChecksumAddress(address) === address;
    }
    exports.validateChecksumAddress = validateChecksumAddress;
  }
});

// node_modules/starknet/dist/index.js
var require_dist = __commonJS({
  "node_modules/starknet/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.typedData = exports.shortString = exports.uint256 = exports.ec = exports.stark = exports.transaction = exports.number = exports.json = exports.hash = exports.encode = exports.constants = void 0;
    __exportStar(require_contract(), exports);
    __exportStar(require_types(), exports);
    __exportStar(require_provider(), exports);
    __exportStar(require_account2(), exports);
    __exportStar(require_signer2(), exports);
    exports.constants = __importStar(require_constants());
    exports.encode = __importStar(require_encode());
    exports.hash = __importStar(require_hash2());
    exports.json = __importStar(require_json());
    exports.number = __importStar(require_number());
    exports.transaction = __importStar(require_transaction());
    exports.stark = __importStar(require_stark());
    exports.ec = __importStar(require_ellipticCurve());
    exports.uint256 = __importStar(require_uint256());
    exports.shortString = __importStar(require_shortString());
    exports.typedData = __importStar(require_typedData());
    __exportStar(require_address(), exports);
  }
});

export {
  require_hash2 as require_hash,
  require_dist
};
//# sourceMappingURL=chunk-3HRWCTJQ.js.map
