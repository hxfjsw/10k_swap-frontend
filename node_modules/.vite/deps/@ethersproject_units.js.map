{
  "version": 3,
  "sources": ["../../@ethersproject/bignumber/src.ts/bignumber.ts", "../../@ethersproject/bignumber/src.ts/_version.ts", "../../@ethersproject/bignumber/src.ts/fixednumber.ts", "../../@ethersproject/units/src.ts/index.ts", "../../@ethersproject/units/src.ts/_version.ts"],
  "sourcesContent": ["\"use strict\";\r\n\r\n/**\r\n *  BigNumber\r\n *\r\n *  A wrapper around the BN.js object. We use the BN.js library\r\n *  because it is used by elliptic, so it is required regardless.\r\n *\r\n */\r\n\r\nimport _BN from \"bn.js\";\r\nimport BN = _BN.BN;\r\n\r\nimport { Bytes, Hexable, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n\r\nconst _constructorGuard = { };\r\n\r\nconst MAX_SAFE = 0x1fffffffffffff;\r\n\r\n\r\nexport type BigNumberish = BigNumber | Bytes | bigint | string | number;\r\n\r\nexport function isBigNumberish(value: any): value is BigNumberish {\r\n    return (value != null) && (\r\n        BigNumber.isBigNumber(value) ||\r\n        (typeof(value) === \"number\" && (value % 1) === 0) ||\r\n        (typeof(value) === \"string\" && !!value.match(/^-?[0-9]+$/)) ||\r\n        isHexString(value) ||\r\n        (typeof(value) === \"bigint\") ||\r\n        isBytes(value)\r\n    );\r\n}\r\n\r\n// Only warn about passing 10 into radix once\r\nlet _warnedToStringRadix = false;\r\n\r\nexport class BigNumber implements Hexable {\r\n    readonly _hex: string;\r\n    readonly _isBigNumber: boolean;\r\n\r\n    constructor(constructorGuard: any, hex: string) {\r\n        if (constructorGuard !== _constructorGuard) {\r\n            logger.throwError(\"cannot call constructor directly; use BigNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                operation: \"new (BigNumber)\"\r\n            });\r\n        }\r\n\r\n        this._hex = hex;\r\n        this._isBigNumber = true;\r\n\r\n        Object.freeze(this);\r\n    }\r\n\r\n    fromTwos(value: number): BigNumber {\r\n        return toBigNumber(toBN(this).fromTwos(value));\r\n    }\r\n\r\n    toTwos(value: number): BigNumber {\r\n        return toBigNumber(toBN(this).toTwos(value));\r\n    }\r\n\r\n    abs(): BigNumber {\r\n        if (this._hex[0] === \"-\") {\r\n            return BigNumber.from(this._hex.substring(1));\r\n        }\r\n        return this;\r\n    }\r\n\r\n    add(other: BigNumberish): BigNumber {\r\n        return toBigNumber(toBN(this).add(toBN(other)));\r\n    }\r\n\r\n    sub(other: BigNumberish): BigNumber {\r\n        return toBigNumber(toBN(this).sub(toBN(other)));\r\n    }\r\n\r\n    div(other: BigNumberish): BigNumber {\r\n        const o = BigNumber.from(other);\r\n        if (o.isZero()) {\r\n            throwFault(\"division-by-zero\", \"div\");\r\n        }\r\n        return toBigNumber(toBN(this).div(toBN(other)));\r\n    }\r\n\r\n    mul(other: BigNumberish): BigNumber {\r\n        return toBigNumber(toBN(this).mul(toBN(other)));\r\n    }\r\n\r\n    mod(other: BigNumberish): BigNumber {\r\n        const value = toBN(other);\r\n        if (value.isNeg()) {\r\n            throwFault(\"division-by-zero\", \"mod\");\r\n        }\r\n        return toBigNumber(toBN(this).umod(value));\r\n    }\r\n\r\n    pow(other: BigNumberish): BigNumber {\r\n        const value = toBN(other);\r\n        if (value.isNeg()) {\r\n            throwFault(\"negative-power\", \"pow\");\r\n        }\r\n        return toBigNumber(toBN(this).pow(value));\r\n    }\r\n\r\n    and(other: BigNumberish): BigNumber {\r\n        const value = toBN(other);\r\n        if (this.isNegative() || value.isNeg()) {\r\n            throwFault(\"unbound-bitwise-result\", \"and\");\r\n        }\r\n        return toBigNumber(toBN(this).and(value));\r\n    }\r\n\r\n    or(other: BigNumberish): BigNumber {\r\n        const value = toBN(other);\r\n        if (this.isNegative() || value.isNeg()) {\r\n            throwFault(\"unbound-bitwise-result\", \"or\");\r\n        }\r\n        return toBigNumber(toBN(this).or(value));\r\n    }\r\n\r\n    xor(other: BigNumberish): BigNumber {\r\n        const value = toBN(other);\r\n        if (this.isNegative() || value.isNeg()) {\r\n            throwFault(\"unbound-bitwise-result\", \"xor\");\r\n        }\r\n        return toBigNumber(toBN(this).xor(value));\r\n    }\r\n\r\n    mask(value: number): BigNumber {\r\n        if (this.isNegative() || value < 0) {\r\n            throwFault(\"negative-width\", \"mask\");\r\n        }\r\n        return toBigNumber(toBN(this).maskn(value));\r\n    }\r\n\r\n    shl(value: number): BigNumber {\r\n        if (this.isNegative() || value < 0) {\r\n            throwFault(\"negative-width\", \"shl\");\r\n        }\r\n        return toBigNumber(toBN(this).shln(value));\r\n    }\r\n\r\n    shr(value: number): BigNumber {\r\n        if (this.isNegative() || value < 0) {\r\n            throwFault(\"negative-width\", \"shr\");\r\n        }\r\n        return toBigNumber(toBN(this).shrn(value));\r\n    }\r\n\r\n    eq(other: BigNumberish): boolean {\r\n        return toBN(this).eq(toBN(other));\r\n    }\r\n\r\n    lt(other: BigNumberish): boolean {\r\n        return toBN(this).lt(toBN(other));\r\n    }\r\n\r\n    lte(other: BigNumberish): boolean {\r\n        return toBN(this).lte(toBN(other));\r\n    }\r\n\r\n    gt(other: BigNumberish): boolean {\r\n        return toBN(this).gt(toBN(other));\r\n   }\r\n\r\n    gte(other: BigNumberish): boolean {\r\n        return toBN(this).gte(toBN(other));\r\n    }\r\n\r\n    isNegative(): boolean {\r\n        return (this._hex[0] === \"-\");\r\n    }\r\n\r\n    isZero(): boolean {\r\n        return toBN(this).isZero();\r\n    }\r\n\r\n    toNumber(): number {\r\n        try {\r\n            return toBN(this).toNumber();\r\n        } catch (error) {\r\n            throwFault(\"overflow\", \"toNumber\", this.toString());\r\n        }\r\n        return null;\r\n    }\r\n\r\n    toBigInt(): bigint {\r\n        try {\r\n            return BigInt(this.toString());\r\n        } catch (e) { }\r\n\r\n        return logger.throwError(\"this platform does not support BigInt\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n            value: this.toString()\r\n        });\r\n    }\r\n\r\n    toString(): string {\r\n        // Lots of people expect this, which we do not support, so check (See: #889)\r\n        if (arguments.length > 0) {\r\n            if (arguments[0] === 10) {\r\n                if (!_warnedToStringRadix) {\r\n                    _warnedToStringRadix = true;\r\n                    logger.warn(\"BigNumber.toString does not accept any parameters; base-10 is assumed\");\r\n                }\r\n            } else if (arguments[0] === 16) {\r\n                logger.throwError(\"BigNumber.toString does not accept any parameters; use bigNumber.toHexString()\", Logger.errors.UNEXPECTED_ARGUMENT, { });\r\n            } else {\r\n                logger.throwError(\"BigNumber.toString does not accept parameters\", Logger.errors.UNEXPECTED_ARGUMENT, { });\r\n            }\r\n        }\r\n        return toBN(this).toString(10);\r\n    }\r\n\r\n    toHexString(): string {\r\n        return this._hex;\r\n    }\r\n\r\n    toJSON(key?: string): any {\r\n        return { type: \"BigNumber\", hex: this.toHexString() };\r\n    }\r\n\r\n    static from(value: any): BigNumber {\r\n        if (value instanceof BigNumber) { return value; }\r\n\r\n        if (typeof(value) === \"string\") {\r\n            if (value.match(/^-?0x[0-9a-f]+$/i)) {\r\n                return new BigNumber(_constructorGuard, toHex(value));\r\n            }\r\n\r\n            if (value.match(/^-?[0-9]+$/)) {\r\n                return new BigNumber(_constructorGuard, toHex(new BN(value)));\r\n            }\r\n\r\n            return logger.throwArgumentError(\"invalid BigNumber string\", \"value\", value);\r\n        }\r\n\r\n        if (typeof(value) === \"number\") {\r\n            if (value % 1) {\r\n                throwFault(\"underflow\", \"BigNumber.from\", value);\r\n            }\r\n\r\n            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\r\n                throwFault(\"overflow\", \"BigNumber.from\", value);\r\n            }\r\n\r\n            return BigNumber.from(String(value));\r\n        }\r\n\r\n        const anyValue = <any>value;\r\n\r\n        if (typeof(anyValue) === \"bigint\") {\r\n            return BigNumber.from(anyValue.toString());\r\n        }\r\n\r\n        if (isBytes(anyValue)) {\r\n            return BigNumber.from(hexlify(anyValue));\r\n        }\r\n\r\n        if (anyValue) {\r\n\r\n            // Hexable interface (takes priority)\r\n            if (anyValue.toHexString) {\r\n                const hex = anyValue.toHexString();\r\n                if (typeof(hex) === \"string\") {\r\n                    return BigNumber.from(hex);\r\n                }\r\n\r\n            } else {\r\n                // For now, handle legacy JSON-ified values (goes away in v6)\r\n                let hex = anyValue._hex;\r\n\r\n                // New-form JSON\r\n                if (hex == null && anyValue.type === \"BigNumber\") {\r\n                    hex = anyValue.hex;\r\n                }\r\n\r\n                if (typeof(hex) === \"string\") {\r\n                    if (isHexString(hex) || (hex[0] === \"-\" && isHexString(hex.substring(1)))) {\r\n                        return BigNumber.from(hex);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return logger.throwArgumentError(\"invalid BigNumber value\", \"value\", value);\r\n    }\r\n\r\n    static isBigNumber(value: any): value is BigNumber {\r\n        return !!(value && value._isBigNumber);\r\n    }\r\n}\r\n\r\n// Normalize the hex string\r\nfunction toHex(value: string | BN): string {\r\n\r\n    // For BN, call on the hex string\r\n    if (typeof(value) !== \"string\") {\r\n        return toHex(value.toString(16));\r\n    }\r\n\r\n    // If negative, prepend the negative sign to the normalized positive value\r\n    if (value[0] === \"-\") {\r\n        // Strip off the negative sign\r\n        value = value.substring(1);\r\n\r\n        // Cannot have multiple negative signs (e.g. \"--0x04\")\r\n        if (value[0] === \"-\") { logger.throwArgumentError(\"invalid hex\", \"value\", value); }\r\n\r\n        // Call toHex on the positive component\r\n        value = toHex(value);\r\n\r\n        // Do not allow \"-0x00\"\r\n        if (value === \"0x00\") { return value; }\r\n\r\n        // Negate the value\r\n        return \"-\" + value;\r\n    }\r\n\r\n    // Add a \"0x\" prefix if missing\r\n    if (value.substring(0, 2) !== \"0x\") { value = \"0x\" + value; }\r\n\r\n    // Normalize zero\r\n    if (value === \"0x\") { return \"0x00\"; }\r\n\r\n    // Make the string even length\r\n    if (value.length % 2) { value = \"0x0\" + value.substring(2); }\r\n\r\n    // Trim to smallest even-length string\r\n    while (value.length > 4 && value.substring(0, 4) === \"0x00\") {\r\n        value = \"0x\" + value.substring(4);\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\nfunction toBigNumber(value: BN): BigNumber {\r\n    return BigNumber.from(toHex(value));\r\n}\r\n\r\nfunction toBN(value: BigNumberish): BN {\r\n    const hex = BigNumber.from(value).toHexString();\r\n    if (hex[0] === \"-\") {\r\n        return (new BN(\"-\" + hex.substring(3), 16));\r\n    }\r\n    return new BN(hex.substring(2), 16);\r\n}\r\n\r\nfunction throwFault(fault: string, operation: string, value?: any): never {\r\n    const params: any = { fault: fault, operation: operation };\r\n    if (value != null) { params.value = value; }\r\n\r\n    return logger.throwError(fault, Logger.errors.NUMERIC_FAULT, params);\r\n}\r\n\r\n// value should have no prefix\r\nexport function _base36To16(value: string): string {\r\n    return (new BN(value, 36)).toString(16);\r\n}\r\n\r\n// value should have no prefix\r\nexport function _base16To36(value: string): string {\r\n    return (new BN(value, 16)).toString(36);\r\n}\r\n", "export const version = \"bignumber/5.7.0\";\r\n", "\"use strict\";\r\n\r\nimport { arrayify, BytesLike, hexZeroPad, isBytes } from \"@ethersproject/bytes\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n\r\nimport { BigNumber, BigNumberish, isBigNumberish } from \"./bignumber\";\r\n\r\nconst _constructorGuard = { };\r\n\r\nconst Zero = BigNumber.from(0);\r\nconst NegativeOne = BigNumber.from(-1);\r\n\r\nfunction throwFault(message: string, fault: string, operation: string, value?: any): never {\r\n    const params: any = { fault: fault, operation: operation };\r\n    if (value !== undefined) { params.value = value; }\r\n    return logger.throwError(message, Logger.errors.NUMERIC_FAULT, params);\r\n}\r\n\r\n// Constant to pull zeros from for multipliers\r\nlet zeros = \"0\";\r\nwhile (zeros.length < 256) { zeros += zeros; }\r\n\r\n// Returns a string \"1\" followed by decimal \"0\"s\r\nfunction getMultiplier(decimals: BigNumberish): string {\r\n\r\n    if (typeof(decimals) !== \"number\") {\r\n        try {\r\n            decimals = BigNumber.from(decimals).toNumber();\r\n        } catch (e) { }\r\n    }\r\n\r\n    if (typeof(decimals) === \"number\" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\r\n        return (\"1\" + zeros.substring(0, decimals));\r\n    }\r\n\r\n    return logger.throwArgumentError(\"invalid decimal size\", \"decimals\", decimals);\r\n}\r\n\r\nexport function formatFixed(value: BigNumberish, decimals?: string | BigNumberish): string {\r\n    if (decimals == null) { decimals = 0; }\r\n    const multiplier = getMultiplier(decimals);\r\n\r\n    // Make sure wei is a big number (convert as necessary)\r\n    value = BigNumber.from(value);\r\n\r\n    const negative = value.lt(Zero);\r\n    if (negative) { value = value.mul(NegativeOne); }\r\n\r\n    let fraction = value.mod(multiplier).toString();\r\n    while (fraction.length < multiplier.length - 1) { fraction = \"0\" + fraction; }\r\n\r\n    // Strip training 0\r\n    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\r\n\r\n    const whole = value.div(multiplier).toString();\r\n    if (multiplier.length === 1) {\r\n        value = whole;\r\n    } else {\r\n        value = whole + \".\" + fraction;\r\n    }\r\n\r\n    if (negative) { value = \"-\" + value; }\r\n\r\n    return value;\r\n}\r\n\r\nexport function parseFixed(value: string, decimals?: BigNumberish): BigNumber {\r\n\r\n    if (decimals == null) { decimals = 0; }\r\n    const multiplier = getMultiplier(decimals);\r\n\r\n    if (typeof(value) !== \"string\" || !value.match(/^-?[0-9.]+$/)) {\r\n        logger.throwArgumentError(\"invalid decimal value\", \"value\", value);\r\n    }\r\n\r\n    // Is it negative?\r\n    const negative = (value.substring(0, 1) === \"-\");\r\n    if (negative) { value = value.substring(1); }\r\n\r\n    if (value === \".\") {\r\n        logger.throwArgumentError(\"missing value\", \"value\", value);\r\n    }\r\n\r\n    // Split it into a whole and fractional part\r\n    const comps = value.split(\".\");\r\n    if (comps.length > 2) {\r\n        logger.throwArgumentError(\"too many decimal points\", \"value\", value);\r\n    }\r\n\r\n    let whole = comps[0], fraction = comps[1];\r\n    if (!whole) { whole = \"0\"; }\r\n    if (!fraction) { fraction = \"0\"; }\r\n\r\n    // Trim trailing zeros\r\n    while (fraction[fraction.length - 1] === \"0\") {\r\n        fraction = fraction.substring(0, fraction.length - 1);\r\n    }\r\n\r\n    // Check the fraction doesn't exceed our decimals size\r\n    if (fraction.length > multiplier.length - 1) {\r\n        throwFault(\"fractional component exceeds decimals\", \"underflow\", \"parseFixed\");\r\n    }\r\n\r\n    // If decimals is 0, we have an empty string for fraction\r\n    if (fraction === \"\") { fraction = \"0\"; }\r\n\r\n    // Fully pad the string with zeros to get to wei\r\n    while (fraction.length < multiplier.length - 1) { fraction += \"0\"; }\r\n\r\n    const wholeValue = BigNumber.from(whole);\r\n    const fractionValue = BigNumber.from(fraction);\r\n\r\n    let wei = (wholeValue.mul(multiplier)).add(fractionValue);\r\n\r\n    if (negative) { wei = wei.mul(NegativeOne); }\r\n\r\n    return wei;\r\n}\r\n\r\n\r\nexport class FixedFormat {\r\n    readonly signed: boolean;\r\n    readonly width: number;\r\n    readonly decimals: number;\r\n    readonly name: string;\r\n    readonly _multiplier: string;\r\n\r\n    constructor(constructorGuard: any, signed: boolean, width: number, decimals: number) {\r\n        if (constructorGuard !== _constructorGuard) {\r\n            logger.throwError(\"cannot use FixedFormat constructor; use FixedFormat.from\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                operation: \"new FixedFormat\"\r\n            });\r\n        }\r\n\r\n        this.signed = signed;\r\n        this.width = width;\r\n        this.decimals = decimals;\r\n\r\n        this.name = (signed ? \"\": \"u\") + \"fixed\" + String(width) + \"x\" + String(decimals);\r\n\r\n        this._multiplier = getMultiplier(decimals);\r\n\r\n        Object.freeze(this);\r\n    }\r\n\r\n    static from(value: any): FixedFormat {\r\n        if (value instanceof FixedFormat) { return value; }\r\n\r\n        if (typeof(value) === \"number\") {\r\n            value = `fixed128x${value}`\r\n        }\r\n\r\n        let signed = true;\r\n        let width = 128;\r\n        let decimals = 18;\r\n\r\n        if (typeof(value) === \"string\") {\r\n            if (value === \"fixed\") {\r\n                // defaults...\r\n            } else if (value === \"ufixed\") {\r\n                signed = false;\r\n            } else {\r\n                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\r\n                if (!match) { logger.throwArgumentError(\"invalid fixed format\", \"format\", value); }\r\n                signed = (match[1] !== \"u\");\r\n                width = parseInt(match[2]);\r\n                decimals = parseInt(match[3]);\r\n            }\r\n        } else if (value) {\r\n            const check = (key: string, type: string, defaultValue: any): any => {\r\n                if (value[key] == null) { return defaultValue; }\r\n                if (typeof(value[key]) !== type) {\r\n                    logger.throwArgumentError(\"invalid fixed format (\" + key + \" not \" + type +\")\", \"format.\" + key, value[key]);\r\n                }\r\n                return value[key];\r\n            }\r\n            signed = check(\"signed\", \"boolean\", signed);\r\n            width = check(\"width\", \"number\", width);\r\n            decimals = check(\"decimals\", \"number\", decimals);\r\n        }\r\n\r\n        if (width % 8) {\r\n            logger.throwArgumentError(\"invalid fixed format width (not byte aligned)\", \"format.width\", width);\r\n        }\r\n\r\n        if (decimals > 80) {\r\n            logger.throwArgumentError(\"invalid fixed format (decimals too large)\", \"format.decimals\", decimals);\r\n        }\r\n\r\n        return new FixedFormat(_constructorGuard, signed, width, decimals);\r\n    }\r\n}\r\n\r\nexport class FixedNumber {\r\n    readonly format: FixedFormat;\r\n    readonly _hex: string;\r\n    readonly _value: string;\r\n\r\n    readonly _isFixedNumber: boolean;\r\n\r\n    constructor(constructorGuard: any, hex: string, value: string, format?: FixedFormat) {\r\n        if (constructorGuard !== _constructorGuard) {\r\n            logger.throwError(\"cannot use FixedNumber constructor; use FixedNumber.from\", Logger.errors.UNSUPPORTED_OPERATION, {\r\n                operation: \"new FixedFormat\"\r\n            });\r\n        }\r\n\r\n        this.format = format;\r\n        this._hex = hex;\r\n        this._value = value;\r\n\r\n        this._isFixedNumber = true;\r\n\r\n        Object.freeze(this);\r\n    }\r\n\r\n    _checkFormat(other: FixedNumber): void {\r\n        if (this.format.name !== other.format.name) {\r\n            logger.throwArgumentError(\"incompatible format; use fixedNumber.toFormat\", \"other\", other);\r\n        }\r\n    }\r\n\r\n    addUnsafe(other: FixedNumber): FixedNumber {\r\n        this._checkFormat(other);\r\n        const a = parseFixed(this._value, this.format.decimals);\r\n        const b = parseFixed(other._value, other.format.decimals);\r\n        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\r\n    }\r\n\r\n    subUnsafe(other: FixedNumber): FixedNumber {\r\n        this._checkFormat(other);\r\n        const a = parseFixed(this._value, this.format.decimals);\r\n        const b = parseFixed(other._value, other.format.decimals);\r\n        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\r\n    }\r\n\r\n    mulUnsafe(other: FixedNumber): FixedNumber {\r\n        this._checkFormat(other);\r\n        const a = parseFixed(this._value, this.format.decimals);\r\n        const b = parseFixed(other._value, other.format.decimals);\r\n        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\r\n    }\r\n\r\n    divUnsafe(other: FixedNumber): FixedNumber {\r\n        this._checkFormat(other);\r\n        const a = parseFixed(this._value, this.format.decimals);\r\n        const b = parseFixed(other._value, other.format.decimals);\r\n        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\r\n    }\r\n\r\n    floor(): FixedNumber {\r\n        const comps = this.toString().split(\".\");\r\n        if (comps.length === 1) { comps.push(\"0\"); }\r\n\r\n        let result = FixedNumber.from(comps[0], this.format);\r\n\r\n        const hasFraction = !comps[1].match(/^(0*)$/);\r\n        if (this.isNegative() && hasFraction) {\r\n            result = result.subUnsafe(ONE.toFormat(result.format));\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    ceiling(): FixedNumber {\r\n        const comps = this.toString().split(\".\");\r\n        if (comps.length === 1) { comps.push(\"0\"); }\r\n\r\n        let result = FixedNumber.from(comps[0], this.format);\r\n\r\n        const hasFraction = !comps[1].match(/^(0*)$/);\r\n        if (!this.isNegative() && hasFraction) {\r\n            result = result.addUnsafe(ONE.toFormat(result.format));\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // @TODO: Support other rounding algorithms\r\n    round(decimals?: number): FixedNumber {\r\n        if (decimals == null) { decimals = 0; }\r\n\r\n        // If we are already in range, we're done\r\n        const comps = this.toString().split(\".\");\r\n        if (comps.length === 1) { comps.push(\"0\"); }\r\n\r\n        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\r\n            logger.throwArgumentError(\"invalid decimal count\", \"decimals\", decimals);\r\n        }\r\n\r\n        if (comps[1].length <= decimals) { return this; }\r\n\r\n        const factor = FixedNumber.from(\"1\" + zeros.substring(0, decimals), this.format);\r\n        const bump = BUMP.toFormat(this.format);\r\n\r\n        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);\r\n    }\r\n\r\n    isZero(): boolean {\r\n        return (this._value === \"0.0\" || this._value === \"0\");\r\n    }\r\n\r\n    isNegative(): boolean {\r\n        return (this._value[0] === \"-\");\r\n    }\r\n\r\n    toString(): string { return this._value; }\r\n\r\n    toHexString(width?: number): string {\r\n        if (width == null) { return this._hex; }\r\n        if (width % 8) { logger.throwArgumentError(\"invalid byte width\", \"width\", width); }\r\n        const hex = BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\r\n        return hexZeroPad(hex, width / 8);\r\n    }\r\n\r\n    toUnsafeFloat(): number { return parseFloat(this.toString()); }\r\n\r\n    toFormat(format: FixedFormat | string): FixedNumber {\r\n        return FixedNumber.fromString(this._value, format);\r\n    }\r\n\r\n\r\n    static fromValue(value: BigNumber, decimals?: BigNumberish, format?: FixedFormat | string | number): FixedNumber {\r\n        // If decimals looks more like a format, and there is no format, shift the parameters\r\n        if (format == null && decimals != null && !isBigNumberish(decimals)) {\r\n            format = decimals;\r\n            decimals = null;\r\n        }\r\n\r\n        if (decimals == null) { decimals = 0; }\r\n        if (format == null) { format = \"fixed\"; }\r\n\r\n        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\r\n    }\r\n\r\n\r\n    static fromString(value: string, format?: FixedFormat | string | number): FixedNumber {\r\n        if (format == null) { format = \"fixed\"; }\r\n\r\n        const fixedFormat = FixedFormat.from(format);\r\n\r\n        const numeric = parseFixed(value, fixedFormat.decimals);\r\n\r\n        if (!fixedFormat.signed && numeric.lt(Zero)) {\r\n            throwFault(\"unsigned value cannot be negative\", \"overflow\", \"value\", value);\r\n        }\r\n\r\n        let hex: string = null;\r\n        if (fixedFormat.signed) {\r\n            hex = numeric.toTwos(fixedFormat.width).toHexString();\r\n        } else {\r\n            hex = numeric.toHexString();\r\n            hex = hexZeroPad(hex, fixedFormat.width / 8);\r\n        }\r\n\r\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\r\n\r\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\r\n    }\r\n\r\n    static fromBytes(value: BytesLike, format?: FixedFormat | string | number): FixedNumber {\r\n        if (format == null) { format = \"fixed\"; }\r\n\r\n        const fixedFormat = FixedFormat.from(format);\r\n\r\n        if (arrayify(value).length > fixedFormat.width / 8) {\r\n            throw new Error(\"overflow\");\r\n        }\r\n\r\n        let numeric = BigNumber.from(value);\r\n        if (fixedFormat.signed) { numeric = numeric.fromTwos(fixedFormat.width); }\r\n\r\n        const hex = numeric.toTwos((fixedFormat.signed ? 0: 1) + fixedFormat.width).toHexString();\r\n        const decimal = formatFixed(numeric, fixedFormat.decimals);\r\n\r\n        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\r\n    }\r\n\r\n    static from(value: any, format?: FixedFormat | string | number) {\r\n        if (typeof(value) === \"string\") {\r\n            return FixedNumber.fromString(value, format);\r\n        }\r\n\r\n        if (isBytes(value)) {\r\n            return FixedNumber.fromBytes(value, format);\r\n        }\r\n\r\n        try {\r\n            return FixedNumber.fromValue(value, 0, format);\r\n        } catch (error) {\r\n            // Allow NUMERIC_FAULT to bubble up\r\n            if (error.code !== Logger.errors.INVALID_ARGUMENT) {\r\n                throw error;\r\n            }\r\n        }\r\n\r\n        return logger.throwArgumentError(\"invalid FixedNumber value\", \"value\", value);\r\n    }\r\n\r\n    static isFixedNumber(value: any): value is FixedNumber {\r\n        return !!(value && value._isFixedNumber);\r\n    }\r\n}\r\n\r\nconst ONE = FixedNumber.from(1);\r\nconst BUMP = FixedNumber.from(\"0.5\");\r\n", "\"use strict\";\r\n\r\nimport { BigNumber, BigNumberish } from \"@ethersproject/bignumber\";\r\nimport { formatFixed, parseFixed } from \"@ethersproject/bignumber\";\r\n\r\nimport { Logger } from \"@ethersproject/logger\";\r\nimport { version } from \"./_version\";\r\nconst logger = new Logger(version);\r\n\r\nconst names = [\r\n    \"wei\",\r\n    \"kwei\",\r\n    \"mwei\",\r\n    \"gwei\",\r\n    \"szabo\",\r\n    \"finney\",\r\n    \"ether\",\r\n];\r\n\r\n\r\n// Some environments have issues with RegEx that contain back-tracking, so we cannot\r\n// use them.\r\nexport function commify(value: string | number): string {\r\n    const comps = String(value).split(\".\");\r\n\r\n    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || (comps[1] && !comps[1].match(/^[0-9]*$/)) || value === \".\" || value === \"-.\") {\r\n        logger.throwArgumentError(\"invalid value\", \"value\", value);\r\n    }\r\n\r\n    // Make sure we have at least one whole digit (0 if none)\r\n    let whole = comps[0];\r\n\r\n    let negative = \"\";\r\n    if (whole.substring(0, 1) === \"-\") {\r\n        negative = \"-\";\r\n        whole = whole.substring(1);\r\n    }\r\n\r\n    // Make sure we have at least 1 whole digit with no leading zeros\r\n    while (whole.substring(0, 1) === \"0\") { whole = whole.substring(1); }\r\n    if (whole === \"\") { whole = \"0\"; }\r\n\r\n    let suffix = \"\";\r\n    if (comps.length === 2) { suffix = \".\" + (comps[1] || \"0\"); }\r\n    while (suffix.length > 2 && suffix[suffix.length - 1] === \"0\") {\r\n        suffix = suffix.substring(0, suffix.length - 1);\r\n    }\r\n\r\n    const formatted = [];\r\n    while (whole.length) {\r\n        if (whole.length <= 3) {\r\n            formatted.unshift(whole);\r\n            break;\r\n        } else {\r\n            const index = whole.length - 3;\r\n            formatted.unshift(whole.substring(index));\r\n            whole = whole.substring(0, index);\r\n        }\r\n    }\r\n\r\n    return negative + formatted.join(\",\") + suffix;\r\n}\r\n\r\nexport function formatUnits(value: BigNumberish, unitName?: string | BigNumberish): string {\r\n    if (typeof(unitName) === \"string\") {\r\n        const index = names.indexOf(unitName);\r\n        if (index !== -1) { unitName = 3 * index; }\r\n    }\r\n    return formatFixed(value, (unitName != null) ? unitName: 18);\r\n}\r\n\r\nexport function parseUnits(value: string, unitName?: BigNumberish): BigNumber {\r\n    if (typeof(value) !== \"string\") {\r\n        logger.throwArgumentError(\"value must be a string\", \"value\", value);\r\n    }\r\n    if (typeof(unitName) === \"string\") {\r\n        const index = names.indexOf(unitName);\r\n        if (index !== -1) { unitName = 3 * index; }\r\n    }\r\n    return parseFixed(value, (unitName != null) ? unitName: 18);\r\n}\r\n\r\nexport function formatEther(wei: BigNumberish): string {\r\n    return formatUnits(wei, 18);\r\n}\r\n\r\nexport function parseEther(ether: string): BigNumber {\r\n    return parseUnits(ether, 18);\r\n}\r\n\r\n", "export const version = \"units/5.7.0\";\r\n"],
  "mappings": "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",
  "names": ["init_lib", "_BN", "init_lib", "logger", "_constructorGuard", "throwFault", "version", "logger", "version"]
}
