import "./chunk-S5KM4IGW.js";

// node_modules/cache-parser/dist/index.mjs
var e = Symbol("cache-parser");
function a(e3) {
  return ("string" == typeof e3 || "number" == typeof e3) && (e3 = Number(e3)) >= 0 && e3 < Infinity;
}
function r(e3) {
  return true === e3 || "number" == typeof e3 || "string" == typeof e3 && "false" !== e3;
}
var t = Number;
function s(s3) {
  var n2 = Object.defineProperty({}, e, { enumerable: false, value: 1 });
  if (!s3 || "string" != typeof s3)
    return n2;
  var i2 = function(e3) {
    var a2 = {}, r5 = e3.toLowerCase().replace(/\s+/g, "").split(",");
    for (var t3 in r5) {
      var s4, n3 = r5[t3].split("=", 2);
      a2[n3[0]] = null == (s4 = n3[1]) || s4;
    }
    return a2;
  }(s3), u2 = i2["max-age"], l2 = i2["max-stale"], o2 = i2["min-fresh"], m2 = i2["s-maxage"], p2 = i2["stale-if-error"], h2 = i2["stale-while-revalidate"];
  return r(i2.immutable) && (n2.immutable = true), a(u2) && (n2.maxAge = t(u2)), a(l2) && (n2.maxStale = t(l2)), a(o2) && (n2.minFresh = t(o2)), r(i2["must-revalidate"]) && (n2.mustRevalidate = true), r(i2["must-understand"]) && (n2.mustUnderstand = true), r(i2["no-cache"]) && (n2.noCache = true), r(i2["no-store"]) && (n2.noStore = true), r(i2["no-transform"]) && (n2.noTransform = true), r(i2["only-if-cached"]) && (n2.onlyIfCached = true), r(i2.private) && (n2.private = true), r(i2["proxy-revalidate"]) && (n2.proxyRevalidate = true), r(i2.public) && (n2.public = true), a(m2) && (n2.sMaxAge = t(m2)), a(p2) && (n2.staleIfError = t(p2)), a(h2) && (n2.staleWhileRevalidate = t(h2)), n2;
}

// node_modules/fast-defer/dist/index.mjs
var r2 = Symbol();
function e2() {
  var e3, n2, o2 = new Promise(function(r5, o3) {
    e3 = r5, n2 = o3;
  });
  return o2.resolve = e3, o2.reject = n2, o2[r2] = 1, o2;
}

// node_modules/object-code/dist/index.mjs
function r3(t3) {
  var n2 = typeof t3;
  if (t3 && "object" === n2 && !(t3 instanceof Date || t3 instanceof RegExp)) {
    for (var e3 = Array.isArray(t3) ? [] : {}, o2 = Object.keys(t3).sort(function(r5, t4) {
      return r5 > t4 ? 1 : -1;
    }), i2 = o2.length; i2--; ) {
      var a2 = o2[i2];
      e3[a2] = r3(t3[a2]);
    }
    return String(t3.constructor) + JSON.stringify(e3, o2);
  }
  return n2 + String(t3);
}
function t2(t3) {
  t3 = r3(t3);
  for (var n2 = 5381, e3 = 0; e3 < t3.length; )
    n2 = 33 * n2 ^ t3.charCodeAt(e3++);
  return n2;
}

// node_modules/axios-cache-interceptor/dist/index.mjs
var r4 = { d: (e3, t3) => {
  for (var a2 in t3)
    r4.o(t3, a2) && !r4.o(e3, a2) && Object.defineProperty(e3, a2, { enumerable: true, get: t3[a2] });
}, o: (e3, t3) => Object.prototype.hasOwnProperty.call(e3, t3) };
var s2 = {};
r4.d(s2, { h4: () => o, UN: () => C, uu: () => S, Kd: () => I, ZF: () => O, nv: () => w, p: () => l, E7: () => d, NQ: () => i, xK: () => A, G6: () => h, LN: () => m, Bw: () => y, Ad: () => u, $k: () => v, v8: () => E, Jk: () => g, tI: () => p, iS: () => f });
var n = ((e3) => {
  var t3 = {};
  return r4.d(t3, e3), t3;
})({ parse: () => s });
var o = Object.freeze({ IfModifiedSince: "if-modified-since", LastModified: "last-modified", IfNoneMatch: "if-none-match", CacheControl: "cache-control", ETag: "etag", Expires: "expires", Age: "age", XAxiosCacheEtag: "x-axios-cache-etag", XAxiosCacheLastModified: "x-axios-cache-last-modified", XAxiosCacheStaleIfError: "x-axios-cache-stale-if-error" });
var i = (e3) => {
  if (!e3)
    return "not enough headers";
  const t3 = e3[o.CacheControl];
  if (t3) {
    const { noCache: a3, noStore: r5, mustRevalidate: s3, maxAge: i2, immutable: c2 } = (0, n.parse)(String(t3));
    if (a3 || r5)
      return "dont cache";
    if (c2)
      return 31536e6;
    if (s3)
      return 0;
    if (void 0 !== i2) {
      const t4 = e3[o.Age];
      return t4 ? 1e3 * (i2 - Number(t4)) : 1e3 * i2;
    }
  }
  const a2 = e3[o.Expires];
  if (a2) {
    const e4 = Date.parse(String(a2)) - Date.now();
    return e4 >= 0 ? e4 : "dont cache";
  }
  return "not enough headers";
};
var c = ((e3) => {
  var t3 = {};
  return r4.d(t3, e3), t3;
})({ deferred: () => e2 });
function d(e3) {
  return e3 ? (t3) => e3(t3) || 304 === t3 : (e4) => e4 >= 200 && e4 < 300 || 304 === e4;
}
function u(e3 = "get", t3 = []) {
  return e3 = e3.toLowerCase(), t3.some((t4) => t4 === e3);
}
function f(e3, t3) {
  var a2;
  t3.headers || (t3.headers = {});
  const { etag: r5, modifiedSince: s3 } = t3.cache;
  if (r5) {
    const s4 = true === r5 ? null === (a2 = e3.data) || void 0 === a2 ? void 0 : a2.headers[o.ETag] : r5;
    s4 && (t3.headers[o.IfNoneMatch] = s4);
  }
  s3 && (t3.headers[o.IfModifiedSince] = true === s3 ? e3.data.headers[o.LastModified] || new Date(e3.createdAt).toUTCString() : s3.toUTCString());
}
function l(e3, t3) {
  return 304 === e3.status && t3 ? (e3.cached = true, e3.data = t3.data, e3.status = t3.status, e3.statusText = t3.statusText, e3.headers = Object.assign(Object.assign({}, t3.headers), e3.headers), t3) : { data: e3.data, status: e3.status, statusText: e3.statusText, headers: e3.headers };
}
function h(e3) {
  const t3 = async (t4) => {
    var a2;
    const r5 = t4.id = e3.generateKey(t4);
    if (false === t4.cache)
      return t4;
    if (t4.cache = Object.assign(Object.assign({}, e3.defaults.cache), t4.cache), !u(t4.method, t4.cache.methods))
      return t4;
    let s3 = await e3.storage.get(r5, t4);
    const n2 = t4.cache.override;
    e:
      if ("empty" === s3.state || "stale" === s3.state || n2) {
        if (e3.waiting[r5] && !n2 && (s3 = await e3.storage.get(r5, t4), "empty" !== s3.state)) {
          0;
          break e;
        }
        return e3.waiting[r5] = (0, c.deferred)(), null === (a2 = e3.waiting[r5]) || void 0 === a2 || a2.catch(() => {
        }), await e3.storage.set(r5, { state: "loading", previous: n2 ? s3.data ? "stale" : "empty" : s3.state, data: s3.data, createdAt: n2 && !s3.createdAt ? Date.now() : s3.createdAt }, t4), "stale" === s3.state && f(s3, t4), t4.validateStatus = d(t4.validateStatus), t4;
      }
    let o2;
    if ("loading" === s3.state) {
      const a3 = e3.waiting[r5];
      if (!a3)
        return await e3.storage.remove(r5, t4), t4;
      0;
      try {
        o2 = await a3;
      } catch (e4) {
        return t4;
      }
    } else
      o2 = s3.data;
    return t4.adapter = () => Promise.resolve({ config: t4, data: o2.data, headers: o2.headers, status: o2.status, statusText: o2.statusText, cached: true, id: r5 }), t4;
  };
  return { onFulfilled: t3, apply: () => e3.interceptors.request.use(t3) };
}
async function g(e3, t3) {
  var a2;
  if ("function" == typeof t3)
    return t3(e3);
  const { statusCheck: r5, responseMatch: s3, containsHeaders: n2 } = t3;
  if (r5 && !await r5(e3.status) || s3 && !await s3(e3))
    return false;
  if (n2) {
    for (const [t4, r6] of Object.entries(n2))
      if (!await r6(null !== (a2 = e3.headers[t4.toLowerCase()]) && void 0 !== a2 ? a2 : e3.headers[t4]))
        return false;
  }
  return true;
}
async function p(e3, t3, a2) {
  if ("function" == typeof a2)
    return a2(t3);
  for (const [r5, s3] of Object.entries(a2)) {
    if ("delete" === s3) {
      await e3.remove(r5, t3.config);
      continue;
    }
    const a3 = await e3.get(r5, t3.config);
    if ("loading" === a3.state)
      continue;
    const n2 = await s3(a3, t3);
    "delete" !== n2 ? "ignore" !== n2 && await e3.set(r5, n2, t3.config) : await e3.remove(r5, t3.config);
  }
}
function m(e3) {
  const t3 = async (t4, a3) => {
    var r6;
    await e3.storage.remove(t4, a3), null === (r6 = e3.waiting[t4]) || void 0 === r6 || r6.reject(), delete e3.waiting[t4];
  }, a2 = async (a3) => {
    var r6, s3, n2;
    const i2 = a3.id = null !== (r6 = (n2 = a3.config).id) && void 0 !== r6 ? r6 : n2.id = e3.generateKey(a3.config);
    if (null !== (s3 = a3.cached) && void 0 !== s3 || (a3.cached = false), a3.cached)
      return a3;
    const c2 = a3.config.cache;
    if (!c2)
      return Object.assign(Object.assign({}, a3), { cached: false });
    const d2 = a3.config, u2 = await e3.storage.get(i2, d2);
    if ((null == c2 ? void 0 : c2.update) && await p(e3.storage, a3, c2.update), "loading" !== u2.state)
      return a3;
    if (!u2.data && !await g(a3, c2.cachePredicate))
      return await t3(i2, d2), a3;
    for (const e4 of Object.keys(a3.headers))
      e4.startsWith("x-axios-cache") && delete a3.headers[e4];
    c2.etag && true !== c2.etag && (a3.headers[o.XAxiosCacheEtag] = c2.etag), c2.modifiedSince && (a3.headers[o.XAxiosCacheLastModified] = true === c2.modifiedSince ? "use-cache-timestamp" : c2.modifiedSince.toUTCString());
    let f2 = c2.ttl || -1;
    if (null == c2 ? void 0 : c2.interpretHeader) {
      const r7 = e3.headerInterpreter(a3.headers);
      if ("dont cache" === r7)
        return await t3(i2, d2), a3;
      f2 = "not enough headers" === r7 ? f2 : r7;
    }
    const h2 = l(a3, u2.data);
    "function" == typeof f2 && (f2 = await f2(a3)), c2.staleIfError && (a3.headers[o.XAxiosCacheStaleIfError] = String(f2));
    const m2 = { state: "cached", ttl: f2, createdAt: Date.now(), data: h2 }, v2 = e3.waiting[i2];
    return v2 && (v2.resolve(m2.data), delete e3.waiting[i2]), await e3.storage.set(i2, m2, d2), a3;
  }, r5 = async (a3) => {
    var r6;
    const s3 = a3.config;
    if (!(null == s3 ? void 0 : s3.cache) || !s3.id)
      throw a3;
    const n2 = await e3.storage.get(s3.id, s3), o2 = s3.cache;
    if ("loading" !== n2.state || "stale" !== n2.previous)
      throw await t3(s3.id, s3), a3;
    if (null == o2 ? void 0 : o2.staleIfError) {
      const t4 = "function" == typeof o2.staleIfError ? await o2.staleIfError(a3.response, n2, a3) : o2.staleIfError;
      if (true === t4 || "number" == typeof t4 && n2.createdAt + t4 > Date.now())
        return null === (r6 = e3.waiting[s3.id]) || void 0 === r6 || r6.resolve(n2.data), delete e3.waiting[s3.id], await e3.storage.set(s3.id, { state: "stale", createdAt: Date.now(), data: n2.data }, s3), { cached: true, config: s3, id: s3.id, data: n2.data.data, headers: n2.data.headers, status: n2.data.status, statusText: n2.data.statusText };
    }
    throw a3;
  };
  return { onFulfilled: a2, onRejected: r5, apply: () => e3.interceptors.response.use(a2, r5) };
}
var v = (e3) => !!e3 && !!e3["is-storage"];
function w(e3) {
  const t3 = e3.data.headers;
  return o.ETag in t3 || o.LastModified in t3 || o.XAxiosCacheEtag in t3 || o.XAxiosCacheStaleIfError in t3 || o.XAxiosCacheLastModified in t3;
}
function y(e3) {
  return e3.createdAt + e3.ttl <= Date.now();
}
function I({ set: e3, find: t3, remove: a2 }) {
  return { "is-storage": 1, set: e3, remove: a2, get: async (r5, s3) => {
    const n2 = await t3(r5, s3);
    if (!n2)
      return { state: "empty" };
    if ("cached" !== n2.state || !y(n2))
      return n2;
    if (w(n2)) {
      const t4 = { state: "stale", createdAt: n2.createdAt, data: n2.data };
      return await e3(r5, t4, s3), t4;
    }
    return await a2(r5, s3), { state: "empty" };
  } };
}
function S(e3 = false) {
  const t3 = I({ set: (e4, a2) => {
    t3.data[e4] = a2;
  }, remove: (e4) => {
    delete t3.data[e4];
  }, find: (a2) => {
    const r5 = t3.data[a2];
    return e3 && void 0 !== r5 ? "function" == typeof structuredClone ? structuredClone(r5) : JSON.parse(JSON.stringify(r5)) : r5;
  } });
  return t3.data = /* @__PURE__ */ Object.create(null), t3;
}
var x = ((e3) => {
  var t3 = {};
  return r4.d(t3, e3), t3;
})({ hash: () => t2 });
var b = /^\/|\/$/g;
function C(e3) {
  return (t3) => {
    if (t3.id)
      return t3.id;
    const a2 = e3(t3);
    return "string" == typeof a2 || "number" == typeof a2 ? `${a2}` : `${(0, x.hash)(a2)}`;
  };
}
var A = C(({ baseURL: e3 = "", url: t3 = "", method: a2 = "get", params: r5, data: s3 }) => (e3 && (e3 = e3.replace(b, "")), t3 && (t3 = t3.replace(b, "")), a2 && (a2 = a2.toLowerCase()), { url: e3 + (e3 && t3 ? "/" : "") + t3, params: r5, method: a2, data: s3 }));
function E(e3, t3 = {}) {
  var a2, r5, s3, n2, o2;
  const c2 = e3;
  if (c2.storage = t3.storage || S(), !v(c2.storage))
    throw new Error("Use buildStorage() function");
  return c2.waiting = t3.waiting || {}, c2.generateKey = t3.generateKey || A, c2.headerInterpreter = t3.headerInterpreter || i, c2.requestInterceptor = t3.requestInterceptor || h(c2), c2.responseInterceptor = t3.responseInterceptor || m(c2), c2.debug = t3.debug, c2.defaults.cache = { update: t3.update || {}, ttl: null !== (a2 = t3.ttl) && void 0 !== a2 ? a2 : 3e5, methods: t3.methods || ["get"], cachePredicate: t3.cachePredicate || { statusCheck: (e4) => e4 >= 200 && e4 < 400 }, etag: null === (r5 = t3.etag) || void 0 === r5 || r5, modifiedSince: null !== (s3 = t3.modifiedSince) && void 0 !== s3 ? s3 : false === t3.etag, interpretHeader: null === (n2 = t3.interpretHeader) || void 0 === n2 || n2, staleIfError: null === (o2 = t3.staleIfError) || void 0 === o2 || o2, override: false }, c2.requestInterceptor.apply(), c2.responseInterceptor.apply(), c2;
}
function O(e3, t3 = "") {
  return I({ find: (a2) => {
    const r5 = e3.getItem(t3 + a2);
    return r5 ? JSON.parse(r5) : void 0;
  }, remove: (a2) => {
    e3.removeItem(t3 + a2);
  }, set: (a2, r5) => {
    const s3 = () => e3.setItem(t3 + a2, JSON.stringify(r5));
    try {
      return s3();
    } catch (r6) {
      const n2 = Object.entries(e3).filter((e4) => e4[0].startsWith(t3)).map((e4) => [e4[0], JSON.parse(e4[1])]);
      for (const t4 of n2)
        "cached" === t4[1].state && y(t4[1]) && !w(t4[1]) && e3.removeItem(t4[0]);
      try {
        return s3();
      } catch (t4) {
        const a3 = n2.sort((e4, t5) => (e4[1].createdAt || 0) - (t5[1].createdAt || 0));
        for (const t5 of a3) {
          e3.removeItem(t5[0]);
          try {
            return s3();
          } catch (e4) {
          }
        }
      }
      e3.removeItem(t3 + a2);
    }
  } });
}
var j = s2.h4;
var N = s2.UN;
var T = s2.uu;
var M = s2.Kd;
var L = s2.ZF;
var K = s2.nv;
var X = s2.p;
var k = s2.E7;
var D = s2.NQ;
var J = s2.xK;
var P = s2.G6;
var R = s2.LN;
var U = s2.Bw;
var q = s2.Ad;
var H = s2.$k;
var $ = s2.v8;
var F = s2.Jk;
var G = s2.tI;
var W = s2.iS;
export {
  j as Header,
  N as buildKeyGenerator,
  T as buildMemoryStorage,
  M as buildStorage,
  L as buildWebStorage,
  K as canStale,
  X as createCacheResponse,
  k as createValidateStatus,
  D as defaultHeaderInterpreter,
  J as defaultKeyGenerator,
  P as defaultRequestInterceptor,
  R as defaultResponseInterceptor,
  U as isExpired,
  q as isMethodIn,
  H as isStorage,
  $ as setupCache,
  F as testCachePredicate,
  G as updateCache,
  W as updateStaleRequest
};
//# sourceMappingURL=axios-cache-interceptor.js.map
