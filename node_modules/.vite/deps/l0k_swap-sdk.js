import {
  require_address,
  require_constants
} from "./chunk-4H7BGTSO.js";
import {
  require_encode,
  require_number
} from "./chunk-5NQHIPE4.js";
import {
  require_dist,
  require_hash
} from "./chunk-UCQ7FGQU.js";
import {
  require_uint256
} from "./chunk-2DAOTV7T.js";
import "./chunk-XJGV4GQE.js";
import "./chunk-KSVBIC6C.js";
import "./chunk-77IFFSE7.js";
import "./chunk-Q5BQ6LHN.js";
import {
  __commonJS
} from "./chunk-S5KM4IGW.js";

// node_modules/jsbi/dist/jsbi-umd.js
var require_jsbi_umd = __commonJS({
  "node_modules/jsbi/dist/jsbi-umd.js"(exports, module) {
    (function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = e || self, e.JSBI = t());
    })(exports, function() {
      "use strict";
      var e = Math.imul, t = Math.clz32;
      function i(e2) {
        "@babel/helpers - typeof";
        return i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
          return typeof e3;
        } : function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        }, i(e2);
      }
      function _(e2, t2) {
        if (!(e2 instanceof t2))
          throw new TypeError("Cannot call a class as a function");
      }
      function n(e2, t2) {
        for (var _2, n2 = 0; n2 < t2.length; n2++)
          _2 = t2[n2], _2.enumerable = _2.enumerable || false, _2.configurable = true, "value" in _2 && (_2.writable = true), Object.defineProperty(e2, _2.key, _2);
      }
      function l(e2, t2, i2) {
        return t2 && n(e2.prototype, t2), i2 && n(e2, i2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
      }
      function g(e2, t2) {
        if ("function" != typeof t2 && null !== t2)
          throw new TypeError("Super expression must either be null or a function");
        e2.prototype = Object.create(t2 && t2.prototype, { constructor: { value: e2, writable: true, configurable: true } }), Object.defineProperty(e2, "prototype", { writable: false }), t2 && u(e2, t2);
      }
      function a(e2) {
        return a = Object.setPrototypeOf ? Object.getPrototypeOf : function(e3) {
          return e3.__proto__ || Object.getPrototypeOf(e3);
        }, a(e2);
      }
      function u(e2, t2) {
        return u = Object.setPrototypeOf || function(e3, t3) {
          return e3.__proto__ = t3, e3;
        }, u(e2, t2);
      }
      function s() {
        if ("undefined" == typeof Reflect || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if ("function" == typeof Proxy)
          return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), true;
        } catch (t2) {
          return false;
        }
      }
      function r() {
        return r = s() ? Reflect.construct : function(e2, t2, i2) {
          var _2 = [null];
          _2.push.apply(_2, t2);
          var n2 = Function.bind.apply(e2, _2), l2 = new n2();
          return i2 && u(l2, i2.prototype), l2;
        }, r.apply(null, arguments);
      }
      function d(e2) {
        return -1 !== Function.toString.call(e2).indexOf("[native code]");
      }
      function h(e2) {
        var t2 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
        return h = function(e3) {
          function i2() {
            return r(e3, arguments, a(this).constructor);
          }
          if (null === e3 || !d(e3))
            return e3;
          if ("function" != typeof e3)
            throw new TypeError("Super expression must either be null or a function");
          if ("undefined" != typeof t2) {
            if (t2.has(e3))
              return t2.get(e3);
            t2.set(e3, i2);
          }
          return i2.prototype = Object.create(e3.prototype, { constructor: { value: i2, enumerable: false, writable: true, configurable: true } }), u(i2, e3);
        }, h(e2);
      }
      function b(e2) {
        if (void 0 === e2)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e2;
      }
      function m(e2, t2) {
        if (t2 && ("object" == typeof t2 || "function" == typeof t2))
          return t2;
        if (void 0 !== t2)
          throw new TypeError("Derived constructors may only return object or undefined");
        return b(e2);
      }
      function c(e2) {
        var t2 = s();
        return function() {
          var i2, _2 = a(e2);
          if (t2) {
            var n2 = a(this).constructor;
            i2 = Reflect.construct(_2, arguments, n2);
          } else
            i2 = _2.apply(this, arguments);
          return m(this, i2);
        };
      }
      function v(e2, t2) {
        return y(e2) || f(e2, t2) || D(e2, t2) || k();
      }
      function y(e2) {
        if (Array.isArray(e2))
          return e2;
      }
      function f(e2, t2) {
        var i2 = null == e2 ? null : "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
        if (null != i2) {
          var _2, n2, l2 = [], g2 = true, o = false;
          try {
            for (i2 = i2.call(e2); !(g2 = (_2 = i2.next()).done) && (l2.push(_2.value), !(t2 && l2.length === t2)); g2 = true)
              ;
          } catch (e3) {
            o = true, n2 = e3;
          } finally {
            try {
              g2 || null == i2["return"] || i2["return"]();
            } finally {
              if (o)
                throw n2;
            }
          }
          return l2;
        }
      }
      function D(e2, t2) {
        if (e2) {
          if ("string" == typeof e2)
            return p(e2, t2);
          var i2 = Object.prototype.toString.call(e2).slice(8, -1);
          return "Object" === i2 && e2.constructor && (i2 = e2.constructor.name), "Map" === i2 || "Set" === i2 ? Array.from(e2) : "Arguments" === i2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i2) ? p(e2, t2) : void 0;
        }
      }
      function p(e2, t2) {
        (null == t2 || t2 > e2.length) && (t2 = e2.length);
        for (var _2 = 0, n2 = Array(t2); _2 < t2; _2++)
          n2[_2] = e2[_2];
        return n2;
      }
      function k() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function B(e2, t2) {
        var _2 = "undefined" != typeof Symbol && e2[Symbol.iterator] || e2["@@iterator"];
        if (!_2) {
          if (Array.isArray(e2) || (_2 = D(e2)) || t2 && e2 && "number" == typeof e2.length) {
            _2 && (e2 = _2);
            var n2 = 0, l2 = function() {
            };
            return { s: l2, n: function() {
              return n2 >= e2.length ? { done: true } : { done: false, value: e2[n2++] };
            }, e: function(t3) {
              throw t3;
            }, f: l2 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var g2, a2 = true, u2 = false;
        return { s: function() {
          _2 = _2.call(e2);
        }, n: function() {
          var e3 = _2.next();
          return a2 = e3.done, e3;
        }, e: function(t3) {
          u2 = true, g2 = t3;
        }, f: function() {
          try {
            a2 || null == _2.return || _2.return();
          } finally {
            if (u2)
              throw g2;
          }
        } };
      }
      var S = function(e2) {
        var t2 = Math.abs, n2 = Math.max, o = Math.floor;
        function a2(e3, t3) {
          var i2;
          if (_(this, a2), i2 = u2.call(this, e3), i2.sign = t3, Object.setPrototypeOf(b(i2), a2.prototype), e3 > a2.__kMaxLength)
            throw new RangeError("Maximum BigInt size exceeded");
          return i2;
        }
        g(a2, e2);
        var u2 = c(a2);
        return l(a2, [{ key: "toDebugString", value: function() {
          var e3, t3 = ["BigInt["], i2 = B(this);
          try {
            for (i2.s(); !(e3 = i2.n()).done; ) {
              var _2 = e3.value;
              t3.push((_2 ? (_2 >>> 0).toString(16) : _2) + ", ");
            }
          } catch (e4) {
            i2.e(e4);
          } finally {
            i2.f();
          }
          return t3.push("]"), t3.join("");
        } }, { key: "toString", value: function() {
          var e3 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 10;
          if (2 > e3 || 36 < e3)
            throw new RangeError("toString() radix argument must be between 2 and 36");
          return 0 === this.length ? "0" : 0 == (e3 & e3 - 1) ? a2.__toStringBasePowerOfTwo(this, e3) : a2.__toStringGeneric(this, e3, false);
        } }, { key: "valueOf", value: function() {
          throw new Error("Convert JSBI instances to native numbers using `toNumber`.");
        } }, { key: "__copy", value: function() {
          for (var e3 = new a2(this.length, this.sign), t3 = 0; t3 < this.length; t3++)
            e3[t3] = this[t3];
          return e3;
        } }, { key: "__trim", value: function() {
          for (var e3 = this.length, t3 = this[e3 - 1]; 0 === t3; )
            e3--, t3 = this[e3 - 1], this.pop();
          return 0 === e3 && (this.sign = false), this;
        } }, { key: "__initializeDigits", value: function() {
          for (var e3 = 0; e3 < this.length; e3++)
            this[e3] = 0;
        } }, { key: "__clzmsd", value: function() {
          return a2.__clz30(this.__digit(this.length - 1));
        } }, { key: "__inplaceMultiplyAdd", value: function(e3, t3, _2) {
          _2 > this.length && (_2 = this.length);
          for (var n3 = 32767 & e3, l2 = e3 >>> 15, g2 = 0, o2 = t3, u3 = 0; u3 < _2; u3++) {
            var s2 = this.__digit(u3), r2 = 32767 & s2, d2 = s2 >>> 15, h2 = a2.__imul(r2, n3), b2 = a2.__imul(r2, l2), m2 = a2.__imul(d2, n3), c2 = a2.__imul(d2, l2), v2 = o2 + h2 + g2;
            g2 = v2 >>> 30, v2 &= 1073741823, v2 += ((32767 & b2) << 15) + ((32767 & m2) << 15), g2 += v2 >>> 30, o2 = c2 + (b2 >>> 15) + (m2 >>> 15), this.__setDigit(u3, 1073741823 & v2);
          }
          if (0 !== g2 || 0 !== o2)
            throw new Error("implementation bug");
        } }, { key: "__inplaceAdd", value: function(e3, t3, _2) {
          for (var n3, l2 = 0, g2 = 0; g2 < _2; g2++)
            n3 = this.__halfDigit(t3 + g2) + e3.__halfDigit(g2) + l2, l2 = n3 >>> 15, this.__setHalfDigit(t3 + g2, 32767 & n3);
          return l2;
        } }, { key: "__inplaceSub", value: function(e3, t3, _2) {
          var n3 = 0;
          if (1 & t3) {
            t3 >>= 1;
            for (var l2 = this.__digit(t3), g2 = 32767 & l2, o2 = 0; o2 < _2 - 1 >>> 1; o2++) {
              var a3 = e3.__digit(o2), u3 = (l2 >>> 15) - (32767 & a3) - n3;
              n3 = 1 & u3 >>> 15, this.__setDigit(t3 + o2, (32767 & u3) << 15 | 32767 & g2), l2 = this.__digit(t3 + o2 + 1), g2 = (32767 & l2) - (a3 >>> 15) - n3, n3 = 1 & g2 >>> 15;
            }
            var s2 = e3.__digit(o2), r2 = (l2 >>> 15) - (32767 & s2) - n3;
            n3 = 1 & r2 >>> 15, this.__setDigit(t3 + o2, (32767 & r2) << 15 | 32767 & g2);
            if (t3 + o2 + 1 >= this.length)
              throw new RangeError("out of bounds");
            0 == (1 & _2) && (l2 = this.__digit(t3 + o2 + 1), g2 = (32767 & l2) - (s2 >>> 15) - n3, n3 = 1 & g2 >>> 15, this.__setDigit(t3 + e3.length, 1073709056 & l2 | 32767 & g2));
          } else {
            t3 >>= 1;
            for (var d2 = 0; d2 < e3.length - 1; d2++) {
              var h2 = this.__digit(t3 + d2), b2 = e3.__digit(d2), m2 = (32767 & h2) - (32767 & b2) - n3;
              n3 = 1 & m2 >>> 15;
              var c2 = (h2 >>> 15) - (b2 >>> 15) - n3;
              n3 = 1 & c2 >>> 15, this.__setDigit(t3 + d2, (32767 & c2) << 15 | 32767 & m2);
            }
            var v2 = this.__digit(t3 + d2), y2 = e3.__digit(d2), f2 = (32767 & v2) - (32767 & y2) - n3;
            n3 = 1 & f2 >>> 15;
            var D2 = 0;
            0 == (1 & _2) && (D2 = (v2 >>> 15) - (y2 >>> 15) - n3, n3 = 1 & D2 >>> 15), this.__setDigit(t3 + d2, (32767 & D2) << 15 | 32767 & f2);
          }
          return n3;
        } }, { key: "__inplaceRightShift", value: function(e3) {
          if (0 !== e3) {
            for (var t3, _2 = this.__digit(0) >>> e3, n3 = this.length - 1, l2 = 0; l2 < n3; l2++)
              t3 = this.__digit(l2 + 1), this.__setDigit(l2, 1073741823 & t3 << 30 - e3 | _2), _2 = t3 >>> e3;
            this.__setDigit(n3, _2);
          }
        } }, { key: "__digit", value: function(e3) {
          return this[e3];
        } }, { key: "__unsignedDigit", value: function(e3) {
          return this[e3] >>> 0;
        } }, { key: "__setDigit", value: function(e3, t3) {
          this[e3] = 0 | t3;
        } }, { key: "__setDigitGrow", value: function(e3, t3) {
          this[e3] = 0 | t3;
        } }, { key: "__halfDigitLength", value: function() {
          var e3 = this.length;
          return 32767 >= this.__unsignedDigit(e3 - 1) ? 2 * e3 - 1 : 2 * e3;
        } }, { key: "__halfDigit", value: function(e3) {
          return 32767 & this[e3 >>> 1] >>> 15 * (1 & e3);
        } }, { key: "__setHalfDigit", value: function(e3, t3) {
          var i2 = e3 >>> 1, _2 = this.__digit(i2), n3 = 1 & e3 ? 32767 & _2 | t3 << 15 : 1073709056 & _2 | 32767 & t3;
          this.__setDigit(i2, n3);
        } }], [{ key: "BigInt", value: function(e3) {
          var t3 = Number.isFinite;
          if ("number" == typeof e3) {
            if (0 === e3)
              return a2.__zero();
            if (a2.__isOneDigitInt(e3))
              return 0 > e3 ? a2.__oneDigit(-e3, true) : a2.__oneDigit(e3, false);
            if (!t3(e3) || o(e3) !== e3)
              throw new RangeError("The number " + e3 + " cannot be converted to BigInt because it is not an integer");
            return a2.__fromDouble(e3);
          }
          if ("string" == typeof e3) {
            var _2 = a2.__fromString(e3);
            if (null === _2)
              throw new SyntaxError("Cannot convert " + e3 + " to a BigInt");
            return _2;
          }
          if ("boolean" == typeof e3)
            return true === e3 ? a2.__oneDigit(1, false) : a2.__zero();
          if ("object" === i(e3)) {
            if (e3.constructor === a2)
              return e3;
            var n3 = a2.__toPrimitive(e3);
            return a2.BigInt(n3);
          }
          throw new TypeError("Cannot convert " + e3 + " to a BigInt");
        } }, { key: "toNumber", value: function(e3) {
          var t3 = e3.length;
          if (0 === t3)
            return 0;
          if (1 === t3) {
            var i2 = e3.__unsignedDigit(0);
            return e3.sign ? -i2 : i2;
          }
          var _2 = e3.__digit(t3 - 1), n3 = a2.__clz30(_2), l2 = 30 * t3 - n3;
          if (1024 < l2)
            return e3.sign ? -Infinity : 1 / 0;
          var g2 = l2 - 1, o2 = _2, u3 = t3 - 1, s2 = n3 + 3, r2 = 32 === s2 ? 0 : o2 << s2;
          r2 >>>= 12;
          var d2 = s2 - 12, h2 = 12 <= s2 ? 0 : o2 << 20 + s2, b2 = 20 + s2;
          for (0 < d2 && 0 < u3 && (u3--, o2 = e3.__digit(u3), r2 |= o2 >>> 30 - d2, h2 = o2 << d2 + 2, b2 = d2 + 2); 0 < b2 && 0 < u3; )
            u3--, o2 = e3.__digit(u3), h2 |= 30 <= b2 ? o2 << b2 - 30 : o2 >>> 30 - b2, b2 -= 30;
          var m2 = a2.__decideRounding(e3, b2, u3, o2);
          if ((1 === m2 || 0 === m2 && 1 == (1 & h2)) && (h2 = h2 + 1 >>> 0, 0 === h2 && (r2++, 0 != r2 >>> 20 && (r2 = 0, g2++, 1023 < g2))))
            return e3.sign ? -Infinity : 1 / 0;
          var c2 = e3.sign ? -2147483648 : 0;
          return g2 = g2 + 1023 << 20, a2.__kBitConversionInts[1] = c2 | g2 | r2, a2.__kBitConversionInts[0] = h2, a2.__kBitConversionDouble[0];
        } }, { key: "unaryMinus", value: function(e3) {
          if (0 === e3.length)
            return e3;
          var t3 = e3.__copy();
          return t3.sign = !e3.sign, t3;
        } }, { key: "bitwiseNot", value: function(e3) {
          return e3.sign ? a2.__absoluteSubOne(e3).__trim() : a2.__absoluteAddOne(e3, true);
        } }, { key: "exponentiate", value: function(e3, t3) {
          if (t3.sign)
            throw new RangeError("Exponent must be positive");
          if (0 === t3.length)
            return a2.__oneDigit(1, false);
          if (0 === e3.length)
            return e3;
          if (1 === e3.length && 1 === e3.__digit(0))
            return e3.sign && 0 == (1 & t3.__digit(0)) ? a2.unaryMinus(e3) : e3;
          if (1 < t3.length)
            throw new RangeError("BigInt too big");
          var i2 = t3.__unsignedDigit(0);
          if (1 === i2)
            return e3;
          if (i2 >= a2.__kMaxLengthBits)
            throw new RangeError("BigInt too big");
          if (1 === e3.length && 2 === e3.__digit(0)) {
            var _2 = 1 + (0 | i2 / 30), n3 = e3.sign && 0 != (1 & i2), l2 = new a2(_2, n3);
            l2.__initializeDigits();
            var g2 = 1 << i2 % 30;
            return l2.__setDigit(_2 - 1, g2), l2;
          }
          var o2 = null, u3 = e3;
          for (0 != (1 & i2) && (o2 = e3), i2 >>= 1; 0 !== i2; i2 >>= 1)
            u3 = a2.multiply(u3, u3), 0 != (1 & i2) && (null === o2 ? o2 = u3 : o2 = a2.multiply(o2, u3));
          return o2;
        } }, { key: "multiply", value: function(e3, t3) {
          if (0 === e3.length)
            return e3;
          if (0 === t3.length)
            return t3;
          var _2 = e3.length + t3.length;
          30 <= e3.__clzmsd() + t3.__clzmsd() && _2--;
          var n3 = new a2(_2, e3.sign !== t3.sign);
          n3.__initializeDigits();
          for (var l2 = 0; l2 < e3.length; l2++)
            a2.__multiplyAccumulate(t3, e3.__digit(l2), n3, l2);
          return n3.__trim();
        } }, { key: "divide", value: function(e3, t3) {
          if (0 === t3.length)
            throw new RangeError("Division by zero");
          if (0 > a2.__absoluteCompare(e3, t3))
            return a2.__zero();
          var i2, _2 = e3.sign !== t3.sign, n3 = t3.__unsignedDigit(0);
          if (1 === t3.length && 32767 >= n3) {
            if (1 === n3)
              return _2 === e3.sign ? e3 : a2.unaryMinus(e3);
            i2 = a2.__absoluteDivSmall(e3, n3, null);
          } else
            i2 = a2.__absoluteDivLarge(e3, t3, true, false);
          return i2.sign = _2, i2.__trim();
        } }, { key: "remainder", value: function i2(e3, t3) {
          if (0 === t3.length)
            throw new RangeError("Division by zero");
          if (0 > a2.__absoluteCompare(e3, t3))
            return e3;
          var _2 = t3.__unsignedDigit(0);
          if (1 === t3.length && 32767 >= _2) {
            if (1 === _2)
              return a2.__zero();
            var n3 = a2.__absoluteModSmall(e3, _2);
            return 0 === n3 ? a2.__zero() : a2.__oneDigit(n3, e3.sign);
          }
          var i3 = a2.__absoluteDivLarge(e3, t3, false, true);
          return i3.sign = e3.sign, i3.__trim();
        } }, { key: "add", value: function(e3, t3) {
          var i2 = e3.sign;
          return i2 === t3.sign ? a2.__absoluteAdd(e3, t3, i2) : 0 <= a2.__absoluteCompare(e3, t3) ? a2.__absoluteSub(e3, t3, i2) : a2.__absoluteSub(t3, e3, !i2);
        } }, { key: "subtract", value: function(e3, t3) {
          var i2 = e3.sign;
          return i2 === t3.sign ? 0 <= a2.__absoluteCompare(e3, t3) ? a2.__absoluteSub(e3, t3, i2) : a2.__absoluteSub(t3, e3, !i2) : a2.__absoluteAdd(e3, t3, i2);
        } }, { key: "leftShift", value: function(e3, t3) {
          return 0 === t3.length || 0 === e3.length ? e3 : t3.sign ? a2.__rightShiftByAbsolute(e3, t3) : a2.__leftShiftByAbsolute(e3, t3);
        } }, { key: "signedRightShift", value: function(e3, t3) {
          return 0 === t3.length || 0 === e3.length ? e3 : t3.sign ? a2.__leftShiftByAbsolute(e3, t3) : a2.__rightShiftByAbsolute(e3, t3);
        } }, { key: "unsignedRightShift", value: function() {
          throw new TypeError("BigInts have no unsigned right shift; use >> instead");
        } }, { key: "lessThan", value: function(e3, t3) {
          return 0 > a2.__compareToBigInt(e3, t3);
        } }, { key: "lessThanOrEqual", value: function(e3, t3) {
          return 0 >= a2.__compareToBigInt(e3, t3);
        } }, { key: "greaterThan", value: function(e3, t3) {
          return 0 < a2.__compareToBigInt(e3, t3);
        } }, { key: "greaterThanOrEqual", value: function(e3, t3) {
          return 0 <= a2.__compareToBigInt(e3, t3);
        } }, { key: "equal", value: function(e3, t3) {
          if (e3.sign !== t3.sign)
            return false;
          if (e3.length !== t3.length)
            return false;
          for (var _2 = 0; _2 < e3.length; _2++)
            if (e3.__digit(_2) !== t3.__digit(_2))
              return false;
          return true;
        } }, { key: "notEqual", value: function(e3, t3) {
          return !a2.equal(e3, t3);
        } }, { key: "bitwiseAnd", value: function(e3, t3) {
          if (!e3.sign && !t3.sign)
            return a2.__absoluteAnd(e3, t3).__trim();
          if (e3.sign && t3.sign) {
            var i2 = n2(e3.length, t3.length) + 1, _2 = a2.__absoluteSubOne(e3, i2), l2 = a2.__absoluteSubOne(t3);
            return _2 = a2.__absoluteOr(_2, l2, _2), a2.__absoluteAddOne(_2, true, _2).__trim();
          }
          if (e3.sign) {
            var g2 = [t3, e3];
            e3 = g2[0], t3 = g2[1];
          }
          return a2.__absoluteAndNot(e3, a2.__absoluteSubOne(t3)).__trim();
        } }, { key: "bitwiseXor", value: function(e3, t3) {
          if (!e3.sign && !t3.sign)
            return a2.__absoluteXor(e3, t3).__trim();
          if (e3.sign && t3.sign) {
            var i2 = n2(e3.length, t3.length), _2 = a2.__absoluteSubOne(e3, i2), l2 = a2.__absoluteSubOne(t3);
            return a2.__absoluteXor(_2, l2, _2).__trim();
          }
          var g2 = n2(e3.length, t3.length) + 1;
          if (e3.sign) {
            var o2 = [t3, e3];
            e3 = o2[0], t3 = o2[1];
          }
          var u3 = a2.__absoluteSubOne(t3, g2);
          return u3 = a2.__absoluteXor(u3, e3, u3), a2.__absoluteAddOne(u3, true, u3).__trim();
        } }, { key: "bitwiseOr", value: function(e3, t3) {
          var i2 = n2(e3.length, t3.length);
          if (!e3.sign && !t3.sign)
            return a2.__absoluteOr(e3, t3).__trim();
          if (e3.sign && t3.sign) {
            var _2 = a2.__absoluteSubOne(e3, i2), l2 = a2.__absoluteSubOne(t3);
            return _2 = a2.__absoluteAnd(_2, l2, _2), a2.__absoluteAddOne(_2, true, _2).__trim();
          }
          if (e3.sign) {
            var g2 = [t3, e3];
            e3 = g2[0], t3 = g2[1];
          }
          var o2 = a2.__absoluteSubOne(t3, i2);
          return o2 = a2.__absoluteAndNot(o2, e3, o2), a2.__absoluteAddOne(o2, true, o2).__trim();
        } }, { key: "asIntN", value: function(e3, t3) {
          if (0 === t3.length)
            return t3;
          if (e3 = o(e3), 0 > e3)
            throw new RangeError("Invalid value: not (convertible to) a safe integer");
          if (0 === e3)
            return a2.__zero();
          if (e3 >= a2.__kMaxLengthBits)
            return t3;
          var _2 = 0 | (e3 + 29) / 30;
          if (t3.length < _2)
            return t3;
          var l2 = t3.__unsignedDigit(_2 - 1), g2 = 1 << (e3 - 1) % 30;
          if (t3.length === _2 && l2 < g2)
            return t3;
          if (!((l2 & g2) === g2))
            return a2.__truncateToNBits(e3, t3);
          if (!t3.sign)
            return a2.__truncateAndSubFromPowerOfTwo(e3, t3, true);
          if (0 == (l2 & g2 - 1)) {
            for (var u3 = _2 - 2; 0 <= u3; u3--)
              if (0 !== t3.__digit(u3))
                return a2.__truncateAndSubFromPowerOfTwo(e3, t3, false);
            return t3.length === _2 && l2 === g2 ? t3 : a2.__truncateToNBits(e3, t3);
          }
          return a2.__truncateAndSubFromPowerOfTwo(e3, t3, false);
        } }, { key: "asUintN", value: function(e3, t3) {
          if (0 === t3.length)
            return t3;
          if (e3 = o(e3), 0 > e3)
            throw new RangeError("Invalid value: not (convertible to) a safe integer");
          if (0 === e3)
            return a2.__zero();
          if (t3.sign) {
            if (e3 > a2.__kMaxLengthBits)
              throw new RangeError("BigInt too big");
            return a2.__truncateAndSubFromPowerOfTwo(e3, t3, false);
          }
          if (e3 >= a2.__kMaxLengthBits)
            return t3;
          var i2 = 0 | (e3 + 29) / 30;
          if (t3.length < i2)
            return t3;
          var _2 = e3 % 30;
          if (t3.length == i2) {
            if (0 === _2)
              return t3;
            var l2 = t3.__digit(i2 - 1);
            if (0 == l2 >>> _2)
              return t3;
          }
          return a2.__truncateToNBits(e3, t3);
        } }, { key: "ADD", value: function(e3, t3) {
          if (e3 = a2.__toPrimitive(e3), t3 = a2.__toPrimitive(t3), "string" == typeof e3)
            return "string" != typeof t3 && (t3 = t3.toString()), e3 + t3;
          if ("string" == typeof t3)
            return e3.toString() + t3;
          if (e3 = a2.__toNumeric(e3), t3 = a2.__toNumeric(t3), a2.__isBigInt(e3) && a2.__isBigInt(t3))
            return a2.add(e3, t3);
          if ("number" == typeof e3 && "number" == typeof t3)
            return e3 + t3;
          throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
        } }, { key: "LT", value: function(e3, t3) {
          return a2.__compare(e3, t3, 0);
        } }, { key: "LE", value: function(e3, t3) {
          return a2.__compare(e3, t3, 1);
        } }, { key: "GT", value: function(e3, t3) {
          return a2.__compare(e3, t3, 2);
        } }, { key: "GE", value: function(e3, t3) {
          return a2.__compare(e3, t3, 3);
        } }, { key: "EQ", value: function(e3, t3) {
          for (; ; ) {
            if (a2.__isBigInt(e3))
              return a2.__isBigInt(t3) ? a2.equal(e3, t3) : a2.EQ(t3, e3);
            if ("number" == typeof e3) {
              if (a2.__isBigInt(t3))
                return a2.__equalToNumber(t3, e3);
              if ("object" !== i(t3))
                return e3 == t3;
              t3 = a2.__toPrimitive(t3);
            } else if ("string" == typeof e3) {
              if (a2.__isBigInt(t3))
                return e3 = a2.__fromString(e3), null !== e3 && a2.equal(e3, t3);
              if ("object" !== i(t3))
                return e3 == t3;
              t3 = a2.__toPrimitive(t3);
            } else if ("boolean" == typeof e3) {
              if (a2.__isBigInt(t3))
                return a2.__equalToNumber(t3, +e3);
              if ("object" !== i(t3))
                return e3 == t3;
              t3 = a2.__toPrimitive(t3);
            } else if ("symbol" === i(e3)) {
              if (a2.__isBigInt(t3))
                return false;
              if ("object" !== i(t3))
                return e3 == t3;
              t3 = a2.__toPrimitive(t3);
            } else if ("object" === i(e3)) {
              if ("object" === i(t3) && t3.constructor !== a2)
                return e3 == t3;
              e3 = a2.__toPrimitive(e3);
            } else
              return e3 == t3;
          }
        } }, { key: "NE", value: function(e3, t3) {
          return !a2.EQ(e3, t3);
        } }, { key: "DataViewGetBigInt64", value: function(e3, t3) {
          var i2 = !!(2 < arguments.length && void 0 !== arguments[2]) && arguments[2];
          return a2.asIntN(64, a2.DataViewGetBigUint64(e3, t3, i2));
        } }, { key: "DataViewGetBigUint64", value: function(e3, t3) {
          var i2 = !!(2 < arguments.length && void 0 !== arguments[2]) && arguments[2], _2 = i2 ? [4, 0] : [0, 4], n3 = v(_2, 2), g2 = n3[0], o2 = n3[1], l2 = e3.getUint32(t3 + g2, i2), u3 = e3.getUint32(t3 + o2, i2), s2 = new a2(3, false);
          return s2.__setDigit(0, 1073741823 & u3), s2.__setDigit(1, (268435455 & l2) << 2 | u3 >>> 30), s2.__setDigit(2, l2 >>> 28), s2.__trim();
        } }, { key: "DataViewSetBigInt64", value: function(e3, t3, i2) {
          var _2 = !!(3 < arguments.length && void 0 !== arguments[3]) && arguments[3];
          a2.DataViewSetBigUint64(e3, t3, i2, _2);
        } }, { key: "DataViewSetBigUint64", value: function(e3, t3, i2) {
          var _2 = !!(3 < arguments.length && void 0 !== arguments[3]) && arguments[3];
          i2 = a2.asUintN(64, i2);
          var n3 = 0, g2 = 0;
          if (0 < i2.length && (g2 = i2.__digit(0), 1 < i2.length)) {
            var o2 = i2.__digit(1);
            g2 |= o2 << 30, n3 = o2 >>> 2, 2 < i2.length && (n3 |= i2.__digit(2) << 28);
          }
          var u3 = _2 ? [4, 0] : [0, 4], s2 = v(u3, 2), r2 = s2[0], d2 = s2[1];
          e3.setUint32(t3 + r2, n3, _2), e3.setUint32(t3 + d2, g2, _2);
        } }, { key: "__zero", value: function() {
          return new a2(0, false);
        } }, { key: "__oneDigit", value: function(e3, t3) {
          var i2 = new a2(1, t3);
          return i2.__setDigit(0, e3), i2;
        } }, { key: "__decideRounding", value: function(e3, t3, i2, _2) {
          if (0 < t3)
            return -1;
          var n3;
          if (0 > t3)
            n3 = -t3 - 1;
          else {
            if (0 === i2)
              return -1;
            i2--, _2 = e3.__digit(i2), n3 = 29;
          }
          var l2 = 1 << n3;
          if (0 == (_2 & l2))
            return -1;
          if (l2 -= 1, 0 != (_2 & l2))
            return 1;
          for (; 0 < i2; )
            if (i2--, 0 !== e3.__digit(i2))
              return 1;
          return 0;
        } }, { key: "__fromDouble", value: function(e3) {
          a2.__kBitConversionDouble[0] = e3;
          var t3, i2 = 2047 & a2.__kBitConversionInts[1] >>> 20, _2 = i2 - 1023, n3 = (0 | _2 / 30) + 1, l2 = new a2(n3, 0 > e3), g2 = 1048575 & a2.__kBitConversionInts[1] | 1048576, o2 = a2.__kBitConversionInts[0], u3 = 20, s2 = _2 % 30, r2 = 0;
          if (s2 < u3) {
            var d2 = u3 - s2;
            r2 = d2 + 32, t3 = g2 >>> d2, g2 = g2 << 32 - d2 | o2 >>> d2, o2 <<= 32 - d2;
          } else if (s2 === u3)
            r2 = 32, t3 = g2, g2 = o2, o2 = 0;
          else {
            var h2 = s2 - u3;
            r2 = 32 - h2, t3 = g2 << h2 | o2 >>> 32 - h2, g2 = o2 << h2, o2 = 0;
          }
          l2.__setDigit(n3 - 1, t3);
          for (var b2 = n3 - 2; 0 <= b2; b2--)
            0 < r2 ? (r2 -= 30, t3 = g2 >>> 2, g2 = g2 << 30 | o2 >>> 2, o2 <<= 30) : t3 = 0, l2.__setDigit(b2, t3);
          return l2.__trim();
        } }, { key: "__isWhitespace", value: function(e3) {
          return !!(13 >= e3 && 9 <= e3) || (159 >= e3 ? 32 == e3 : 131071 >= e3 ? 160 == e3 || 5760 == e3 : 196607 >= e3 ? (e3 &= 131071, 10 >= e3 || 40 == e3 || 41 == e3 || 47 == e3 || 95 == e3 || 4096 == e3) : 65279 == e3);
        } }, { key: "__fromString", value: function(e3) {
          var t3 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, i2 = 0, _2 = e3.length, n3 = 0;
          if (n3 === _2)
            return a2.__zero();
          for (var l2 = e3.charCodeAt(n3); a2.__isWhitespace(l2); ) {
            if (++n3 === _2)
              return a2.__zero();
            l2 = e3.charCodeAt(n3);
          }
          if (43 === l2) {
            if (++n3 === _2)
              return null;
            l2 = e3.charCodeAt(n3), i2 = 1;
          } else if (45 === l2) {
            if (++n3 === _2)
              return null;
            l2 = e3.charCodeAt(n3), i2 = -1;
          }
          if (0 === t3) {
            if (t3 = 10, 48 === l2) {
              if (++n3 === _2)
                return a2.__zero();
              if (l2 = e3.charCodeAt(n3), 88 === l2 || 120 === l2) {
                if (t3 = 16, ++n3 === _2)
                  return null;
                l2 = e3.charCodeAt(n3);
              } else if (79 === l2 || 111 === l2) {
                if (t3 = 8, ++n3 === _2)
                  return null;
                l2 = e3.charCodeAt(n3);
              } else if (66 === l2 || 98 === l2) {
                if (t3 = 2, ++n3 === _2)
                  return null;
                l2 = e3.charCodeAt(n3);
              }
            }
          } else if (16 === t3 && 48 === l2) {
            if (++n3 === _2)
              return a2.__zero();
            if (l2 = e3.charCodeAt(n3), 88 === l2 || 120 === l2) {
              if (++n3 === _2)
                return null;
              l2 = e3.charCodeAt(n3);
            }
          }
          if (0 !== i2 && 10 !== t3)
            return null;
          for (; 48 === l2; ) {
            if (++n3 === _2)
              return a2.__zero();
            l2 = e3.charCodeAt(n3);
          }
          var g2 = _2 - n3, o2 = a2.__kMaxBitsPerChar[t3], u3 = a2.__kBitsPerCharTableMultiplier - 1;
          if (g2 > 1073741824 / o2)
            return null;
          var s2 = o2 * g2 + u3 >>> a2.__kBitsPerCharTableShift, r2 = new a2(0 | (s2 + 29) / 30, false), h2 = 10 > t3 ? t3 : 10, b2 = 10 < t3 ? t3 - 10 : 0;
          if (0 == (t3 & t3 - 1)) {
            o2 >>= a2.__kBitsPerCharTableShift;
            var c2 = [], v2 = [], y2 = false;
            do {
              for (var f2, D2 = 0, p2 = 0; ; ) {
                if (f2 = void 0, l2 - 48 >>> 0 < h2)
                  f2 = l2 - 48;
                else if ((32 | l2) - 97 >>> 0 < b2)
                  f2 = (32 | l2) - 87;
                else {
                  y2 = true;
                  break;
                }
                if (p2 += o2, D2 = D2 << o2 | f2, ++n3 === _2) {
                  y2 = true;
                  break;
                }
                if (l2 = e3.charCodeAt(n3), 30 < p2 + o2)
                  break;
              }
              c2.push(D2), v2.push(p2);
            } while (!y2);
            a2.__fillFromParts(r2, c2, v2);
          } else {
            r2.__initializeDigits();
            var k2 = false, B2 = 0;
            do {
              for (var S2, C = 0, I = 1; ; ) {
                if (S2 = void 0, l2 - 48 >>> 0 < h2)
                  S2 = l2 - 48;
                else if ((32 | l2) - 97 >>> 0 < b2)
                  S2 = (32 | l2) - 87;
                else {
                  k2 = true;
                  break;
                }
                var A = I * t3;
                if (1073741823 < A)
                  break;
                if (I = A, C = C * t3 + S2, B2++, ++n3 === _2) {
                  k2 = true;
                  break;
                }
                l2 = e3.charCodeAt(n3);
              }
              u3 = 30 * a2.__kBitsPerCharTableMultiplier - 1;
              var m2 = 0 | (o2 * B2 + u3 >>> a2.__kBitsPerCharTableShift) / 30;
              r2.__inplaceMultiplyAdd(I, C, m2);
            } while (!k2);
          }
          if (n3 !== _2) {
            if (!a2.__isWhitespace(l2))
              return null;
            for (n3++; n3 < _2; n3++)
              if (l2 = e3.charCodeAt(n3), !a2.__isWhitespace(l2))
                return null;
          }
          return r2.sign = -1 === i2, r2.__trim();
        } }, { key: "__fillFromParts", value: function(e3, t3, _2) {
          for (var n3 = 0, l2 = 0, g2 = 0, o2 = t3.length - 1; 0 <= o2; o2--) {
            var a3 = t3[o2], u3 = _2[o2];
            l2 |= a3 << g2, g2 += u3, 30 === g2 ? (e3.__setDigit(n3++, l2), g2 = 0, l2 = 0) : 30 < g2 && (e3.__setDigit(n3++, 1073741823 & l2), g2 -= 30, l2 = a3 >>> u3 - g2);
          }
          if (0 !== l2) {
            if (n3 >= e3.length)
              throw new Error("implementation bug");
            e3.__setDigit(n3++, l2);
          }
          for (; n3 < e3.length; n3++)
            e3.__setDigit(n3, 0);
        } }, { key: "__toStringBasePowerOfTwo", value: function(e3, t3) {
          var _2 = e3.length, n3 = t3 - 1;
          n3 = (85 & n3 >>> 1) + (85 & n3), n3 = (51 & n3 >>> 2) + (51 & n3), n3 = (15 & n3 >>> 4) + (15 & n3);
          var l2 = n3, g2 = t3 - 1, o2 = e3.__digit(_2 - 1), u3 = a2.__clz30(o2), s2 = 0 | (30 * _2 - u3 + l2 - 1) / l2;
          if (e3.sign && s2++, 268435456 < s2)
            throw new Error("string too long");
          for (var r2 = Array(s2), d2 = s2 - 1, h2 = 0, b2 = 0, m2 = 0; m2 < _2 - 1; m2++) {
            var c2 = e3.__digit(m2), v2 = (h2 | c2 << b2) & g2;
            r2[d2--] = a2.__kConversionChars[v2];
            var y2 = l2 - b2;
            for (h2 = c2 >>> y2, b2 = 30 - y2; b2 >= l2; )
              r2[d2--] = a2.__kConversionChars[h2 & g2], h2 >>>= l2, b2 -= l2;
          }
          var f2 = (h2 | o2 << b2) & g2;
          for (r2[d2--] = a2.__kConversionChars[f2], h2 = o2 >>> l2 - b2; 0 !== h2; )
            r2[d2--] = a2.__kConversionChars[h2 & g2], h2 >>>= l2;
          if (e3.sign && (r2[d2--] = "-"), -1 !== d2)
            throw new Error("implementation bug");
          return r2.join("");
        } }, { key: "__toStringGeneric", value: function(e3, t3, _2) {
          var n3 = e3.length;
          if (0 === n3)
            return "";
          if (1 === n3) {
            var l2 = e3.__unsignedDigit(0).toString(t3);
            return false === _2 && e3.sign && (l2 = "-" + l2), l2;
          }
          var g2 = 30 * n3 - a2.__clz30(e3.__digit(n3 - 1)), o2 = a2.__kMaxBitsPerChar[t3], u3 = o2 - 1, s2 = g2 * a2.__kBitsPerCharTableMultiplier;
          s2 += u3 - 1, s2 = 0 | s2 / u3;
          var r2, d2, h2 = s2 + 1 >> 1, b2 = a2.exponentiate(a2.__oneDigit(t3, false), a2.__oneDigit(h2, false)), m2 = b2.__unsignedDigit(0);
          if (1 === b2.length && 32767 >= m2) {
            r2 = new a2(e3.length, false), r2.__initializeDigits();
            for (var c2, v2 = 0, y2 = 2 * e3.length - 1; 0 <= y2; y2--)
              c2 = v2 << 15 | e3.__halfDigit(y2), r2.__setHalfDigit(y2, 0 | c2 / m2), v2 = 0 | c2 % m2;
            d2 = v2.toString(t3);
          } else {
            var f2 = a2.__absoluteDivLarge(e3, b2, true, true);
            r2 = f2.quotient;
            var D2 = f2.remainder.__trim();
            d2 = a2.__toStringGeneric(D2, t3, true);
          }
          r2.__trim();
          for (var p2 = a2.__toStringGeneric(r2, t3, true); d2.length < h2; )
            d2 = "0" + d2;
          return false === _2 && e3.sign && (p2 = "-" + p2), p2 + d2;
        } }, { key: "__unequalSign", value: function(e3) {
          return e3 ? -1 : 1;
        } }, { key: "__absoluteGreater", value: function(e3) {
          return e3 ? -1 : 1;
        } }, { key: "__absoluteLess", value: function(e3) {
          return e3 ? 1 : -1;
        } }, { key: "__compareToBigInt", value: function(e3, t3) {
          var i2 = e3.sign;
          if (i2 !== t3.sign)
            return a2.__unequalSign(i2);
          var _2 = a2.__absoluteCompare(e3, t3);
          return 0 < _2 ? a2.__absoluteGreater(i2) : 0 > _2 ? a2.__absoluteLess(i2) : 0;
        } }, { key: "__compareToNumber", value: function(e3, i2) {
          if (a2.__isOneDigitInt(i2)) {
            var _2 = e3.sign, n3 = 0 > i2;
            if (_2 !== n3)
              return a2.__unequalSign(_2);
            if (0 === e3.length) {
              if (n3)
                throw new Error("implementation bug");
              return 0 === i2 ? 0 : -1;
            }
            if (1 < e3.length)
              return a2.__absoluteGreater(_2);
            var l2 = t2(i2), g2 = e3.__unsignedDigit(0);
            return g2 > l2 ? a2.__absoluteGreater(_2) : g2 < l2 ? a2.__absoluteLess(_2) : 0;
          }
          return a2.__compareToDouble(e3, i2);
        } }, { key: "__compareToDouble", value: function(e3, t3) {
          if (t3 !== t3)
            return t3;
          if (t3 === 1 / 0)
            return -1;
          if (t3 === -Infinity)
            return 1;
          var i2 = e3.sign;
          if (i2 !== 0 > t3)
            return a2.__unequalSign(i2);
          if (0 === t3)
            throw new Error("implementation bug: should be handled elsewhere");
          if (0 === e3.length)
            return -1;
          a2.__kBitConversionDouble[0] = t3;
          var _2 = 2047 & a2.__kBitConversionInts[1] >>> 20;
          if (2047 == _2)
            throw new Error("implementation bug: handled elsewhere");
          var n3 = _2 - 1023;
          if (0 > n3)
            return a2.__absoluteGreater(i2);
          var l2 = e3.length, g2 = e3.__digit(l2 - 1), o2 = a2.__clz30(g2), u3 = 30 * l2 - o2, s2 = n3 + 1;
          if (u3 < s2)
            return a2.__absoluteLess(i2);
          if (u3 > s2)
            return a2.__absoluteGreater(i2);
          var r2 = 1048576 | 1048575 & a2.__kBitConversionInts[1], d2 = a2.__kBitConversionInts[0], h2 = 20, b2 = 29 - o2;
          if (b2 !== (0 | (u3 - 1) % 30))
            throw new Error("implementation bug");
          var m2, c2 = 0;
          if (b2 < h2) {
            var v2 = h2 - b2;
            c2 = v2 + 32, m2 = r2 >>> v2, r2 = r2 << 32 - v2 | d2 >>> v2, d2 <<= 32 - v2;
          } else if (b2 === h2)
            c2 = 32, m2 = r2, r2 = d2, d2 = 0;
          else {
            var y2 = b2 - h2;
            c2 = 32 - y2, m2 = r2 << y2 | d2 >>> 32 - y2, r2 = d2 << y2, d2 = 0;
          }
          if (g2 >>>= 0, m2 >>>= 0, g2 > m2)
            return a2.__absoluteGreater(i2);
          if (g2 < m2)
            return a2.__absoluteLess(i2);
          for (var f2 = l2 - 2; 0 <= f2; f2--) {
            0 < c2 ? (c2 -= 30, m2 = r2 >>> 2, r2 = r2 << 30 | d2 >>> 2, d2 <<= 30) : m2 = 0;
            var D2 = e3.__unsignedDigit(f2);
            if (D2 > m2)
              return a2.__absoluteGreater(i2);
            if (D2 < m2)
              return a2.__absoluteLess(i2);
          }
          if (0 !== r2 || 0 !== d2) {
            if (0 === c2)
              throw new Error("implementation bug");
            return a2.__absoluteLess(i2);
          }
          return 0;
        } }, { key: "__equalToNumber", value: function(e3, i2) {
          return a2.__isOneDigitInt(i2) ? 0 === i2 ? 0 === e3.length : 1 === e3.length && e3.sign === 0 > i2 && e3.__unsignedDigit(0) === t2(i2) : 0 === a2.__compareToDouble(e3, i2);
        } }, { key: "__comparisonResultToBool", value: function(e3, t3) {
          return 0 === t3 ? 0 > e3 : 1 === t3 ? 0 >= e3 : 2 === t3 ? 0 < e3 : 3 === t3 ? 0 <= e3 : void 0;
        } }, { key: "__compare", value: function(e3, t3, i2) {
          if (e3 = a2.__toPrimitive(e3), t3 = a2.__toPrimitive(t3), "string" == typeof e3 && "string" == typeof t3)
            switch (i2) {
              case 0:
                return e3 < t3;
              case 1:
                return e3 <= t3;
              case 2:
                return e3 > t3;
              case 3:
                return e3 >= t3;
            }
          if (a2.__isBigInt(e3) && "string" == typeof t3)
            return t3 = a2.__fromString(t3), null !== t3 && a2.__comparisonResultToBool(a2.__compareToBigInt(e3, t3), i2);
          if ("string" == typeof e3 && a2.__isBigInt(t3))
            return e3 = a2.__fromString(e3), null !== e3 && a2.__comparisonResultToBool(a2.__compareToBigInt(e3, t3), i2);
          if (e3 = a2.__toNumeric(e3), t3 = a2.__toNumeric(t3), a2.__isBigInt(e3)) {
            if (a2.__isBigInt(t3))
              return a2.__comparisonResultToBool(a2.__compareToBigInt(e3, t3), i2);
            if ("number" != typeof t3)
              throw new Error("implementation bug");
            return a2.__comparisonResultToBool(a2.__compareToNumber(e3, t3), i2);
          }
          if ("number" != typeof e3)
            throw new Error("implementation bug");
          if (a2.__isBigInt(t3))
            return a2.__comparisonResultToBool(a2.__compareToNumber(t3, e3), 2 ^ i2);
          if ("number" != typeof t3)
            throw new Error("implementation bug");
          return 0 === i2 ? e3 < t3 : 1 === i2 ? e3 <= t3 : 2 === i2 ? e3 > t3 : 3 === i2 ? e3 >= t3 : void 0;
        } }, { key: "__absoluteAdd", value: function(e3, t3, _2) {
          if (e3.length < t3.length)
            return a2.__absoluteAdd(t3, e3, _2);
          if (0 === e3.length)
            return e3;
          if (0 === t3.length)
            return e3.sign === _2 ? e3 : a2.unaryMinus(e3);
          var n3 = e3.length;
          (0 === e3.__clzmsd() || t3.length === e3.length && 0 === t3.__clzmsd()) && n3++;
          for (var l2, g2 = new a2(n3, _2), o2 = 0, u3 = 0; u3 < t3.length; u3++)
            l2 = e3.__digit(u3) + t3.__digit(u3) + o2, o2 = l2 >>> 30, g2.__setDigit(u3, 1073741823 & l2);
          for (; u3 < e3.length; u3++) {
            var s2 = e3.__digit(u3) + o2;
            o2 = s2 >>> 30, g2.__setDigit(u3, 1073741823 & s2);
          }
          return u3 < g2.length && g2.__setDigit(u3, o2), g2.__trim();
        } }, { key: "__absoluteSub", value: function(e3, t3, _2) {
          if (0 === e3.length)
            return e3;
          if (0 === t3.length)
            return e3.sign === _2 ? e3 : a2.unaryMinus(e3);
          for (var n3, l2 = new a2(e3.length, _2), g2 = 0, o2 = 0; o2 < t3.length; o2++)
            n3 = e3.__digit(o2) - t3.__digit(o2) - g2, g2 = 1 & n3 >>> 30, l2.__setDigit(o2, 1073741823 & n3);
          for (; o2 < e3.length; o2++) {
            var u3 = e3.__digit(o2) - g2;
            g2 = 1 & u3 >>> 30, l2.__setDigit(o2, 1073741823 & u3);
          }
          return l2.__trim();
        } }, { key: "__absoluteAddOne", value: function(e3, t3) {
          var _2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n3 = e3.length;
          null === _2 ? _2 = new a2(n3, t3) : _2.sign = t3;
          for (var l2, g2 = 1, o2 = 0; o2 < n3; o2++)
            l2 = e3.__digit(o2) + g2, g2 = l2 >>> 30, _2.__setDigit(o2, 1073741823 & l2);
          return 0 !== g2 && _2.__setDigitGrow(n3, 1), _2;
        } }, { key: "__absoluteSubOne", value: function(e3, t3) {
          var _2 = e3.length;
          t3 = t3 || _2;
          for (var n3, l2 = new a2(t3, false), g2 = 1, o2 = 0; o2 < _2; o2++)
            n3 = e3.__digit(o2) - g2, g2 = 1 & n3 >>> 30, l2.__setDigit(o2, 1073741823 & n3);
          if (0 !== g2)
            throw new Error("implementation bug");
          for (var u3 = _2; u3 < t3; u3++)
            l2.__setDigit(u3, 0);
          return l2;
        } }, { key: "__absoluteAnd", value: function(e3, t3) {
          var _2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n3 = e3.length, l2 = t3.length, g2 = l2;
          if (n3 < l2) {
            g2 = n3;
            var o2 = e3, u3 = n3;
            e3 = t3, n3 = l2, t3 = o2, l2 = u3;
          }
          var s2 = g2;
          null === _2 ? _2 = new a2(s2, false) : s2 = _2.length;
          for (var r2 = 0; r2 < g2; r2++)
            _2.__setDigit(r2, e3.__digit(r2) & t3.__digit(r2));
          for (; r2 < s2; r2++)
            _2.__setDigit(r2, 0);
          return _2;
        } }, { key: "__absoluteAndNot", value: function(e3, t3) {
          var _2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n3 = e3.length, l2 = t3.length, g2 = l2;
          n3 < l2 && (g2 = n3);
          var o2 = n3;
          null === _2 ? _2 = new a2(o2, false) : o2 = _2.length;
          for (var u3 = 0; u3 < g2; u3++)
            _2.__setDigit(u3, e3.__digit(u3) & ~t3.__digit(u3));
          for (; u3 < n3; u3++)
            _2.__setDigit(u3, e3.__digit(u3));
          for (; u3 < o2; u3++)
            _2.__setDigit(u3, 0);
          return _2;
        } }, { key: "__absoluteOr", value: function(e3, t3) {
          var _2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n3 = e3.length, l2 = t3.length, g2 = l2;
          if (n3 < l2) {
            g2 = n3;
            var o2 = e3, u3 = n3;
            e3 = t3, n3 = l2, t3 = o2, l2 = u3;
          }
          var s2 = n3;
          null === _2 ? _2 = new a2(s2, false) : s2 = _2.length;
          for (var r2 = 0; r2 < g2; r2++)
            _2.__setDigit(r2, e3.__digit(r2) | t3.__digit(r2));
          for (; r2 < n3; r2++)
            _2.__setDigit(r2, e3.__digit(r2));
          for (; r2 < s2; r2++)
            _2.__setDigit(r2, 0);
          return _2;
        } }, { key: "__absoluteXor", value: function(e3, t3) {
          var _2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n3 = e3.length, l2 = t3.length, g2 = l2;
          if (n3 < l2) {
            g2 = n3;
            var o2 = e3, u3 = n3;
            e3 = t3, n3 = l2, t3 = o2, l2 = u3;
          }
          var s2 = n3;
          null === _2 ? _2 = new a2(s2, false) : s2 = _2.length;
          for (var r2 = 0; r2 < g2; r2++)
            _2.__setDigit(r2, e3.__digit(r2) ^ t3.__digit(r2));
          for (; r2 < n3; r2++)
            _2.__setDigit(r2, e3.__digit(r2));
          for (; r2 < s2; r2++)
            _2.__setDigit(r2, 0);
          return _2;
        } }, { key: "__absoluteCompare", value: function(e3, t3) {
          var _2 = e3.length - t3.length;
          if (0 != _2)
            return _2;
          for (var n3 = e3.length - 1; 0 <= n3 && e3.__digit(n3) === t3.__digit(n3); )
            n3--;
          return 0 > n3 ? 0 : e3.__unsignedDigit(n3) > t3.__unsignedDigit(n3) ? 1 : -1;
        } }, { key: "__multiplyAccumulate", value: function(e3, t3, _2, n3) {
          if (0 !== t3) {
            for (var l2 = 32767 & t3, g2 = t3 >>> 15, o2 = 0, u3 = 0, s2 = 0; s2 < e3.length; s2++, n3++) {
              var r2 = _2.__digit(n3), d2 = e3.__digit(s2), h2 = 32767 & d2, b2 = d2 >>> 15, m2 = a2.__imul(h2, l2), c2 = a2.__imul(h2, g2), v2 = a2.__imul(b2, l2), y2 = a2.__imul(b2, g2);
              r2 += u3 + m2 + o2, o2 = r2 >>> 30, r2 &= 1073741823, r2 += ((32767 & c2) << 15) + ((32767 & v2) << 15), o2 += r2 >>> 30, u3 = y2 + (c2 >>> 15) + (v2 >>> 15), _2.__setDigit(n3, 1073741823 & r2);
            }
            for (; 0 !== o2 || 0 !== u3; n3++) {
              var f2 = _2.__digit(n3);
              f2 += o2 + u3, u3 = 0, o2 = f2 >>> 30, _2.__setDigit(n3, 1073741823 & f2);
            }
          }
        } }, { key: "__internalMultiplyAdd", value: function(e3, t3, _2, l2, g2) {
          for (var o2 = _2, u3 = 0, s2 = 0; s2 < l2; s2++) {
            var d2 = e3.__digit(s2), h2 = a2.__imul(32767 & d2, t3), b2 = a2.__imul(d2 >>> 15, t3), m2 = h2 + ((32767 & b2) << 15) + u3 + o2;
            o2 = m2 >>> 30, u3 = b2 >>> 15, g2.__setDigit(s2, 1073741823 & m2);
          }
          if (g2.length > l2)
            for (g2.__setDigit(l2++, o2 + u3); l2 < g2.length; )
              g2.__setDigit(l2++, 0);
          else if (0 !== o2 + u3)
            throw new Error("implementation bug");
        } }, { key: "__absoluteDivSmall", value: function(e3, t3) {
          var _2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
          null === _2 && (_2 = new a2(e3.length, false));
          for (var n3 = 0, l2 = 2 * e3.length - 1; 0 <= l2; l2 -= 2) {
            var g2 = (n3 << 15 | e3.__halfDigit(l2)) >>> 0, o2 = 0 | g2 / t3;
            n3 = 0 | g2 % t3, g2 = (n3 << 15 | e3.__halfDigit(l2 - 1)) >>> 0;
            var u3 = 0 | g2 / t3;
            n3 = 0 | g2 % t3, _2.__setDigit(l2 >>> 1, o2 << 15 | u3);
          }
          return _2;
        } }, { key: "__absoluteModSmall", value: function(e3, t3) {
          for (var _2, n3 = 0, l2 = 2 * e3.length - 1; 0 <= l2; l2--)
            _2 = (n3 << 15 | e3.__halfDigit(l2)) >>> 0, n3 = 0 | _2 % t3;
          return n3;
        } }, { key: "__absoluteDivLarge", value: function(e3, t3, i2, _2) {
          var l2 = t3.__halfDigitLength(), n3 = t3.length, g2 = e3.__halfDigitLength() - l2, o2 = null;
          i2 && (o2 = new a2(g2 + 2 >>> 1, false), o2.__initializeDigits());
          var s2 = new a2(l2 + 2 >>> 1, false);
          s2.__initializeDigits();
          var r2 = a2.__clz15(t3.__halfDigit(l2 - 1));
          0 < r2 && (t3 = a2.__specialLeftShift(t3, r2, 0));
          for (var d2 = a2.__specialLeftShift(e3, r2, 1), u3 = t3.__halfDigit(l2 - 1), h2 = 0, b2 = g2; 0 <= b2; b2--) {
            var m2 = 32767, v2 = d2.__halfDigit(b2 + l2);
            if (v2 !== u3) {
              var y2 = (v2 << 15 | d2.__halfDigit(b2 + l2 - 1)) >>> 0;
              m2 = 0 | y2 / u3;
              for (var f2 = 0 | y2 % u3, D2 = t3.__halfDigit(l2 - 2), p2 = d2.__halfDigit(b2 + l2 - 2); a2.__imul(m2, D2) >>> 0 > (f2 << 16 | p2) >>> 0 && (m2--, f2 += u3, !(32767 < f2)); )
                ;
            }
            a2.__internalMultiplyAdd(t3, m2, 0, n3, s2);
            var k2 = d2.__inplaceSub(s2, b2, l2 + 1);
            0 !== k2 && (k2 = d2.__inplaceAdd(t3, b2, l2), d2.__setHalfDigit(b2 + l2, 32767 & d2.__halfDigit(b2 + l2) + k2), m2--), i2 && (1 & b2 ? h2 = m2 << 15 : o2.__setDigit(b2 >>> 1, h2 | m2));
          }
          if (_2)
            return d2.__inplaceRightShift(r2), i2 ? { quotient: o2, remainder: d2 } : d2;
          if (i2)
            return o2;
          throw new Error("unreachable");
        } }, { key: "__clz15", value: function(e3) {
          return a2.__clz30(e3) - 15;
        } }, { key: "__specialLeftShift", value: function(e3, t3, _2) {
          var l2 = e3.length, n3 = new a2(l2 + _2, false);
          if (0 === t3) {
            for (var g2 = 0; g2 < l2; g2++)
              n3.__setDigit(g2, e3.__digit(g2));
            return 0 < _2 && n3.__setDigit(l2, 0), n3;
          }
          for (var o2, u3 = 0, s2 = 0; s2 < l2; s2++)
            o2 = e3.__digit(s2), n3.__setDigit(s2, 1073741823 & o2 << t3 | u3), u3 = o2 >>> 30 - t3;
          return 0 < _2 && n3.__setDigit(l2, u3), n3;
        } }, { key: "__leftShiftByAbsolute", value: function(e3, t3) {
          var _2 = a2.__toShiftAmount(t3);
          if (0 > _2)
            throw new RangeError("BigInt too big");
          var n3 = 0 | _2 / 30, l2 = _2 % 30, g2 = e3.length, o2 = 0 !== l2 && 0 != e3.__digit(g2 - 1) >>> 30 - l2, u3 = g2 + n3 + (o2 ? 1 : 0), s2 = new a2(u3, e3.sign);
          if (0 === l2) {
            for (var r2 = 0; r2 < n3; r2++)
              s2.__setDigit(r2, 0);
            for (; r2 < u3; r2++)
              s2.__setDigit(r2, e3.__digit(r2 - n3));
          } else {
            for (var h2 = 0, b2 = 0; b2 < n3; b2++)
              s2.__setDigit(b2, 0);
            for (var m2, c2 = 0; c2 < g2; c2++)
              m2 = e3.__digit(c2), s2.__setDigit(c2 + n3, 1073741823 & m2 << l2 | h2), h2 = m2 >>> 30 - l2;
            if (o2)
              s2.__setDigit(g2 + n3, h2);
            else if (0 !== h2)
              throw new Error("implementation bug");
          }
          return s2.__trim();
        } }, { key: "__rightShiftByAbsolute", value: function(e3, t3) {
          var _2 = e3.length, n3 = e3.sign, l2 = a2.__toShiftAmount(t3);
          if (0 > l2)
            return a2.__rightShiftByMaximum(n3);
          var g2 = 0 | l2 / 30, o2 = l2 % 30, u3 = _2 - g2;
          if (0 >= u3)
            return a2.__rightShiftByMaximum(n3);
          var s2 = false;
          if (n3) {
            if (0 != (e3.__digit(g2) & (1 << o2) - 1))
              s2 = true;
            else
              for (var r2 = 0; r2 < g2; r2++)
                if (0 !== e3.__digit(r2)) {
                  s2 = true;
                  break;
                }
          }
          if (s2 && 0 === o2) {
            var h2 = e3.__digit(_2 - 1);
            0 == ~h2 && u3++;
          }
          var b2 = new a2(u3, n3);
          if (0 === o2) {
            b2.__setDigit(u3 - 1, 0);
            for (var m2 = g2; m2 < _2; m2++)
              b2.__setDigit(m2 - g2, e3.__digit(m2));
          } else {
            for (var c2, v2 = e3.__digit(g2) >>> o2, y2 = _2 - g2 - 1, f2 = 0; f2 < y2; f2++)
              c2 = e3.__digit(f2 + g2 + 1), b2.__setDigit(f2, 1073741823 & c2 << 30 - o2 | v2), v2 = c2 >>> o2;
            b2.__setDigit(y2, v2);
          }
          return s2 && (b2 = a2.__absoluteAddOne(b2, true, b2)), b2.__trim();
        } }, { key: "__rightShiftByMaximum", value: function(e3) {
          return e3 ? a2.__oneDigit(1, true) : a2.__zero();
        } }, { key: "__toShiftAmount", value: function(e3) {
          if (1 < e3.length)
            return -1;
          var t3 = e3.__unsignedDigit(0);
          return t3 > a2.__kMaxLengthBits ? -1 : t3;
        } }, { key: "__toPrimitive", value: function(e3) {
          var t3 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "default";
          if ("object" !== i(e3))
            return e3;
          if (e3.constructor === a2)
            return e3;
          if ("undefined" != typeof Symbol && "symbol" === i(Symbol.toPrimitive)) {
            var _2 = e3[Symbol.toPrimitive];
            if (_2) {
              var n3 = _2(t3);
              if ("object" !== i(n3))
                return n3;
              throw new TypeError("Cannot convert object to primitive value");
            }
          }
          var l2 = e3.valueOf;
          if (l2) {
            var g2 = l2.call(e3);
            if ("object" !== i(g2))
              return g2;
          }
          var o2 = e3.toString;
          if (o2) {
            var u3 = o2.call(e3);
            if ("object" !== i(u3))
              return u3;
          }
          throw new TypeError("Cannot convert object to primitive value");
        } }, { key: "__toNumeric", value: function(e3) {
          return a2.__isBigInt(e3) ? e3 : +e3;
        } }, { key: "__isBigInt", value: function(e3) {
          return "object" === i(e3) && null !== e3 && e3.constructor === a2;
        } }, { key: "__truncateToNBits", value: function(e3, t3) {
          for (var _2 = 0 | (e3 + 29) / 30, n3 = new a2(_2, t3.sign), l2 = _2 - 1, g2 = 0; g2 < l2; g2++)
            n3.__setDigit(g2, t3.__digit(g2));
          var o2 = t3.__digit(l2);
          if (0 != e3 % 30) {
            var u3 = 32 - e3 % 30;
            o2 = o2 << u3 >>> u3;
          }
          return n3.__setDigit(l2, o2), n3.__trim();
        } }, { key: "__truncateAndSubFromPowerOfTwo", value: function(e3, t3, _2) {
          for (var n3 = Math.min, l2, g2 = 0 | (e3 + 29) / 30, o2 = new a2(g2, _2), u3 = 0, s2 = g2 - 1, d2 = 0, h2 = n3(s2, t3.length); u3 < h2; u3++)
            l2 = 0 - t3.__digit(u3) - d2, d2 = 1 & l2 >>> 30, o2.__setDigit(u3, 1073741823 & l2);
          for (; u3 < s2; u3++)
            o2.__setDigit(u3, 0 | 1073741823 & -d2);
          var b2, m2 = s2 < t3.length ? t3.__digit(s2) : 0, c2 = e3 % 30;
          if (0 === c2)
            b2 = 0 - m2 - d2, b2 &= 1073741823;
          else {
            var v2 = 32 - c2;
            m2 = m2 << v2 >>> v2;
            var y2 = 1 << 32 - v2;
            b2 = y2 - m2 - d2, b2 &= y2 - 1;
          }
          return o2.__setDigit(s2, b2), o2.__trim();
        } }, { key: "__digitPow", value: function(e3, t3) {
          for (var i2 = 1; 0 < t3; )
            1 & t3 && (i2 *= e3), t3 >>>= 1, e3 *= e3;
          return i2;
        } }, { key: "__isOneDigitInt", value: function(e3) {
          return (1073741823 & e3) === e3;
        } }]), a2;
      }(h(Array));
      return S.__kMaxLength = 33554432, S.__kMaxLengthBits = S.__kMaxLength << 5, S.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], S.__kBitsPerCharTableShift = 5, S.__kBitsPerCharTableMultiplier = 1 << S.__kBitsPerCharTableShift, S.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], S.__kBitConversionBuffer = new ArrayBuffer(8), S.__kBitConversionDouble = new Float64Array(S.__kBitConversionBuffer), S.__kBitConversionInts = new Int32Array(S.__kBitConversionBuffer), S.__clz30 = t ? function(e2) {
        return t(e2) - 2;
      } : function(e2) {
        var t2 = Math.LN2, i2 = Math.log;
        return 0 === e2 ? 30 : 0 | 29 - (0 | i2(e2 >>> 0) / t2);
      }, S.__imul = e || function(e2, t2) {
        return 0 | e2 * t2;
      }, S;
    });
  }
});

// node_modules/tiny-invariant/dist/tiny-invariant.cjs.js
var require_tiny_invariant_cjs = __commonJS({
  "node_modules/tiny-invariant/dist/tiny-invariant.cjs.js"(exports, module) {
    "use strict";
    var isProduction = false;
    var prefix = "Invariant failed";
    function invariant(condition, message) {
      if (condition) {
        return;
      }
      if (isProduction) {
        throw new Error(prefix);
      }
      var provided = typeof message === "function" ? message() : message;
      var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
      throw new Error(value);
    }
    module.exports = invariant;
  }
});

// node_modules/starknet/utils/shortString.js
var require_shortString = __commonJS({
  "node_modules/starknet/utils/shortString.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeShortString = exports.encodeShortString = exports.isShortString = exports.isASCII = void 0;
    var encode_1 = require_encode();
    function isASCII(str) {
      return /^[\x00-\x7F]*$/.test(str);
    }
    exports.isASCII = isASCII;
    function isShortString(str) {
      return str.length <= 31;
    }
    exports.isShortString = isShortString;
    function encodeShortString(str) {
      if (!isASCII(str))
        throw new Error("".concat(str, " is not an ASCII string"));
      if (!isShortString(str))
        throw new Error("".concat(str, " is too long"));
      return (0, encode_1.addHexPrefix)(
        str.replace(/./g, function(char) {
          return char.charCodeAt(0).toString(16);
        })
      );
    }
    exports.encodeShortString = encodeShortString;
    function decodeShortString(str) {
      return (0, encode_1.removeHexPrefix)(str).replace(/.{2}/g, function(hex) {
        return String.fromCharCode(parseInt(hex, 16));
      });
    }
    exports.decodeShortString = decodeShortString;
  }
});

// node_modules/toformat/toFormat.js
var require_toFormat = __commonJS({
  "node_modules/toformat/toFormat.js"(exports, module) {
    function toFormat(Ctor) {
      "use strict";
      Ctor.prototype.toFormat = function toFormat2(dp, rm, fmt) {
        if (!this.e && this.e !== 0)
          return this.toString();
        var arr, g1, g2, i, u, nd, intd, intp, fracp, dsep, gsep, gsize, sgsize, fgsep, fgsize, tfmt = this.format || {}, cfmt = this.constructor.format || {};
        if (dp != u) {
          if (typeof dp == "object") {
            fmt = dp;
            dp = u;
          } else if (rm != u) {
            if (typeof rm == "object") {
              fmt = rm;
              rm = u;
            } else if (typeof fmt != "object") {
              fmt = {};
            }
          } else {
            fmt = {};
          }
        } else {
          fmt = {};
        }
        arr = this.toFixed(dp, rm).split(".");
        intp = arr[0];
        fracp = arr[1];
        intd = this.s < 0 ? intp.slice(1) : intp;
        nd = intd.length;
        dsep = fmt.decimalSeparator;
        if (dsep == u) {
          dsep = tfmt.decimalSeparator;
          if (dsep == u) {
            dsep = cfmt.decimalSeparator;
            if (dsep == u)
              dsep = ".";
          }
        }
        gsep = fmt.groupSeparator;
        if (gsep == u) {
          gsep = tfmt.groupSeparator;
          if (gsep == u)
            gsep = cfmt.groupSeparator;
        }
        if (gsep) {
          gsize = fmt.groupSize;
          if (gsize == u) {
            gsize = tfmt.groupSize;
            if (gsize == u) {
              gsize = cfmt.groupSize;
              if (gsize == u)
                gsize = 0;
            }
          }
          sgsize = fmt.secondaryGroupSize;
          if (sgsize == u) {
            sgsize = tfmt.secondaryGroupSize;
            if (sgsize == u) {
              sgsize = cfmt.secondaryGroupSize;
              if (sgsize == u)
                sgsize = 0;
            }
          }
          if (sgsize) {
            g1 = +sgsize;
            g2 = +gsize;
            nd -= g2;
          } else {
            g1 = +gsize;
            g2 = +sgsize;
          }
          if (g1 > 0 && nd > 0) {
            i = nd % g1 || g1;
            intp = intd.substr(0, i);
            for (; i < nd; i += g1)
              intp += gsep + intd.substr(i, g1);
            if (g2 > 0)
              intp += gsep + intd.slice(i);
            if (this.s < 0)
              intp = "-" + intp;
          }
        }
        if (fracp) {
          fgsep = fmt.fractionGroupSeparator;
          if (fgsep == u) {
            fgsep = tfmt.fractionGroupSeparator;
            if (fgsep == u)
              fgsep = cfmt.fractionGroupSeparator;
          }
          if (fgsep) {
            fgsize = fmt.fractionGroupSize;
            if (fgsize == u) {
              fgsize = tfmt.fractionGroupSize;
              if (fgsize == u) {
                fgsize = cfmt.fractionGroupSize;
                if (fgsize == u)
                  fgsize = 0;
              }
            }
            fgsize = +fgsize;
            if (fgsize) {
              fracp = fracp.replace(new RegExp("\\d{" + fgsize + "}\\B", "g"), "$&" + fgsep);
            }
          }
          return intp + dsep + fracp;
        } else {
          return intp;
        }
      };
      Ctor.format = {
        decimalSeparator: ".",
        groupSeparator: ",",
        groupSize: 3,
        secondaryGroupSize: 0,
        fractionGroupSeparator: "",
        fractionGroupSize: 0
      };
      return Ctor;
    }
    if (typeof module !== "undefined" && module.exports)
      module.exports = toFormat;
  }
});

// node_modules/decimal.js-light/decimal.js
var require_decimal = __commonJS({
  "node_modules/decimal.js-light/decimal.js"(exports, module) {
    (function(globalScope) {
      "use strict";
      var MAX_DIGITS = 1e9, Decimal = {
        precision: 20,
        rounding: 4,
        toExpNeg: -7,
        toExpPos: 21,
        LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
      }, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", exponentOutOfRange = decimalError + "Exponent out of range: ", mathfloor = Math.floor, mathpow = Math.pow, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ONE, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE), P = {};
      P.absoluteValue = P.abs = function() {
        var x = new this.constructor(this);
        if (x.s)
          x.s = 1;
        return x;
      };
      P.comparedTo = P.cmp = function(y) {
        var i, j, xdL, ydL, x = this;
        y = new x.constructor(y);
        if (x.s !== y.s)
          return x.s || -y.s;
        if (x.e !== y.e)
          return x.e > y.e ^ x.s < 0 ? 1 : -1;
        xdL = x.d.length;
        ydL = y.d.length;
        for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
          if (x.d[i] !== y.d[i])
            return x.d[i] > y.d[i] ^ x.s < 0 ? 1 : -1;
        }
        return xdL === ydL ? 0 : xdL > ydL ^ x.s < 0 ? 1 : -1;
      };
      P.decimalPlaces = P.dp = function() {
        var x = this, w = x.d.length - 1, dp = (w - x.e) * LOG_BASE;
        w = x.d[w];
        if (w)
          for (; w % 10 == 0; w /= 10)
            dp--;
        return dp < 0 ? 0 : dp;
      };
      P.dividedBy = P.div = function(y) {
        return divide(this, new this.constructor(y));
      };
      P.dividedToIntegerBy = P.idiv = function(y) {
        var x = this, Ctor = x.constructor;
        return round(divide(x, new Ctor(y), 0, 1), Ctor.precision);
      };
      P.equals = P.eq = function(y) {
        return !this.cmp(y);
      };
      P.exponent = function() {
        return getBase10Exponent(this);
      };
      P.greaterThan = P.gt = function(y) {
        return this.cmp(y) > 0;
      };
      P.greaterThanOrEqualTo = P.gte = function(y) {
        return this.cmp(y) >= 0;
      };
      P.isInteger = P.isint = function() {
        return this.e > this.d.length - 2;
      };
      P.isNegative = P.isneg = function() {
        return this.s < 0;
      };
      P.isPositive = P.ispos = function() {
        return this.s > 0;
      };
      P.isZero = function() {
        return this.s === 0;
      };
      P.lessThan = P.lt = function(y) {
        return this.cmp(y) < 0;
      };
      P.lessThanOrEqualTo = P.lte = function(y) {
        return this.cmp(y) < 1;
      };
      P.logarithm = P.log = function(base) {
        var r, x = this, Ctor = x.constructor, pr = Ctor.precision, wpr = pr + 5;
        if (base === void 0) {
          base = new Ctor(10);
        } else {
          base = new Ctor(base);
          if (base.s < 1 || base.eq(ONE))
            throw Error(decimalError + "NaN");
        }
        if (x.s < 1)
          throw Error(decimalError + (x.s ? "NaN" : "-Infinity"));
        if (x.eq(ONE))
          return new Ctor(0);
        external = false;
        r = divide(ln(x, wpr), ln(base, wpr), wpr);
        external = true;
        return round(r, pr);
      };
      P.minus = P.sub = function(y) {
        var x = this;
        y = new x.constructor(y);
        return x.s == y.s ? subtract(x, y) : add(x, (y.s = -y.s, y));
      };
      P.modulo = P.mod = function(y) {
        var q, x = this, Ctor = x.constructor, pr = Ctor.precision;
        y = new Ctor(y);
        if (!y.s)
          throw Error(decimalError + "NaN");
        if (!x.s)
          return round(new Ctor(x), pr);
        external = false;
        q = divide(x, y, 0, 1).times(y);
        external = true;
        return x.minus(q);
      };
      P.naturalExponential = P.exp = function() {
        return exp(this);
      };
      P.naturalLogarithm = P.ln = function() {
        return ln(this);
      };
      P.negated = P.neg = function() {
        var x = new this.constructor(this);
        x.s = -x.s || 0;
        return x;
      };
      P.plus = P.add = function(y) {
        var x = this;
        y = new x.constructor(y);
        return x.s == y.s ? add(x, y) : subtract(x, (y.s = -y.s, y));
      };
      P.precision = P.sd = function(z) {
        var e, sd, w, x = this;
        if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
          throw Error(invalidArgument + z);
        e = getBase10Exponent(x) + 1;
        w = x.d.length - 1;
        sd = w * LOG_BASE + 1;
        w = x.d[w];
        if (w) {
          for (; w % 10 == 0; w /= 10)
            sd--;
          for (w = x.d[0]; w >= 10; w /= 10)
            sd++;
        }
        return z && e > sd ? e : sd;
      };
      P.squareRoot = P.sqrt = function() {
        var e, n, pr, r, s, t, wpr, x = this, Ctor = x.constructor;
        if (x.s < 1) {
          if (!x.s)
            return new Ctor(0);
          throw Error(decimalError + "NaN");
        }
        e = getBase10Exponent(x);
        external = false;
        s = Math.sqrt(+x);
        if (s == 0 || s == 1 / 0) {
          n = digitsToString(x.d);
          if ((n.length + e) % 2 == 0)
            n += "0";
          s = Math.sqrt(n);
          e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new Ctor(n);
        } else {
          r = new Ctor(s.toString());
        }
        pr = Ctor.precision;
        s = wpr = pr + 3;
        for (; ; ) {
          t = r;
          r = t.plus(divide(x, t, wpr + 2)).times(0.5);
          if (digitsToString(t.d).slice(0, wpr) === (n = digitsToString(r.d)).slice(0, wpr)) {
            n = n.slice(wpr - 3, wpr + 1);
            if (s == wpr && n == "4999") {
              round(t, pr + 1, 0);
              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            } else if (n != "9999") {
              break;
            }
            wpr += 4;
          }
        }
        external = true;
        return round(r, pr);
      };
      P.times = P.mul = function(y) {
        var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
        if (!x.s || !y.s)
          return new Ctor(0);
        y.s *= x.s;
        e = x.e + y.e;
        xdL = xd.length;
        ydL = yd.length;
        if (xdL < ydL) {
          r = xd;
          xd = yd;
          yd = r;
          rL = xdL;
          xdL = ydL;
          ydL = rL;
        }
        r = [];
        rL = xdL + ydL;
        for (i = rL; i--; )
          r.push(0);
        for (i = ydL; --i >= 0; ) {
          carry = 0;
          for (k = xdL + i; k > i; ) {
            t = r[k] + yd[i] * xd[k - i - 1] + carry;
            r[k--] = t % BASE | 0;
            carry = t / BASE | 0;
          }
          r[k] = (r[k] + carry) % BASE | 0;
        }
        for (; !r[--rL]; )
          r.pop();
        if (carry)
          ++e;
        else
          r.shift();
        y.d = r;
        y.e = e;
        return external ? round(y, Ctor.precision) : y;
      };
      P.toDecimalPlaces = P.todp = function(dp, rm) {
        var x = this, Ctor = x.constructor;
        x = new Ctor(x);
        if (dp === void 0)
          return x;
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
        return round(x, dp + getBase10Exponent(x) + 1, rm);
      };
      P.toExponential = function(dp, rm) {
        var str, x = this, Ctor = x.constructor;
        if (dp === void 0) {
          str = toString(x, true);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt32(rm, 0, 8);
          x = round(new Ctor(x), dp + 1, rm);
          str = toString(x, true, dp + 1);
        }
        return str;
      };
      P.toFixed = function(dp, rm) {
        var str, y, x = this, Ctor = x.constructor;
        if (dp === void 0)
          return toString(x);
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
        y = round(new Ctor(x), dp + getBase10Exponent(x) + 1, rm);
        str = toString(y.abs(), false, dp + getBase10Exponent(y) + 1);
        return x.isneg() && !x.isZero() ? "-" + str : str;
      };
      P.toInteger = P.toint = function() {
        var x = this, Ctor = x.constructor;
        return round(new Ctor(x), getBase10Exponent(x) + 1, Ctor.rounding);
      };
      P.toNumber = function() {
        return +this;
      };
      P.toPower = P.pow = function(y) {
        var e, k, pr, r, sign, yIsInt, x = this, Ctor = x.constructor, guard = 12, yn = +(y = new Ctor(y));
        if (!y.s)
          return new Ctor(ONE);
        x = new Ctor(x);
        if (!x.s) {
          if (y.s < 1)
            throw Error(decimalError + "Infinity");
          return x;
        }
        if (x.eq(ONE))
          return x;
        pr = Ctor.precision;
        if (y.eq(ONE))
          return round(x, pr);
        e = y.e;
        k = y.d.length - 1;
        yIsInt = e >= k;
        sign = x.s;
        if (!yIsInt) {
          if (sign < 0)
            throw Error(decimalError + "NaN");
        } else if ((k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
          r = new Ctor(ONE);
          e = Math.ceil(pr / LOG_BASE + 4);
          external = false;
          for (; ; ) {
            if (k % 2) {
              r = r.times(x);
              truncate(r.d, e);
            }
            k = mathfloor(k / 2);
            if (k === 0)
              break;
            x = x.times(x);
            truncate(x.d, e);
          }
          external = true;
          return y.s < 0 ? new Ctor(ONE).div(r) : round(r, pr);
        }
        sign = sign < 0 && y.d[Math.max(e, k)] & 1 ? -1 : 1;
        x.s = 1;
        external = false;
        r = y.times(ln(x, pr + guard));
        external = true;
        r = exp(r);
        r.s = sign;
        return r;
      };
      P.toPrecision = function(sd, rm) {
        var e, str, x = this, Ctor = x.constructor;
        if (sd === void 0) {
          e = getBase10Exponent(x);
          str = toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
        } else {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt32(rm, 0, 8);
          x = round(new Ctor(x), sd, rm);
          e = getBase10Exponent(x);
          str = toString(x, sd <= e || e <= Ctor.toExpNeg, sd);
        }
        return str;
      };
      P.toSignificantDigits = P.tosd = function(sd, rm) {
        var x = this, Ctor = x.constructor;
        if (sd === void 0) {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        } else {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0)
            rm = Ctor.rounding;
          else
            checkInt32(rm, 0, 8);
        }
        return round(new Ctor(x), sd, rm);
      };
      P.toString = P.valueOf = P.val = P.toJSON = function() {
        var x = this, e = getBase10Exponent(x), Ctor = x.constructor;
        return toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
      };
      function add(x, y) {
        var carry, d, e, i, k, len, xd, yd, Ctor = x.constructor, pr = Ctor.precision;
        if (!x.s || !y.s) {
          if (!y.s)
            y = new Ctor(x);
          return external ? round(y, pr) : y;
        }
        xd = x.d;
        yd = y.d;
        k = x.e;
        e = y.e;
        xd = xd.slice();
        i = k - e;
        if (i) {
          if (i < 0) {
            d = xd;
            i = -i;
            len = yd.length;
          } else {
            d = yd;
            e = k;
            len = xd.length;
          }
          k = Math.ceil(pr / LOG_BASE);
          len = k > len ? k + 1 : len + 1;
          if (i > len) {
            i = len;
            d.length = 1;
          }
          d.reverse();
          for (; i--; )
            d.push(0);
          d.reverse();
        }
        len = xd.length;
        i = yd.length;
        if (len - i < 0) {
          i = len;
          d = yd;
          yd = xd;
          xd = d;
        }
        for (carry = 0; i; ) {
          carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
          xd[i] %= BASE;
        }
        if (carry) {
          xd.unshift(carry);
          ++e;
        }
        for (len = xd.length; xd[--len] == 0; )
          xd.pop();
        y.d = xd;
        y.e = e;
        return external ? round(y, pr) : y;
      }
      function checkInt32(i, min, max) {
        if (i !== ~~i || i < min || i > max) {
          throw Error(invalidArgument + i);
        }
      }
      function digitsToString(d) {
        var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
        if (indexOfLastWord > 0) {
          str += w;
          for (i = 1; i < indexOfLastWord; i++) {
            ws = d[i] + "";
            k = LOG_BASE - ws.length;
            if (k)
              str += getZeroString(k);
            str += ws;
          }
          w = d[i];
          ws = w + "";
          k = LOG_BASE - ws.length;
          if (k)
            str += getZeroString(k);
        } else if (w === 0) {
          return "0";
        }
        for (; w % 10 === 0; )
          w /= 10;
        return str + w;
      }
      var divide = function() {
        function multiplyInteger(x, k) {
          var temp, carry = 0, i = x.length;
          for (x = x.slice(); i--; ) {
            temp = x[i] * k + carry;
            x[i] = temp % BASE | 0;
            carry = temp / BASE | 0;
          }
          if (carry)
            x.unshift(carry);
          return x;
        }
        function compare(a, b, aL, bL) {
          var i, r;
          if (aL != bL) {
            r = aL > bL ? 1 : -1;
          } else {
            for (i = r = 0; i < aL; i++) {
              if (a[i] != b[i]) {
                r = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }
          return r;
        }
        function subtract2(a, b, aL) {
          var i = 0;
          for (; aL--; ) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * BASE + a[aL] - b[aL];
          }
          for (; !a[0] && a.length > 1; )
            a.shift();
        }
        return function(x, y, pr, dp) {
          var cmp, e, i, k, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
          if (!x.s)
            return new Ctor(x);
          if (!y.s)
            throw Error(decimalError + "Division by zero");
          e = x.e - y.e;
          yL = yd.length;
          xL = xd.length;
          q = new Ctor(sign);
          qd = q.d = [];
          for (i = 0; yd[i] == (xd[i] || 0); )
            ++i;
          if (yd[i] > (xd[i] || 0))
            --e;
          if (pr == null) {
            sd = pr = Ctor.precision;
          } else if (dp) {
            sd = pr + (getBase10Exponent(x) - getBase10Exponent(y)) + 1;
          } else {
            sd = pr;
          }
          if (sd < 0)
            return new Ctor(0);
          sd = sd / LOG_BASE + 2 | 0;
          i = 0;
          if (yL == 1) {
            k = 0;
            yd = yd[0];
            sd++;
            for (; (i < xL || k) && sd--; i++) {
              t = k * BASE + (xd[i] || 0);
              qd[i] = t / yd | 0;
              k = t % yd | 0;
            }
          } else {
            k = BASE / (yd[0] + 1) | 0;
            if (k > 1) {
              yd = multiplyInteger(yd, k);
              xd = multiplyInteger(xd, k);
              yL = yd.length;
              xL = xd.length;
            }
            xi = yL;
            rem = xd.slice(0, yL);
            remL = rem.length;
            for (; remL < yL; )
              rem[remL++] = 0;
            yz = yd.slice();
            yz.unshift(0);
            yd0 = yd[0];
            if (yd[1] >= BASE / 2)
              ++yd0;
            do {
              k = 0;
              cmp = compare(yd, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL)
                  rem0 = rem0 * BASE + (rem[1] || 0);
                k = rem0 / yd0 | 0;
                if (k > 1) {
                  if (k >= BASE)
                    k = BASE - 1;
                  prod = multiplyInteger(yd, k);
                  prodL = prod.length;
                  remL = rem.length;
                  cmp = compare(prod, rem, prodL, remL);
                  if (cmp == 1) {
                    k--;
                    subtract2(prod, yL < prodL ? yz : yd, prodL);
                  }
                } else {
                  if (k == 0)
                    cmp = k = 1;
                  prod = yd.slice();
                }
                prodL = prod.length;
                if (prodL < remL)
                  prod.unshift(0);
                subtract2(rem, prod, remL);
                if (cmp == -1) {
                  remL = rem.length;
                  cmp = compare(yd, rem, yL, remL);
                  if (cmp < 1) {
                    k++;
                    subtract2(rem, yL < remL ? yz : yd, remL);
                  }
                }
                remL = rem.length;
              } else if (cmp === 0) {
                k++;
                rem = [0];
              }
              qd[i++] = k;
              if (cmp && rem[0]) {
                rem[remL++] = xd[xi] || 0;
              } else {
                rem = [xd[xi]];
                remL = 1;
              }
            } while ((xi++ < xL || rem[0] !== void 0) && sd--);
          }
          if (!qd[0])
            qd.shift();
          q.e = e;
          return round(q, dp ? pr + getBase10Exponent(q) + 1 : pr);
        };
      }();
      function exp(x, sd) {
        var denominator, guard, pow, sum, t, wpr, i = 0, k = 0, Ctor = x.constructor, pr = Ctor.precision;
        if (getBase10Exponent(x) > 16)
          throw Error(exponentOutOfRange + getBase10Exponent(x));
        if (!x.s)
          return new Ctor(ONE);
        if (sd == null) {
          external = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        t = new Ctor(0.03125);
        while (x.abs().gte(0.1)) {
          x = x.times(t);
          k += 5;
        }
        guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
        wpr += guard;
        denominator = pow = sum = new Ctor(ONE);
        Ctor.precision = wpr;
        for (; ; ) {
          pow = round(pow.times(x), wpr);
          denominator = denominator.times(++i);
          t = sum.plus(divide(pow, denominator, wpr));
          if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
            while (k--)
              sum = round(sum.times(sum), wpr);
            Ctor.precision = pr;
            return sd == null ? (external = true, round(sum, pr)) : sum;
          }
          sum = t;
        }
      }
      function getBase10Exponent(x) {
        var e = x.e * LOG_BASE, w = x.d[0];
        for (; w >= 10; w /= 10)
          e++;
        return e;
      }
      function getLn10(Ctor, sd, pr) {
        if (sd > Ctor.LN10.sd()) {
          external = true;
          if (pr)
            Ctor.precision = pr;
          throw Error(decimalError + "LN10 precision limit exceeded");
        }
        return round(new Ctor(Ctor.LN10), sd);
      }
      function getZeroString(k) {
        var zs = "";
        for (; k--; )
          zs += "0";
        return zs;
      }
      function ln(y, sd) {
        var c, c0, denominator, e, numerator, sum, t, wpr, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, pr = Ctor.precision;
        if (x.s < 1)
          throw Error(decimalError + (x.s ? "NaN" : "-Infinity"));
        if (x.eq(ONE))
          return new Ctor(0);
        if (sd == null) {
          external = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        if (x.eq(10)) {
          if (sd == null)
            external = true;
          return getLn10(Ctor, wpr);
        }
        wpr += guard;
        Ctor.precision = wpr;
        c = digitsToString(xd);
        c0 = c.charAt(0);
        e = getBase10Exponent(x);
        if (Math.abs(e) < 15e14) {
          while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
            x = x.times(y);
            c = digitsToString(x.d);
            c0 = c.charAt(0);
            n++;
          }
          e = getBase10Exponent(x);
          if (c0 > 1) {
            x = new Ctor("0." + c);
            e++;
          } else {
            x = new Ctor(c0 + "." + c.slice(1));
          }
        } else {
          t = getLn10(Ctor, wpr + 2, pr).times(e + "");
          x = ln(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
          Ctor.precision = pr;
          return sd == null ? (external = true, round(x, pr)) : x;
        }
        sum = numerator = x = divide(x.minus(ONE), x.plus(ONE), wpr);
        x2 = round(x.times(x), wpr);
        denominator = 3;
        for (; ; ) {
          numerator = round(numerator.times(x2), wpr);
          t = sum.plus(divide(numerator, new Ctor(denominator), wpr));
          if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
            sum = sum.times(2);
            if (e !== 0)
              sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
            sum = divide(sum, new Ctor(n), wpr);
            Ctor.precision = pr;
            return sd == null ? (external = true, round(sum, pr)) : sum;
          }
          sum = t;
          denominator += 2;
        }
      }
      function parseDecimal(x, str) {
        var e, i, len;
        if ((e = str.indexOf(".")) > -1)
          str = str.replace(".", "");
        if ((i = str.search(/e/i)) > 0) {
          if (e < 0)
            e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {
          e = str.length;
        }
        for (i = 0; str.charCodeAt(i) === 48; )
          ++i;
        for (len = str.length; str.charCodeAt(len - 1) === 48; )
          --len;
        str = str.slice(i, len);
        if (str) {
          len -= i;
          e = e - i - 1;
          x.e = mathfloor(e / LOG_BASE);
          x.d = [];
          i = (e + 1) % LOG_BASE;
          if (e < 0)
            i += LOG_BASE;
          if (i < len) {
            if (i)
              x.d.push(+str.slice(0, i));
            for (len -= LOG_BASE; i < len; )
              x.d.push(+str.slice(i, i += LOG_BASE));
            str = str.slice(i);
            i = LOG_BASE - str.length;
          } else {
            i -= len;
          }
          for (; i--; )
            str += "0";
          x.d.push(+str);
          if (external && (x.e > MAX_E || x.e < -MAX_E))
            throw Error(exponentOutOfRange + e);
        } else {
          x.s = 0;
          x.e = 0;
          x.d = [0];
        }
        return x;
      }
      function round(x, sd, rm) {
        var i, j, k, n, rd, doRound, w, xdi, xd = x.d;
        for (n = 1, k = xd[0]; k >= 10; k /= 10)
          n++;
        i = sd - n;
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          w = xd[xdi = 0];
        } else {
          xdi = Math.ceil((i + 1) / LOG_BASE);
          k = xd.length;
          if (xdi >= k)
            return x;
          w = k = xd[xdi];
          for (n = 1; k >= 10; k /= 10)
            n++;
          i %= LOG_BASE;
          j = i - LOG_BASE + n;
        }
        if (rm !== void 0) {
          k = mathpow(10, n - j - 1);
          rd = w / k % 10 | 0;
          doRound = sd < 0 || xd[xdi + 1] !== void 0 || w % k;
          doRound = rm < 4 ? (rd || doRound) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, n - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        }
        if (sd < 1 || !xd[0]) {
          if (doRound) {
            k = getBase10Exponent(x);
            xd.length = 1;
            sd = sd - k - 1;
            xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
            x.e = mathfloor(-sd / LOG_BASE) || 0;
          } else {
            xd.length = 1;
            xd[0] = x.e = x.s = 0;
          }
          return x;
        }
        if (i == 0) {
          xd.length = xdi;
          k = 1;
          xdi--;
        } else {
          xd.length = xdi + 1;
          k = mathpow(10, LOG_BASE - i);
          xd[xdi] = j > 0 ? (w / mathpow(10, n - j) % mathpow(10, j) | 0) * k : 0;
        }
        if (doRound) {
          for (; ; ) {
            if (xdi == 0) {
              if ((xd[0] += k) == BASE) {
                xd[0] = 1;
                ++x.e;
              }
              break;
            } else {
              xd[xdi] += k;
              if (xd[xdi] != BASE)
                break;
              xd[xdi--] = 0;
              k = 1;
            }
          }
        }
        for (i = xd.length; xd[--i] === 0; )
          xd.pop();
        if (external && (x.e > MAX_E || x.e < -MAX_E)) {
          throw Error(exponentOutOfRange + getBase10Exponent(x));
        }
        return x;
      }
      function subtract(x, y) {
        var d, e, i, j, k, len, xd, xe, xLTy, yd, Ctor = x.constructor, pr = Ctor.precision;
        if (!x.s || !y.s) {
          if (y.s)
            y.s = -y.s;
          else
            y = new Ctor(x);
          return external ? round(y, pr) : y;
        }
        xd = x.d;
        yd = y.d;
        e = y.e;
        xe = x.e;
        xd = xd.slice();
        k = xe - e;
        if (k) {
          xLTy = k < 0;
          if (xLTy) {
            d = xd;
            k = -k;
            len = yd.length;
          } else {
            d = yd;
            e = xe;
            len = xd.length;
          }
          i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
          if (k > i) {
            k = i;
            d.length = 1;
          }
          d.reverse();
          for (i = k; i--; )
            d.push(0);
          d.reverse();
        } else {
          i = xd.length;
          len = yd.length;
          xLTy = i < len;
          if (xLTy)
            len = i;
          for (i = 0; i < len; i++) {
            if (xd[i] != yd[i]) {
              xLTy = xd[i] < yd[i];
              break;
            }
          }
          k = 0;
        }
        if (xLTy) {
          d = xd;
          xd = yd;
          yd = d;
          y.s = -y.s;
        }
        len = xd.length;
        for (i = yd.length - len; i > 0; --i)
          xd[len++] = 0;
        for (i = yd.length; i > k; ) {
          if (xd[--i] < yd[i]) {
            for (j = i; j && xd[--j] === 0; )
              xd[j] = BASE - 1;
            --xd[j];
            xd[i] += BASE;
          }
          xd[i] -= yd[i];
        }
        for (; xd[--len] === 0; )
          xd.pop();
        for (; xd[0] === 0; xd.shift())
          --e;
        if (!xd[0])
          return new Ctor(0);
        y.d = xd;
        y.e = e;
        return external ? round(y, pr) : y;
      }
      function toString(x, isExp, sd) {
        var k, e = getBase10Exponent(x), str = digitsToString(x.d), len = str.length;
        if (isExp) {
          if (sd && (k = sd - len) > 0) {
            str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
          } else if (len > 1) {
            str = str.charAt(0) + "." + str.slice(1);
          }
          str = str + (e < 0 ? "e" : "e+") + e;
        } else if (e < 0) {
          str = "0." + getZeroString(-e - 1) + str;
          if (sd && (k = sd - len) > 0)
            str += getZeroString(k);
        } else if (e >= len) {
          str += getZeroString(e + 1 - len);
          if (sd && (k = sd - e - 1) > 0)
            str = str + "." + getZeroString(k);
        } else {
          if ((k = e + 1) < len)
            str = str.slice(0, k) + "." + str.slice(k);
          if (sd && (k = sd - len) > 0) {
            if (e + 1 === len)
              str += ".";
            str += getZeroString(k);
          }
        }
        return x.s < 0 ? "-" + str : str;
      }
      function truncate(arr, len) {
        if (arr.length > len) {
          arr.length = len;
          return true;
        }
      }
      function clone(obj) {
        var i, p, ps;
        function Decimal2(value) {
          var x = this;
          if (!(x instanceof Decimal2))
            return new Decimal2(value);
          x.constructor = Decimal2;
          if (value instanceof Decimal2) {
            x.s = value.s;
            x.e = value.e;
            x.d = (value = value.d) ? value.slice() : value;
            return;
          }
          if (typeof value === "number") {
            if (value * 0 !== 0) {
              throw Error(invalidArgument + value);
            }
            if (value > 0) {
              x.s = 1;
            } else if (value < 0) {
              value = -value;
              x.s = -1;
            } else {
              x.s = 0;
              x.e = 0;
              x.d = [0];
              return;
            }
            if (value === ~~value && value < 1e7) {
              x.e = 0;
              x.d = [value];
              return;
            }
            return parseDecimal(x, value.toString());
          } else if (typeof value !== "string") {
            throw Error(invalidArgument + value);
          }
          if (value.charCodeAt(0) === 45) {
            value = value.slice(1);
            x.s = -1;
          } else {
            x.s = 1;
          }
          if (isDecimal.test(value))
            parseDecimal(x, value);
          else
            throw Error(invalidArgument + value);
        }
        Decimal2.prototype = P;
        Decimal2.ROUND_UP = 0;
        Decimal2.ROUND_DOWN = 1;
        Decimal2.ROUND_CEIL = 2;
        Decimal2.ROUND_FLOOR = 3;
        Decimal2.ROUND_HALF_UP = 4;
        Decimal2.ROUND_HALF_DOWN = 5;
        Decimal2.ROUND_HALF_EVEN = 6;
        Decimal2.ROUND_HALF_CEIL = 7;
        Decimal2.ROUND_HALF_FLOOR = 8;
        Decimal2.clone = clone;
        Decimal2.config = Decimal2.set = config;
        if (obj === void 0)
          obj = {};
        if (obj) {
          ps = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"];
          for (i = 0; i < ps.length; )
            if (!obj.hasOwnProperty(p = ps[i++]))
              obj[p] = this[p];
        }
        Decimal2.config(obj);
        return Decimal2;
      }
      function config(obj) {
        if (!obj || typeof obj !== "object") {
          throw Error(decimalError + "Object expected");
        }
        var i, p, v, ps = [
          "precision",
          1,
          MAX_DIGITS,
          "rounding",
          0,
          8,
          "toExpNeg",
          -1 / 0,
          0,
          "toExpPos",
          0,
          1 / 0
        ];
        for (i = 0; i < ps.length; i += 3) {
          if ((v = obj[p = ps[i]]) !== void 0) {
            if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
              this[p] = v;
            else
              throw Error(invalidArgument + p + ": " + v);
          }
        }
        if ((v = obj[p = "LN10"]) !== void 0) {
          if (v == Math.LN10)
            this[p] = new this(v);
          else
            throw Error(invalidArgument + p + ": " + v);
        }
        return this;
      }
      Decimal = clone(Decimal);
      Decimal["default"] = Decimal.Decimal = Decimal;
      ONE = new Decimal(1);
      if (typeof define == "function" && define.amd) {
        define(function() {
          return Decimal;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = Decimal;
      } else {
        if (!globalScope) {
          globalScope = typeof self != "undefined" && self && self.self == self ? self : Function("return this")();
        }
        globalScope.Decimal = Decimal;
      }
    })(exports);
  }
});

// node_modules/big.js/big.js
var require_big = __commonJS({
  "node_modules/big.js/big.js"(exports, module) {
    (function(GLOBAL) {
      "use strict";
      var Big, DP = 20, RM = 1, MAX_DP = 1e6, MAX_POWER = 1e6, NE = -7, PE = 21, STRICT = false, NAME = "[big.js] ", INVALID = NAME + "Invalid ", INVALID_DP = INVALID + "decimal places", INVALID_RM = INVALID + "rounding mode", DIV_BY_ZERO = NAME + "Division by zero", P = {}, UNDEFINED = void 0, NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
      function _Big_() {
        function Big2(n) {
          var x = this;
          if (!(x instanceof Big2))
            return n === UNDEFINED ? _Big_() : new Big2(n);
          if (n instanceof Big2) {
            x.s = n.s;
            x.e = n.e;
            x.c = n.c.slice();
          } else {
            if (typeof n !== "string") {
              if (Big2.strict === true && typeof n !== "bigint") {
                throw TypeError(INVALID + "value");
              }
              n = n === 0 && 1 / n < 0 ? "-0" : String(n);
            }
            parse(x, n);
          }
          x.constructor = Big2;
        }
        Big2.prototype = P;
        Big2.DP = DP;
        Big2.RM = RM;
        Big2.NE = NE;
        Big2.PE = PE;
        Big2.strict = STRICT;
        Big2.roundDown = 0;
        Big2.roundHalfUp = 1;
        Big2.roundHalfEven = 2;
        Big2.roundUp = 3;
        return Big2;
      }
      function parse(x, n) {
        var e, i, nl;
        if (!NUMERIC.test(n)) {
          throw Error(INVALID + "number");
        }
        x.s = n.charAt(0) == "-" ? (n = n.slice(1), -1) : 1;
        if ((e = n.indexOf(".")) > -1)
          n = n.replace(".", "");
        if ((i = n.search(/e/i)) > 0) {
          if (e < 0)
            e = i;
          e += +n.slice(i + 1);
          n = n.substring(0, i);
        } else if (e < 0) {
          e = n.length;
        }
        nl = n.length;
        for (i = 0; i < nl && n.charAt(i) == "0"; )
          ++i;
        if (i == nl) {
          x.c = [x.e = 0];
        } else {
          for (; nl > 0 && n.charAt(--nl) == "0"; )
            ;
          x.e = e - i - 1;
          x.c = [];
          for (e = 0; i <= nl; )
            x.c[e++] = +n.charAt(i++);
        }
        return x;
      }
      function round(x, sd, rm, more) {
        var xc = x.c;
        if (rm === UNDEFINED)
          rm = x.constructor.RM;
        if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {
          throw Error(INVALID_RM);
        }
        if (sd < 1) {
          more = rm === 3 && (more || !!xc[0]) || sd === 0 && (rm === 1 && xc[0] >= 5 || rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED)));
          xc.length = 1;
          if (more) {
            x.e = x.e - sd + 1;
            xc[0] = 1;
          } else {
            xc[0] = x.e = 0;
          }
        } else if (sd < xc.length) {
          more = rm === 1 && xc[sd] >= 5 || rm === 2 && (xc[sd] > 5 || xc[sd] === 5 && (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) || rm === 3 && (more || !!xc[0]);
          xc.length = sd;
          if (more) {
            for (; ++xc[--sd] > 9; ) {
              xc[sd] = 0;
              if (sd === 0) {
                ++x.e;
                xc.unshift(1);
                break;
              }
            }
          }
          for (sd = xc.length; !xc[--sd]; )
            xc.pop();
        }
        return x;
      }
      function stringify(x, doExponential, isNonzero) {
        var e = x.e, s = x.c.join(""), n = s.length;
        if (doExponential) {
          s = s.charAt(0) + (n > 1 ? "." + s.slice(1) : "") + (e < 0 ? "e" : "e+") + e;
        } else if (e < 0) {
          for (; ++e; )
            s = "0" + s;
          s = "0." + s;
        } else if (e > 0) {
          if (++e > n) {
            for (e -= n; e--; )
              s += "0";
          } else if (e < n) {
            s = s.slice(0, e) + "." + s.slice(e);
          }
        } else if (n > 1) {
          s = s.charAt(0) + "." + s.slice(1);
        }
        return x.s < 0 && isNonzero ? "-" + s : s;
      }
      P.abs = function() {
        var x = new this.constructor(this);
        x.s = 1;
        return x;
      };
      P.cmp = function(y) {
        var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!xc[0] || !yc[0])
          return !xc[0] ? !yc[0] ? 0 : -j : i;
        if (i != j)
          return i;
        isneg = i < 0;
        if (k != l)
          return k > l ^ isneg ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = -1; ++i < j; ) {
          if (xc[i] != yc[i])
            return xc[i] > yc[i] ^ isneg ? 1 : -1;
        }
        return k == l ? 0 : k > l ^ isneg ? 1 : -1;
      };
      P.div = function(y) {
        var x = this, Big2 = x.constructor, a = x.c, b = (y = new Big2(y)).c, k = x.s == y.s ? 1 : -1, dp = Big2.DP;
        if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
          throw Error(INVALID_DP);
        }
        if (!b[0]) {
          throw Error(DIV_BY_ZERO);
        }
        if (!a[0]) {
          y.s = k;
          y.c = [y.e = 0];
          return y;
        }
        var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, p = dp + (q.e = x.e - y.e) + 1;
        q.s = k;
        k = p < 0 ? 0 : p;
        bz.unshift(0);
        for (; rl++ < bl; )
          r.push(0);
        do {
          for (n = 0; n < 10; n++) {
            if (bl != (rl = r.length)) {
              cmp = bl > rl ? 1 : -1;
            } else {
              for (ri = -1, cmp = 0; ++ri < bl; ) {
                if (b[ri] != r[ri]) {
                  cmp = b[ri] > r[ri] ? 1 : -1;
                  break;
                }
              }
            }
            if (cmp < 0) {
              for (bt = rl == bl ? b : bz; rl; ) {
                if (r[--rl] < bt[rl]) {
                  ri = rl;
                  for (; ri && !r[--ri]; )
                    r[ri] = 9;
                  --r[ri];
                  r[rl] += 10;
                }
                r[rl] -= bt[rl];
              }
              for (; !r[0]; )
                r.shift();
            } else {
              break;
            }
          }
          qc[qi++] = cmp ? n : ++n;
          if (r[0] && cmp)
            r[rl] = a[ai] || 0;
          else
            r = [a[ai]];
        } while ((ai++ < al || r[0] !== UNDEFINED) && k--);
        if (!qc[0] && qi != 1) {
          qc.shift();
          q.e--;
          p--;
        }
        if (qi > p)
          round(q, p, Big2.RM, r[0] !== UNDEFINED);
        return q;
      };
      P.eq = function(y) {
        return this.cmp(y) === 0;
      };
      P.gt = function(y) {
        return this.cmp(y) > 0;
      };
      P.gte = function(y) {
        return this.cmp(y) > -1;
      };
      P.lt = function(y) {
        return this.cmp(y) < 0;
      };
      P.lte = function(y) {
        return this.cmp(y) < 1;
      };
      P.minus = P.sub = function(y) {
        var i, j, t, xlty, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
        if (a != b) {
          y.s = -b;
          return x.plus(y);
        }
        var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;
        if (!xc[0] || !yc[0]) {
          if (yc[0]) {
            y.s = -b;
          } else if (xc[0]) {
            y = new Big2(x);
          } else {
            y.s = 1;
          }
          return y;
        }
        if (a = xe - ye) {
          if (xlty = a < 0) {
            a = -a;
            t = xc;
          } else {
            ye = xe;
            t = yc;
          }
          t.reverse();
          for (b = a; b--; )
            t.push(0);
          t.reverse();
        } else {
          j = ((xlty = xc.length < yc.length) ? xc : yc).length;
          for (a = b = 0; b < j; b++) {
            if (xc[b] != yc[b]) {
              xlty = xc[b] < yc[b];
              break;
            }
          }
        }
        if (xlty) {
          t = xc;
          xc = yc;
          yc = t;
          y.s = -y.s;
        }
        if ((b = (j = yc.length) - (i = xc.length)) > 0)
          for (; b--; )
            xc[i++] = 0;
        for (b = i; j > a; ) {
          if (xc[--j] < yc[j]) {
            for (i = j; i && !xc[--i]; )
              xc[i] = 9;
            --xc[i];
            xc[j] += 10;
          }
          xc[j] -= yc[j];
        }
        for (; xc[--b] === 0; )
          xc.pop();
        for (; xc[0] === 0; ) {
          xc.shift();
          --ye;
        }
        if (!xc[0]) {
          y.s = 1;
          xc = [ye = 0];
        }
        y.c = xc;
        y.e = ye;
        return y;
      };
      P.mod = function(y) {
        var ygtx, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
        if (!y.c[0]) {
          throw Error(DIV_BY_ZERO);
        }
        x.s = y.s = 1;
        ygtx = y.cmp(x) == 1;
        x.s = a;
        y.s = b;
        if (ygtx)
          return new Big2(x);
        a = Big2.DP;
        b = Big2.RM;
        Big2.DP = Big2.RM = 0;
        x = x.div(y);
        Big2.DP = a;
        Big2.RM = b;
        return this.minus(x.times(y));
      };
      P.neg = function() {
        var x = new this.constructor(this);
        x.s = -x.s;
        return x;
      };
      P.plus = P.add = function(y) {
        var e, k, t, x = this, Big2 = x.constructor;
        y = new Big2(y);
        if (x.s != y.s) {
          y.s = -y.s;
          return x.minus(y);
        }
        var xe = x.e, xc = x.c, ye = y.e, yc = y.c;
        if (!xc[0] || !yc[0]) {
          if (!yc[0]) {
            if (xc[0]) {
              y = new Big2(x);
            } else {
              y.s = x.s;
            }
          }
          return y;
        }
        xc = xc.slice();
        if (e = xe - ye) {
          if (e > 0) {
            ye = xe;
            t = yc;
          } else {
            e = -e;
            t = xc;
          }
          t.reverse();
          for (; e--; )
            t.push(0);
          t.reverse();
        }
        if (xc.length - yc.length < 0) {
          t = yc;
          yc = xc;
          xc = t;
        }
        e = yc.length;
        for (k = 0; e; xc[e] %= 10)
          k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;
        if (k) {
          xc.unshift(k);
          ++ye;
        }
        for (e = xc.length; xc[--e] === 0; )
          xc.pop();
        y.c = xc;
        y.e = ye;
        return y;
      };
      P.pow = function(n) {
        var x = this, one = new x.constructor("1"), y = one, isneg = n < 0;
        if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {
          throw Error(INVALID + "exponent");
        }
        if (isneg)
          n = -n;
        for (; ; ) {
          if (n & 1)
            y = y.times(x);
          n >>= 1;
          if (!n)
            break;
          x = x.times(x);
        }
        return isneg ? one.div(y) : y;
      };
      P.prec = function(sd, rm) {
        if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
          throw Error(INVALID + "precision");
        }
        return round(new this.constructor(this), sd, rm);
      };
      P.round = function(dp, rm) {
        if (dp === UNDEFINED)
          dp = 0;
        else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {
          throw Error(INVALID_DP);
        }
        return round(new this.constructor(this), dp + this.e + 1, rm);
      };
      P.sqrt = function() {
        var r, c, t, x = this, Big2 = x.constructor, s = x.s, e = x.e, half = new Big2("0.5");
        if (!x.c[0])
          return new Big2(x);
        if (s < 0) {
          throw Error(NAME + "No square root");
        }
        s = Math.sqrt(x + "");
        if (s === 0 || s === 1 / 0) {
          c = x.c.join("");
          if (!(c.length + e & 1))
            c += "0";
          s = Math.sqrt(c);
          e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
          r = new Big2((s == 1 / 0 ? "5e" : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + e);
        } else {
          r = new Big2(s + "");
        }
        e = r.e + (Big2.DP += 4);
        do {
          t = r;
          r = half.times(t.plus(x.div(t)));
        } while (t.c.slice(0, e).join("") !== r.c.slice(0, e).join(""));
        return round(r, (Big2.DP -= 4) + r.e + 1, Big2.RM);
      };
      P.times = P.mul = function(y) {
        var c, x = this, Big2 = x.constructor, xc = x.c, yc = (y = new Big2(y)).c, a = xc.length, b = yc.length, i = x.e, j = y.e;
        y.s = x.s == y.s ? 1 : -1;
        if (!xc[0] || !yc[0]) {
          y.c = [y.e = 0];
          return y;
        }
        y.e = i + j;
        if (a < b) {
          c = xc;
          xc = yc;
          yc = c;
          j = a;
          a = b;
          b = j;
        }
        for (c = new Array(j = a + b); j--; )
          c[j] = 0;
        for (i = b; i--; ) {
          b = 0;
          for (j = a + i; j > i; ) {
            b = c[j] + yc[i] * xc[j - i - 1] + b;
            c[j--] = b % 10;
            b = b / 10 | 0;
          }
          c[j] = b;
        }
        if (b)
          ++y.e;
        else
          c.shift();
        for (i = c.length; !c[--i]; )
          c.pop();
        y.c = c;
        return y;
      };
      P.toExponential = function(dp, rm) {
        var x = this, n = x.c[0];
        if (dp !== UNDEFINED) {
          if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
            throw Error(INVALID_DP);
          }
          x = round(new x.constructor(x), ++dp, rm);
          for (; x.c.length < dp; )
            x.c.push(0);
        }
        return stringify(x, true, !!n);
      };
      P.toFixed = function(dp, rm) {
        var x = this, n = x.c[0];
        if (dp !== UNDEFINED) {
          if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
            throw Error(INVALID_DP);
          }
          x = round(new x.constructor(x), dp + x.e + 1, rm);
          for (dp = dp + x.e + 1; x.c.length < dp; )
            x.c.push(0);
        }
        return stringify(x, false, !!n);
      };
      P.toJSON = P.toString = function() {
        var x = this, Big2 = x.constructor;
        return stringify(x, x.e <= Big2.NE || x.e >= Big2.PE, !!x.c[0]);
      };
      P.toNumber = function() {
        var n = Number(stringify(this, true, true));
        if (this.constructor.strict === true && !this.eq(n.toString())) {
          throw Error(NAME + "Imprecise conversion");
        }
        return n;
      };
      P.toPrecision = function(sd, rm) {
        var x = this, Big2 = x.constructor, n = x.c[0];
        if (sd !== UNDEFINED) {
          if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
            throw Error(INVALID + "precision");
          }
          x = round(new Big2(x), sd, rm);
          for (; x.c.length < sd; )
            x.c.push(0);
        }
        return stringify(x, sd <= x.e || x.e <= Big2.NE || x.e >= Big2.PE, !!n);
      };
      P.valueOf = function() {
        var x = this, Big2 = x.constructor;
        if (Big2.strict === true) {
          throw Error(NAME + "valueOf disallowed");
        }
        return stringify(x, x.e <= Big2.NE || x.e >= Big2.PE, true);
      };
      Big = _Big_();
      Big["default"] = Big.Big = Big;
      if (typeof define === "function" && define.amd) {
        define(function() {
          return Big;
        });
      } else if (typeof module !== "undefined" && module.exports) {
        module.exports = Big;
      } else {
        GLOBAL.Big = Big;
      }
    })(exports);
  }
});

// node_modules/l0k_swap-sdk/dist/l0k_swap-sdk.cjs.development.js
var require_l0k_swap_sdk_cjs_development = __commonJS({
  "node_modules/l0k_swap-sdk/dist/l0k_swap-sdk.cjs.development.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopDefault(ex) {
      return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
    }
    var JSBI = _interopDefault(require_jsbi_umd());
    var invariant = _interopDefault(require_tiny_invariant_cjs());
    var shortString = require_shortString();
    var constants = require_constants();
    var number = require_number();
    var hash = require_hash();
    var address = require_address();
    var toFormat = _interopDefault(require_toFormat());
    var _Decimal = _interopDefault(require_decimal());
    var _Big = _interopDefault(require_big());
    var uint256 = require_uint256();
    var starknet = require_dist();
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct.bind();
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a = [null];
          a.push.apply(a, args2);
          var Constructor = Function.bind.apply(Parent2, a);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper);
        }
        function Wrapper() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class2.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _createForOfIteratorHelperLoose(o, allowArrayLike) {
      var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
      if (it)
        return (it = it.call(o)).next.bind(it);
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        return function() {
          if (i >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i++]
          };
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var CAN_SET_PROTOTYPE = "setPrototypeOf" in Object;
    var InsufficientReservesError = function(_Error) {
      _inheritsLoose(InsufficientReservesError2, _Error);
      function InsufficientReservesError2() {
        var _this;
        _this = _Error.call(this) || this;
        _this.isInsufficientReservesError = true;
        _this.name = _this.constructor.name;
        if (CAN_SET_PROTOTYPE)
          Object.setPrototypeOf(_assertThisInitialized(_this), (this instanceof InsufficientReservesError2 ? this.constructor : void 0).prototype);
        return _this;
      }
      return InsufficientReservesError2;
    }(_wrapNativeSuper(Error));
    var InsufficientInputAmountError = function(_Error2) {
      _inheritsLoose(InsufficientInputAmountError2, _Error2);
      function InsufficientInputAmountError2() {
        var _this2;
        _this2 = _Error2.call(this) || this;
        _this2.isInsufficientInputAmountError = true;
        _this2.name = _this2.constructor.name;
        if (CAN_SET_PROTOTYPE)
          Object.setPrototypeOf(_assertThisInitialized(_this2), (this instanceof InsufficientInputAmountError2 ? this.constructor : void 0).prototype);
        return _this2;
      }
      return InsufficientInputAmountError2;
    }(_wrapNativeSuper(Error));
    var _SOLIDITY_TYPE_MAXIMA;
    var _FACTORY_ADDRESSES;
    (function(TradeType) {
      TradeType[TradeType["EXACT_INPUT"] = 0] = "EXACT_INPUT";
      TradeType[TradeType["EXACT_OUTPUT"] = 1] = "EXACT_OUTPUT";
    })(exports.TradeType || (exports.TradeType = {}));
    (function(Rounding) {
      Rounding[Rounding["ROUND_DOWN"] = 0] = "ROUND_DOWN";
      Rounding[Rounding["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
      Rounding[Rounding["ROUND_UP"] = 2] = "ROUND_UP";
    })(exports.Rounding || (exports.Rounding = {}));
    var MINIMUM_LIQUIDITY = JSBI.BigInt(1e3);
    var ZERO = JSBI.BigInt(0);
    var ONE = JSBI.BigInt(1);
    var TWO = JSBI.BigInt(2);
    var THREE = JSBI.BigInt(3);
    var FIVE = JSBI.BigInt(5);
    var TEN = JSBI.BigInt(10);
    var _100 = JSBI.BigInt(100);
    var FEES_NUMERATOR = JSBI.BigInt(9970);
    var FEES_DENOMINATOR = JSBI.BigInt(1e4);
    (function(SolidityType) {
      SolidityType["uint8"] = "uint8";
      SolidityType["uint256"] = "uint256";
    })(exports.SolidityType || (exports.SolidityType = {}));
    var SOLIDITY_TYPE_MAXIMA = (_SOLIDITY_TYPE_MAXIMA = {}, _SOLIDITY_TYPE_MAXIMA[exports.SolidityType.uint8] = JSBI.BigInt("0xff"), _SOLIDITY_TYPE_MAXIMA[exports.SolidityType.uint256] = JSBI.BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), _SOLIDITY_TYPE_MAXIMA);
    var PAIR_CONTRACT_CLASS_HASH = "0x231adde42526bad434ca2eb983efdd64472638702f87f97e6e3c084f264e06f";
    var FACTORY_ADDRESSES = (_FACTORY_ADDRESSES = {}, _FACTORY_ADDRESSES[constants.StarknetChainId.MAINNET] = "0x01c0a36e26a8f822e0d81f20a5a562b16a8f8a3dfd99801367dd2aea8f1a87a2", _FACTORY_ADDRESSES[constants.StarknetChainId.TESTNET] = "0x06c31f39524388c982045988de3788530605ed08b10389def2e7b1dd09d19308", _FACTORY_ADDRESSES);
    var CONTRACT_ADDRESS_PREFIX = shortString.encodeShortString("STARKNET_CONTRACT_ADDRESS");
    function validateSolidityTypeInstance(value, solidityType) {
      !JSBI.greaterThanOrEqual(value, ZERO) ? invariant(false, value + " is not a " + solidityType + ".") : void 0;
      !JSBI.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]) ? invariant(false, value + " is not a " + solidityType + ".") : void 0;
    }
    function validateAndParseAddress(address$1) {
      try {
        var checksummedAddress = address.validateAndParseAddress(address$1);
        return checksummedAddress;
      } catch (error) {
        invariant(false, address$1 + " is not a valid address.");
      }
    }
    function parseBigintIsh(bigintIsh) {
      return bigintIsh instanceof JSBI ? bigintIsh : typeof bigintIsh === "bigint" ? JSBI.BigInt(bigintIsh.toString()) : JSBI.BigInt(bigintIsh);
    }
    function sqrt(y) {
      validateSolidityTypeInstance(y, exports.SolidityType.uint256);
      var z = ZERO;
      var x;
      if (JSBI.greaterThan(y, THREE)) {
        z = y;
        x = JSBI.add(JSBI.divide(y, TWO), ONE);
        while (JSBI.lessThan(x, z)) {
          z = x;
          x = JSBI.divide(JSBI.add(JSBI.divide(y, x), x), TWO);
        }
      } else if (JSBI.notEqual(y, ZERO)) {
        z = ONE;
      }
      return z;
    }
    function sortedInsert(items, add, maxSize, comparator) {
      !(maxSize > 0) ? invariant(false, "MAX_SIZE_ZERO") : void 0;
      !(items.length <= maxSize) ? invariant(false, "ITEMS_SIZE") : void 0;
      if (items.length === 0) {
        items.push(add);
        return null;
      } else {
        var _items$pop;
        var isFull = items.length === maxSize;
        if (isFull && comparator(items[items.length - 1], add) <= 0) {
          return add;
        }
        var lo = 0, hi = items.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (comparator(items[mid], add) <= 0) {
            lo = mid + 1;
          } else {
            hi = mid;
          }
        }
        items.splice(lo, 0, add);
        return isFull ? (_items$pop = items.pop()) !== null && _items$pop !== void 0 ? _items$pop : null : null;
      }
    }
    function getPairAddress(tokenA, tokenB) {
      var tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];
      var salt = hash.pedersen([tokens[0].address, tokens[1].address]);
      var constructorCalldataHash = hash.computeHashOnElements([]);
      return hash.computeHashOnElements([CONTRACT_ADDRESS_PREFIX, FACTORY_ADDRESSES[tokenA.chainId], salt, PAIR_CONTRACT_CLASS_HASH, constructorCalldataHash]);
    }
    function isEqualAddress(addressA, addressB) {
      return number.toBN(addressA).eq(number.toBN(addressB));
    }
    function sortsBefore(addressA, addressB) {
      return number.toBN(addressA).lt(number.toBN(addressB));
    }
    var Token = function() {
      function Token2(chainId, address2, decimals, symbol, name) {
        validateSolidityTypeInstance(JSBI.BigInt(decimals), exports.SolidityType.uint8);
        this.decimals = decimals;
        this.symbol = symbol;
        this.name = name;
        this.chainId = chainId;
        this.address = validateAndParseAddress(address2);
      }
      var _proto = Token2.prototype;
      _proto.equals = function equals(other) {
        if (this === other) {
          return true;
        }
        return this.chainId === other.chainId && isEqualAddress(this.address, other.address);
      };
      _proto.sortsBefore = function sortsBefore$1(other) {
        !(this.chainId === other.chainId) ? invariant(false, "CHAIN_IDS") : void 0;
        !(this.address !== other.address) ? invariant(false, "ADDRESSES") : void 0;
        return sortsBefore(this.address, other.address);
      };
      return Token2;
    }();
    function currencyEquals(currencyA, currencyB) {
      if (currencyA instanceof Token && currencyB instanceof Token) {
        return currencyA.equals(currencyB);
      } else if (currencyA instanceof Token) {
        return false;
      } else if (currencyB instanceof Token) {
        return false;
      } else {
        return currencyA === currencyB;
      }
    }
    var _toSignificantRoundin;
    var _toFixedRounding;
    var Decimal = toFormat(_Decimal);
    var Big = toFormat(_Big);
    var toSignificantRounding = (_toSignificantRoundin = {}, _toSignificantRoundin[exports.Rounding.ROUND_DOWN] = Decimal.ROUND_DOWN, _toSignificantRoundin[exports.Rounding.ROUND_HALF_UP] = Decimal.ROUND_HALF_UP, _toSignificantRoundin[exports.Rounding.ROUND_UP] = Decimal.ROUND_UP, _toSignificantRoundin);
    var toFixedRounding = (_toFixedRounding = {}, _toFixedRounding[exports.Rounding.ROUND_DOWN] = 0, _toFixedRounding[exports.Rounding.ROUND_HALF_UP] = 1, _toFixedRounding[exports.Rounding.ROUND_UP] = 3, _toFixedRounding);
    var Fraction = function() {
      function Fraction2(numerator, denominator) {
        if (denominator === void 0) {
          denominator = ONE;
        }
        this.numerator = parseBigintIsh(numerator);
        this.denominator = parseBigintIsh(denominator);
      }
      var _proto = Fraction2.prototype;
      _proto.invert = function invert() {
        return new Fraction2(this.denominator, this.numerator);
      };
      _proto.add = function add(other) {
        var otherParsed = other instanceof Fraction2 ? other : new Fraction2(parseBigintIsh(other));
        if (JSBI.equal(this.denominator, otherParsed.denominator)) {
          return new Fraction2(JSBI.add(this.numerator, otherParsed.numerator), this.denominator);
        }
        return new Fraction2(JSBI.add(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));
      };
      _proto.subtract = function subtract(other) {
        var otherParsed = other instanceof Fraction2 ? other : new Fraction2(parseBigintIsh(other));
        if (JSBI.equal(this.denominator, otherParsed.denominator)) {
          return new Fraction2(JSBI.subtract(this.numerator, otherParsed.numerator), this.denominator);
        }
        return new Fraction2(JSBI.subtract(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator)), JSBI.multiply(this.denominator, otherParsed.denominator));
      };
      _proto.lessThan = function lessThan(other) {
        var otherParsed = other instanceof Fraction2 ? other : new Fraction2(parseBigintIsh(other));
        return JSBI.lessThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
      };
      _proto.equalTo = function equalTo(other) {
        var otherParsed = other instanceof Fraction2 ? other : new Fraction2(parseBigintIsh(other));
        return JSBI.equal(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
      };
      _proto.greaterThan = function greaterThan(other) {
        var otherParsed = other instanceof Fraction2 ? other : new Fraction2(parseBigintIsh(other));
        return JSBI.greaterThan(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(otherParsed.numerator, this.denominator));
      };
      _proto.multiply = function multiply(other) {
        var otherParsed = other instanceof Fraction2 ? other : new Fraction2(parseBigintIsh(other));
        return new Fraction2(JSBI.multiply(this.numerator, otherParsed.numerator), JSBI.multiply(this.denominator, otherParsed.denominator));
      };
      _proto.divide = function divide(other) {
        var otherParsed = other instanceof Fraction2 ? other : new Fraction2(parseBigintIsh(other));
        return new Fraction2(JSBI.multiply(this.numerator, otherParsed.denominator), JSBI.multiply(this.denominator, otherParsed.numerator));
      };
      _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
        if (format === void 0) {
          format = {
            groupSeparator: ""
          };
        }
        if (rounding === void 0) {
          rounding = exports.Rounding.ROUND_HALF_UP;
        }
        !Number.isInteger(significantDigits) ? invariant(false, significantDigits + " is not an integer.") : void 0;
        !(significantDigits > 0) ? invariant(false, significantDigits + " is not positive.") : void 0;
        Decimal.set({
          precision: significantDigits + 1,
          rounding: toSignificantRounding[rounding]
        });
        var quotient = new Decimal(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);
        return quotient.toFormat(quotient.decimalPlaces(), format);
      };
      _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
        if (format === void 0) {
          format = {
            groupSeparator: ""
          };
        }
        if (rounding === void 0) {
          rounding = exports.Rounding.ROUND_HALF_UP;
        }
        !Number.isInteger(decimalPlaces) ? invariant(false, decimalPlaces + " is not an integer.") : void 0;
        !(decimalPlaces >= 0) ? invariant(false, decimalPlaces + " is negative.") : void 0;
        Big.DP = decimalPlaces;
        Big.RM = toFixedRounding[rounding];
        return new Big(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);
      };
      _createClass(Fraction2, [{
        key: "quotient",
        get: function get() {
          return JSBI.divide(this.numerator, this.denominator);
        }
      }, {
        key: "remainder",
        get: function get() {
          return new Fraction2(JSBI.remainder(this.numerator, this.denominator), this.denominator);
        }
      }]);
      return Fraction2;
    }();
    var Big$1 = toFormat(_Big);
    var TokenAmount = function(_Fraction) {
      _inheritsLoose(TokenAmount2, _Fraction);
      function TokenAmount2(token, amount) {
        var _this;
        var parsedAmount = parseBigintIsh(amount);
        validateSolidityTypeInstance(parsedAmount, exports.SolidityType.uint256);
        _this = _Fraction.call(this, parsedAmount, JSBI.exponentiate(TEN, JSBI.BigInt(token.decimals))) || this;
        _this.token = token;
        return _this;
      }
      var _proto = TokenAmount2.prototype;
      _proto.add = function add(other) {
        !this.token.equals(other.token) ? invariant(false, "TOKEN") : void 0;
        return new TokenAmount2(this.token, JSBI.add(this.raw, other.raw));
      };
      _proto.subtract = function subtract(other) {
        !this.token.equals(other.token) ? invariant(false, "TOKEN") : void 0;
        return new TokenAmount2(this.token, JSBI.subtract(this.raw, other.raw));
      };
      _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
        if (significantDigits === void 0) {
          significantDigits = 12;
        }
        if (rounding === void 0) {
          rounding = exports.Rounding.ROUND_DOWN;
        }
        return _Fraction.prototype.toSignificant.call(this, significantDigits, format, rounding);
      };
      _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
        if (decimalPlaces === void 0) {
          decimalPlaces = this.token.decimals;
        }
        if (rounding === void 0) {
          rounding = exports.Rounding.ROUND_DOWN;
        }
        !(decimalPlaces <= this.token.decimals) ? invariant(false, "DECIMALS") : void 0;
        return _Fraction.prototype.toFixed.call(this, decimalPlaces, format, rounding);
      };
      _proto.toExact = function toExact(format) {
        if (format === void 0) {
          format = {
            groupSeparator: ""
          };
        }
        Big$1.DP = this.token.decimals;
        return new Big$1(this.numerator.toString()).div(this.denominator.toString()).toFormat(format);
      };
      _createClass(TokenAmount2, [{
        key: "raw",
        get: function get() {
          return this.numerator;
        }
      }]);
      return TokenAmount2;
    }(Fraction);
    var Price = function(_Fraction) {
      _inheritsLoose(Price2, _Fraction);
      function Price2(baseCurrency, quoteCurrency, denominator, numerator) {
        var _this;
        _this = _Fraction.call(this, numerator, denominator) || this;
        _this.baseCurrency = baseCurrency;
        _this.quoteCurrency = quoteCurrency;
        _this.scalar = new Fraction(JSBI.exponentiate(TEN, JSBI.BigInt(baseCurrency.decimals)), JSBI.exponentiate(TEN, JSBI.BigInt(quoteCurrency.decimals)));
        return _this;
      }
      Price2.fromRoute = function fromRoute(route) {
        var prices = [];
        for (var _iterator = _createForOfIteratorHelperLoose(route.pairs.entries()), _step; !(_step = _iterator()).done; ) {
          var _step$value = _step.value, i = _step$value[0], pair = _step$value[1];
          prices.push(route.path[i].equals(pair.token0) ? new Price2(pair.reserve0.token, pair.reserve1.token, pair.reserve0.raw, pair.reserve1.raw) : new Price2(pair.reserve1.token, pair.reserve0.token, pair.reserve1.raw, pair.reserve0.raw));
        }
        return prices.slice(1).reduce(function(accumulator, currentValue) {
          return accumulator.multiply(currentValue);
        }, prices[0]);
      };
      var _proto = Price2.prototype;
      _proto.invert = function invert() {
        return new Price2(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator);
      };
      _proto.multiply = function multiply(other) {
        !currencyEquals(this.quoteCurrency, other.baseCurrency) ? invariant(false, "TOKEN") : void 0;
        var fraction = _Fraction.prototype.multiply.call(this, other);
        return new Price2(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator);
      };
      _proto.quote = function quote(currencyAmount) {
        !currencyEquals(currencyAmount.token, this.baseCurrency) ? invariant(false, "TOKEN") : void 0;
        return new TokenAmount(this.quoteCurrency, _Fraction.prototype.multiply.call(this, currencyAmount.raw).quotient);
      };
      _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
        if (significantDigits === void 0) {
          significantDigits = 6;
        }
        return this.adjusted.toSignificant(significantDigits, format, rounding);
      };
      _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
        if (decimalPlaces === void 0) {
          decimalPlaces = 4;
        }
        return this.adjusted.toFixed(decimalPlaces, format, rounding);
      };
      _createClass(Price2, [{
        key: "raw",
        get: function get() {
          return new Fraction(this.numerator, this.denominator);
        }
      }, {
        key: "adjusted",
        get: function get() {
          return _Fraction.prototype.multiply.call(this, this.scalar);
        }
      }]);
      return Price2;
    }(Fraction);
    var PAIR_ADDRESS_CACHE = {};
    var Pair = function() {
      function Pair2(tokenAmountA, tokenAmountB) {
        var tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];
        this.liquidityToken = new Token(tokenAmounts[0].token.chainId, Pair2.getAddress(tokenAmounts[0].token, tokenAmounts[1].token), 18, "10k Swap LP", "10k Swap");
        this.tokenAmounts = tokenAmounts;
      }
      Pair2.getAddress = function getAddress(tokenA, tokenB) {
        var _PAIR_ADDRESS_CACHE, _PAIR_ADDRESS_CACHE$t;
        var tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];
        if (((_PAIR_ADDRESS_CACHE = PAIR_ADDRESS_CACHE) === null || _PAIR_ADDRESS_CACHE === void 0 ? void 0 : (_PAIR_ADDRESS_CACHE$t = _PAIR_ADDRESS_CACHE[tokens[0].address]) === null || _PAIR_ADDRESS_CACHE$t === void 0 ? void 0 : _PAIR_ADDRESS_CACHE$t[tokens[1].address]) === void 0) {
          var _PAIR_ADDRESS_CACHE2, _extends2, _extends3;
          PAIR_ADDRESS_CACHE = _extends({}, PAIR_ADDRESS_CACHE, (_extends3 = {}, _extends3[tokens[0].address] = _extends({}, (_PAIR_ADDRESS_CACHE2 = PAIR_ADDRESS_CACHE) === null || _PAIR_ADDRESS_CACHE2 === void 0 ? void 0 : _PAIR_ADDRESS_CACHE2[tokens[0].address], (_extends2 = {}, _extends2[tokens[1].address] = getPairAddress(tokenA, tokenB), _extends2)), _extends3));
        }
        return PAIR_ADDRESS_CACHE[tokens[0].address][tokens[1].address];
      };
      var _proto = Pair2.prototype;
      _proto.involvesToken = function involvesToken(token) {
        return token.equals(this.token0) || token.equals(this.token1);
      };
      _proto.priceOf = function priceOf(token) {
        !this.involvesToken(token) ? invariant(false, "TOKEN") : void 0;
        return token.equals(this.token0) ? this.token0Price : this.token1Price;
      };
      _proto.reserveOf = function reserveOf(token) {
        !this.involvesToken(token) ? invariant(false, "TOKEN") : void 0;
        return token.equals(this.token0) ? this.reserve0 : this.reserve1;
      };
      _proto.getOutputAmount = function getOutputAmount(inputAmount) {
        !this.involvesToken(inputAmount.token) ? invariant(false, "TOKEN") : void 0;
        if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO)) {
          throw new InsufficientReservesError();
        }
        var inputReserve = this.reserveOf(inputAmount.token);
        var outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0);
        var inputAmountWithFee = JSBI.multiply(inputAmount.raw, FEES_NUMERATOR);
        var numerator = JSBI.multiply(inputAmountWithFee, outputReserve.raw);
        var denominator = JSBI.add(JSBI.multiply(inputReserve.raw, FEES_DENOMINATOR), inputAmountWithFee);
        var outputAmount = new TokenAmount(inputAmount.token.equals(this.token0) ? this.token1 : this.token0, JSBI.divide(numerator, denominator));
        if (JSBI.equal(outputAmount.raw, ZERO)) {
          throw new InsufficientInputAmountError();
        }
        return [outputAmount, new Pair2(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];
      };
      _proto.getInputAmount = function getInputAmount(outputAmount) {
        !this.involvesToken(outputAmount.token) ? invariant(false, "TOKEN") : void 0;
        if (JSBI.equal(this.reserve0.raw, ZERO) || JSBI.equal(this.reserve1.raw, ZERO) || JSBI.greaterThanOrEqual(outputAmount.raw, this.reserveOf(outputAmount.token).raw)) {
          throw new InsufficientReservesError();
        }
        var outputReserve = this.reserveOf(outputAmount.token);
        var inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0);
        var numerator = JSBI.multiply(JSBI.multiply(inputReserve.raw, outputAmount.raw), FEES_DENOMINATOR);
        var denominator = JSBI.multiply(JSBI.subtract(outputReserve.raw, outputAmount.raw), FEES_NUMERATOR);
        var inputAmount = new TokenAmount(outputAmount.token.equals(this.token0) ? this.token1 : this.token0, JSBI.add(JSBI.divide(numerator, denominator), ONE));
        return [inputAmount, new Pair2(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];
      };
      _proto.getLiquidityMinted = function getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB) {
        !totalSupply.token.equals(this.liquidityToken) ? invariant(false, "LIQUIDITY") : void 0;
        var tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];
        !(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1)) ? invariant(false, "TOKEN") : void 0;
        var liquidity;
        if (JSBI.equal(totalSupply.raw, ZERO)) {
          liquidity = JSBI.subtract(sqrt(JSBI.multiply(tokenAmounts[0].raw, tokenAmounts[1].raw)), MINIMUM_LIQUIDITY);
        } else {
          var amount0 = JSBI.divide(JSBI.multiply(tokenAmounts[0].raw, totalSupply.raw), this.reserve0.raw);
          var amount1 = JSBI.divide(JSBI.multiply(tokenAmounts[1].raw, totalSupply.raw), this.reserve1.raw);
          liquidity = JSBI.lessThanOrEqual(amount0, amount1) ? amount0 : amount1;
        }
        if (!JSBI.greaterThan(liquidity, ZERO)) {
          throw new InsufficientInputAmountError();
        }
        return new TokenAmount(this.liquidityToken, liquidity);
      };
      _proto.getLiquidityValue = function getLiquidityValue(token, totalSupply, liquidity, feeOn, kLast) {
        if (feeOn === void 0) {
          feeOn = false;
        }
        !this.involvesToken(token) ? invariant(false, "TOKEN") : void 0;
        !totalSupply.token.equals(this.liquidityToken) ? invariant(false, "TOTAL_SUPPLY") : void 0;
        !liquidity.token.equals(this.liquidityToken) ? invariant(false, "LIQUIDITY") : void 0;
        !JSBI.lessThanOrEqual(liquidity.raw, totalSupply.raw) ? invariant(false, "LIQUIDITY") : void 0;
        var totalSupplyAdjusted;
        if (!feeOn) {
          totalSupplyAdjusted = totalSupply;
        } else {
          !!!kLast ? invariant(false, "K_LAST") : void 0;
          var kLastParsed = parseBigintIsh(kLast);
          if (!JSBI.equal(kLastParsed, ZERO)) {
            var rootK = sqrt(JSBI.multiply(this.reserve0.raw, this.reserve1.raw));
            var rootKLast = sqrt(kLastParsed);
            if (JSBI.greaterThan(rootK, rootKLast)) {
              var numerator = JSBI.multiply(totalSupply.raw, JSBI.subtract(rootK, rootKLast));
              var denominator = JSBI.add(JSBI.multiply(rootK, FIVE), rootKLast);
              var feeLiquidity = JSBI.divide(numerator, denominator);
              totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity));
            } else {
              totalSupplyAdjusted = totalSupply;
            }
          } else {
            totalSupplyAdjusted = totalSupply;
          }
        }
        return new TokenAmount(token, JSBI.divide(JSBI.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw));
      };
      _createClass(Pair2, [{
        key: "token0Price",
        get: function get() {
          return new Price(this.token0, this.token1, this.tokenAmounts[0].raw, this.tokenAmounts[1].raw);
        }
      }, {
        key: "token1Price",
        get: function get() {
          return new Price(this.token1, this.token0, this.tokenAmounts[1].raw, this.tokenAmounts[0].raw);
        }
      }, {
        key: "chainId",
        get: function get() {
          return this.token0.chainId;
        }
      }, {
        key: "token0",
        get: function get() {
          return this.tokenAmounts[0].token;
        }
      }, {
        key: "token1",
        get: function get() {
          return this.tokenAmounts[1].token;
        }
      }, {
        key: "reserve0",
        get: function get() {
          return this.tokenAmounts[0];
        }
      }, {
        key: "reserve1",
        get: function get() {
          return this.tokenAmounts[1];
        }
      }]);
      return Pair2;
    }();
    var Route = function() {
      function Route2(pairs, input, output) {
        !(pairs.length > 0) ? invariant(false, "PAIRS") : void 0;
        !pairs.every(function(pair2) {
          return pair2.chainId === pairs[0].chainId;
        }) ? invariant(false, "CHAIN_IDS") : void 0;
        !(input instanceof Token && pairs[0].involvesToken(input) || "INPUT") ? invariant(false) : void 0;
        !(typeof output === "undefined" || output instanceof Token && pairs[pairs.length - 1].involvesToken(output)) ? invariant(false, "OUTPUT") : void 0;
        var path = [input];
        for (var _iterator = _createForOfIteratorHelperLoose(pairs.entries()), _step; !(_step = _iterator()).done; ) {
          var _step$value = _step.value, i = _step$value[0], pair = _step$value[1];
          var currentInput = path[i];
          !(currentInput.equals(pair.token0) || currentInput.equals(pair.token1)) ? invariant(false, "PATH") : void 0;
          var _output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0;
          path.push(_output);
        }
        this.pairs = pairs;
        this.path = path;
        this.midPrice = Price.fromRoute(this);
        this.input = input;
        this.output = output !== null && output !== void 0 ? output : path[path.length - 1];
      }
      _createClass(Route2, [{
        key: "chainId",
        get: function get() {
          return this.pairs[0].chainId;
        }
      }]);
      return Route2;
    }();
    var _100_PERCENT = new Fraction(_100);
    var Percent = function(_Fraction) {
      _inheritsLoose(Percent2, _Fraction);
      function Percent2() {
        return _Fraction.apply(this, arguments) || this;
      }
      var _proto = Percent2.prototype;
      _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
        if (significantDigits === void 0) {
          significantDigits = 5;
        }
        return this.multiply(_100_PERCENT).toSignificant(significantDigits, format, rounding);
      };
      _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
        if (decimalPlaces === void 0) {
          decimalPlaces = 2;
        }
        return this.multiply(_100_PERCENT).toFixed(decimalPlaces, format, rounding);
      };
      return Percent2;
    }(Fraction);
    function computePriceImpact(midPrice, inputAmount, outputAmount) {
      var exactQuote = midPrice.raw.multiply(inputAmount.raw);
      var slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote);
      return new Percent(slippage.numerator, slippage.denominator);
    }
    function inputOutputComparator(a, b) {
      !currencyEquals(a.inputAmount.token, b.inputAmount.token) ? invariant(false, "INPUT_CURRENCY") : void 0;
      !currencyEquals(a.outputAmount.token, b.outputAmount.token) ? invariant(false, "OUTPUT_CURRENCY") : void 0;
      if (a.outputAmount.equalTo(b.outputAmount)) {
        if (a.inputAmount.equalTo(b.inputAmount)) {
          return 0;
        }
        if (a.inputAmount.lessThan(b.inputAmount)) {
          return -1;
        } else {
          return 1;
        }
      } else {
        if (a.outputAmount.lessThan(b.outputAmount)) {
          return 1;
        } else {
          return -1;
        }
      }
    }
    function tradeComparator(a, b) {
      var ioComp = inputOutputComparator(a, b);
      if (ioComp !== 0) {
        return ioComp;
      }
      if (a.priceImpact.lessThan(b.priceImpact)) {
        return -1;
      } else if (a.priceImpact.greaterThan(b.priceImpact)) {
        return 1;
      }
      return a.route.path.length - b.route.path.length;
    }
    var Trade = function() {
      function Trade2(route, amount, tradeType) {
        var amounts = new Array(route.path.length);
        var nextPairs = new Array(route.pairs.length);
        if (tradeType === exports.TradeType.EXACT_INPUT) {
          !currencyEquals(amount.token, route.input) ? invariant(false, "INPUT") : void 0;
          amounts[0] = amount;
          for (var i = 0; i < route.path.length - 1; i++) {
            var pair = route.pairs[i];
            var _pair$getOutputAmount = pair.getOutputAmount(amounts[i]), outputAmount = _pair$getOutputAmount[0], nextPair = _pair$getOutputAmount[1];
            amounts[i + 1] = outputAmount;
            nextPairs[i] = nextPair;
          }
        } else {
          !currencyEquals(amount.token, route.output) ? invariant(false, "OUTPUT") : void 0;
          amounts[amounts.length - 1] = amount;
          for (var _i = route.path.length - 1; _i > 0; _i--) {
            var _pair = route.pairs[_i - 1];
            var _pair$getInputAmount = _pair.getInputAmount(amounts[_i]), inputAmount = _pair$getInputAmount[0], _nextPair = _pair$getInputAmount[1];
            amounts[_i - 1] = inputAmount;
            nextPairs[_i - 1] = _nextPair;
          }
        }
        this.route = route;
        this.tradeType = tradeType;
        this.inputAmount = tradeType === exports.TradeType.EXACT_INPUT ? amount : amounts[0];
        this.outputAmount = tradeType === exports.TradeType.EXACT_OUTPUT ? amount : amounts[amounts.length - 1];
        this.executionPrice = new Price(this.inputAmount.token, this.outputAmount.token, this.inputAmount.raw, this.outputAmount.raw);
        this.nextMidPrice = Price.fromRoute(new Route(nextPairs, route.input));
        this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount);
      }
      Trade2.exactIn = function exactIn(route, amountIn) {
        return new Trade2(route, amountIn, exports.TradeType.EXACT_INPUT);
      };
      Trade2.exactOut = function exactOut(route, amountOut) {
        return new Trade2(route, amountOut, exports.TradeType.EXACT_OUTPUT);
      };
      var _proto = Trade2.prototype;
      _proto.minimumAmountOut = function minimumAmountOut(slippageTolerance) {
        !!slippageTolerance.lessThan(ZERO) ? invariant(false, "SLIPPAGE_TOLERANCE") : void 0;
        if (this.tradeType === exports.TradeType.EXACT_OUTPUT) {
          return this.outputAmount;
        } else {
          var slippageAdjustedAmountOut = new Fraction(ONE).add(slippageTolerance).invert().multiply(this.outputAmount.raw).quotient;
          return new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut);
        }
      };
      _proto.maximumAmountIn = function maximumAmountIn(slippageTolerance) {
        !!slippageTolerance.lessThan(ZERO) ? invariant(false, "SLIPPAGE_TOLERANCE") : void 0;
        if (this.tradeType === exports.TradeType.EXACT_INPUT) {
          return this.inputAmount;
        } else {
          var slippageAdjustedAmountIn = new Fraction(ONE).add(slippageTolerance).multiply(this.inputAmount.raw).quotient;
          return new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn);
        }
      };
      Trade2.bestTradeExactIn = function bestTradeExactIn(pairs, currencyAmountIn, currencyOut, _temp, currentPairs, originalAmountIn, bestTrades) {
        var _ref = _temp === void 0 ? {} : _temp, _ref$maxNumResults = _ref.maxNumResults, maxNumResults = _ref$maxNumResults === void 0 ? 3 : _ref$maxNumResults, _ref$maxHops = _ref.maxHops, maxHops = _ref$maxHops === void 0 ? 3 : _ref$maxHops;
        if (currentPairs === void 0) {
          currentPairs = [];
        }
        if (originalAmountIn === void 0) {
          originalAmountIn = currencyAmountIn;
        }
        if (bestTrades === void 0) {
          bestTrades = [];
        }
        !(pairs.length > 0) ? invariant(false, "PAIRS") : void 0;
        !(maxHops > 0) ? invariant(false, "MAX_HOPS") : void 0;
        !(originalAmountIn === currencyAmountIn || currentPairs.length > 0) ? invariant(false, "INVALID_RECURSION") : void 0;
        var chainId = currencyAmountIn instanceof TokenAmount ? currencyAmountIn.token.chainId : currencyOut instanceof Token ? currencyOut.chainId : void 0;
        !(chainId !== void 0) ? invariant(false, "CHAIN_ID") : void 0;
        var amountIn = currencyAmountIn;
        var tokenOut = currencyOut;
        for (var i = 0; i < pairs.length; i++) {
          var pair = pairs[i];
          if (!pair.token0.equals(amountIn.token) && !pair.token1.equals(amountIn.token))
            continue;
          if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO))
            continue;
          var amountOut = void 0;
          try {
            ;
            var _pair$getOutputAmount2 = pair.getOutputAmount(amountIn);
            amountOut = _pair$getOutputAmount2[0];
          } catch (error) {
            if (error.isInsufficientInputAmountError) {
              continue;
            }
            throw error;
          }
          if (amountOut.token.equals(tokenOut)) {
            sortedInsert(bestTrades, new Trade2(new Route([].concat(currentPairs, [pair]), originalAmountIn.token, currencyOut), originalAmountIn, exports.TradeType.EXACT_INPUT), maxNumResults, tradeComparator);
          } else if (maxHops > 1 && pairs.length > 1) {
            var pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length));
            Trade2.bestTradeExactIn(pairsExcludingThisPair, amountOut, currencyOut, {
              maxNumResults,
              maxHops: maxHops - 1
            }, [].concat(currentPairs, [pair]), originalAmountIn, bestTrades);
          }
        }
        return bestTrades;
      };
      Trade2.bestTradeExactOut = function bestTradeExactOut(pairs, currencyIn, currencyAmountOut, _temp2, currentPairs, originalAmountOut, bestTrades) {
        var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$maxNumResults = _ref2.maxNumResults, maxNumResults = _ref2$maxNumResults === void 0 ? 3 : _ref2$maxNumResults, _ref2$maxHops = _ref2.maxHops, maxHops = _ref2$maxHops === void 0 ? 3 : _ref2$maxHops;
        if (currentPairs === void 0) {
          currentPairs = [];
        }
        if (originalAmountOut === void 0) {
          originalAmountOut = currencyAmountOut;
        }
        if (bestTrades === void 0) {
          bestTrades = [];
        }
        !(pairs.length > 0) ? invariant(false, "PAIRS") : void 0;
        !(maxHops > 0) ? invariant(false, "MAX_HOPS") : void 0;
        !(originalAmountOut === currencyAmountOut || currentPairs.length > 0) ? invariant(false, "INVALID_RECURSION") : void 0;
        var chainId = currencyAmountOut instanceof TokenAmount ? currencyAmountOut.token.chainId : currencyIn instanceof Token ? currencyIn.chainId : void 0;
        !(chainId !== void 0) ? invariant(false, "CHAIN_ID") : void 0;
        var amountOut = currencyAmountOut;
        var tokenIn = currencyIn;
        for (var i = 0; i < pairs.length; i++) {
          var pair = pairs[i];
          if (!pair.token0.equals(amountOut.token) && !pair.token1.equals(amountOut.token))
            continue;
          if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO))
            continue;
          var amountIn = void 0;
          try {
            ;
            var _pair$getInputAmount2 = pair.getInputAmount(amountOut);
            amountIn = _pair$getInputAmount2[0];
          } catch (error) {
            if (error.isInsufficientReservesError) {
              continue;
            }
            throw error;
          }
          if (amountIn.token.equals(tokenIn)) {
            sortedInsert(bestTrades, new Trade2(new Route([pair].concat(currentPairs), currencyIn, originalAmountOut.token), originalAmountOut, exports.TradeType.EXACT_OUTPUT), maxNumResults, tradeComparator);
          } else if (maxHops > 1 && pairs.length > 1) {
            var pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length));
            Trade2.bestTradeExactOut(pairsExcludingThisPair, currencyIn, amountIn, {
              maxNumResults,
              maxHops: maxHops - 1
            }, [pair].concat(currentPairs), originalAmountOut, bestTrades);
          }
        }
        return bestTrades;
      };
      return Trade2;
    }();
    var Router = function() {
      function Router2() {
      }
      Router2.swapCallParameters = function swapCallParameters(trade, options) {
        !(options.ttl > 0) ? invariant(false, "TTL") : void 0;
        var to = options.recipient;
        var amountIn = uint256.bnToUint256(trade.maximumAmountIn(options.allowedSlippage).raw.toString());
        var amountOut = uint256.bnToUint256(trade.minimumAmountOut(options.allowedSlippage).raw.toString());
        var path = trade.route.path.map(function(token) {
          return token.address;
        });
        var deadline = "" + (Math.floor(new Date().getTime() / 1e3) + options.ttl).toString();
        var useFeeOnTransfer = Boolean(options.feeOnTransfer);
        var methodName;
        var args;
        switch (trade.tradeType) {
          case exports.TradeType.EXACT_INPUT:
            methodName = useFeeOnTransfer ? "swapExactTokensForTokensSupportingFeeOnTransferTokens" : "swapExactTokensForTokens";
            args = [amountIn.low.toString(), amountIn.high.toString(), amountOut.low.toString(), amountOut.high.toString(), path.length + ""].concat(path, [to, deadline]);
            break;
          case exports.TradeType.EXACT_OUTPUT:
            !!useFeeOnTransfer ? invariant(false, "EXACT_OUT_FOT") : void 0;
            methodName = "swapTokensForExactTokens";
            args = [amountOut.low.toString(), amountOut.high.toString(), amountIn.low.toString(), amountIn.high.toString(), path.length + ""].concat(path, [to, deadline]);
            break;
        }
        return {
          methodName,
          args
        };
      };
      return Router2;
    }();
    var l0kPairAbi = [
      {
        members: [
          {
            name: "low",
            offset: 0,
            type: "felt"
          },
          {
            name: "high",
            offset: 1,
            type: "felt"
          }
        ],
        name: "Uint256",
        size: 2,
        type: "struct"
      },
      {
        data: [
          {
            name: "from_",
            type: "felt"
          },
          {
            name: "to",
            type: "felt"
          },
          {
            name: "value",
            type: "Uint256"
          }
        ],
        keys: [],
        name: "Transfer",
        type: "event"
      },
      {
        data: [
          {
            name: "owner",
            type: "felt"
          },
          {
            name: "spender",
            type: "felt"
          },
          {
            name: "value",
            type: "Uint256"
          }
        ],
        keys: [],
        name: "Approval",
        type: "event"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            name: "name",
            type: "felt"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            name: "symbol",
            type: "felt"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            name: "totalSupply",
            type: "Uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            name: "decimals",
            type: "felt"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "account",
            type: "felt"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            name: "balance",
            type: "Uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "owner",
            type: "felt"
          },
          {
            name: "spender",
            type: "felt"
          }
        ],
        name: "allowance",
        outputs: [
          {
            name: "remaining",
            type: "Uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "recipient",
            type: "felt"
          },
          {
            name: "amount",
            type: "Uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            name: "success",
            type: "felt"
          }
        ],
        type: "function"
      },
      {
        inputs: [
          {
            name: "sender",
            type: "felt"
          },
          {
            name: "recipient",
            type: "felt"
          },
          {
            name: "amount",
            type: "Uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            name: "success",
            type: "felt"
          }
        ],
        type: "function"
      },
      {
        inputs: [
          {
            name: "spender",
            type: "felt"
          },
          {
            name: "amount",
            type: "Uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            name: "success",
            type: "felt"
          }
        ],
        type: "function"
      },
      {
        inputs: [
          {
            name: "spender",
            type: "felt"
          },
          {
            name: "added_value",
            type: "Uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            name: "success",
            type: "felt"
          }
        ],
        type: "function"
      },
      {
        inputs: [
          {
            name: "spender",
            type: "felt"
          },
          {
            name: "subtracted_value",
            type: "Uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            name: "success",
            type: "felt"
          }
        ],
        type: "function"
      },
      {
        data: [
          {
            name: "sender",
            type: "felt"
          },
          {
            name: "amount0",
            type: "Uint256"
          },
          {
            name: "amount1",
            type: "Uint256"
          }
        ],
        keys: [],
        name: "Mint",
        type: "event"
      },
      {
        data: [
          {
            name: "sender",
            type: "felt"
          },
          {
            name: "amount0",
            type: "Uint256"
          },
          {
            name: "amount1",
            type: "Uint256"
          },
          {
            name: "to",
            type: "felt"
          }
        ],
        keys: [],
        name: "Burn",
        type: "event"
      },
      {
        data: [
          {
            name: "sender",
            type: "felt"
          },
          {
            name: "amount0In",
            type: "Uint256"
          },
          {
            name: "amount1In",
            type: "Uint256"
          },
          {
            name: "amount0Out",
            type: "Uint256"
          },
          {
            name: "amount1Out",
            type: "Uint256"
          },
          {
            name: "to",
            type: "felt"
          }
        ],
        keys: [],
        name: "Swap",
        type: "event"
      },
      {
        data: [
          {
            name: "reserve0",
            type: "felt"
          },
          {
            name: "reserve1",
            type: "felt"
          }
        ],
        keys: [],
        name: "Sync",
        type: "event"
      },
      {
        inputs: [],
        name: "constructor",
        outputs: [],
        type: "constructor"
      },
      {
        inputs: [],
        name: "MINIMUM_LIQUIDITY",
        outputs: [
          {
            name: "MINIMUM_LIQUIDITY",
            type: "felt"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "factory",
        outputs: [
          {
            name: "factory",
            type: "felt"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "token0",
        outputs: [
          {
            name: "token0",
            type: "felt"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "token1",
        outputs: [
          {
            name: "token1",
            type: "felt"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "blockTimestampLast",
        outputs: [
          {
            name: "blockTimestampLast",
            type: "felt"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "price0CumulativeLast",
        outputs: [
          {
            name: "price0CumulativeLast",
            type: "Uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "price1CumulativeLast",
        outputs: [
          {
            name: "price1CumulativeLast",
            type: "Uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "kLast",
        outputs: [
          {
            name: "kLast",
            type: "Uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "getReserves",
        outputs: [
          {
            name: "reserve0",
            type: "felt"
          },
          {
            name: "reserve1",
            type: "felt"
          },
          {
            name: "blockTimestampLast",
            type: "felt"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "token0",
            type: "felt"
          },
          {
            name: "token1",
            type: "felt"
          }
        ],
        name: "initialize",
        outputs: [],
        type: "function"
      },
      {
        inputs: [
          {
            name: "to",
            type: "felt"
          }
        ],
        name: "mint",
        outputs: [
          {
            name: "liquidity",
            type: "Uint256"
          }
        ],
        type: "function"
      },
      {
        inputs: [
          {
            name: "to",
            type: "felt"
          }
        ],
        name: "burn",
        outputs: [
          {
            name: "amount0",
            type: "Uint256"
          },
          {
            name: "amount1",
            type: "Uint256"
          }
        ],
        type: "function"
      },
      {
        inputs: [
          {
            name: "amount0Out",
            type: "Uint256"
          },
          {
            name: "amount1Out",
            type: "Uint256"
          },
          {
            name: "to",
            type: "felt"
          }
        ],
        name: "swap",
        outputs: [],
        type: "function"
      },
      {
        inputs: [
          {
            name: "to",
            type: "felt"
          }
        ],
        name: "skim",
        outputs: [],
        type: "function"
      },
      {
        inputs: [],
        name: "sync",
        outputs: [],
        type: "function"
      }
    ];
    var ERC20 = [
      {
        members: [
          {
            name: "low",
            offset: 0,
            type: "felt"
          },
          {
            name: "high",
            offset: 1,
            type: "felt"
          }
        ],
        name: "Uint256",
        size: 2,
        type: "struct"
      },
      {
        data: [
          {
            name: "from_",
            type: "felt"
          },
          {
            name: "to",
            type: "felt"
          },
          {
            name: "value",
            type: "Uint256"
          }
        ],
        keys: [],
        name: "Transfer",
        type: "event"
      },
      {
        data: [
          {
            name: "owner",
            type: "felt"
          },
          {
            name: "spender",
            type: "felt"
          },
          {
            name: "value",
            type: "Uint256"
          }
        ],
        keys: [],
        name: "Approval",
        type: "event"
      },
      {
        data: [
          {
            name: "previousOwner",
            type: "felt"
          },
          {
            name: "newOwner",
            type: "felt"
          }
        ],
        keys: [],
        name: "OwnershipTransferred",
        type: "event"
      },
      {
        inputs: [
          {
            name: "name",
            type: "felt"
          },
          {
            name: "symbol",
            type: "felt"
          }
        ],
        name: "constructor",
        outputs: [],
        type: "constructor"
      },
      {
        inputs: [],
        name: "name",
        outputs: [
          {
            name: "name",
            type: "felt"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "symbol",
        outputs: [
          {
            name: "symbol",
            type: "felt"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "totalSupply",
        outputs: [
          {
            name: "totalSupply",
            type: "Uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [],
        name: "decimals",
        outputs: [
          {
            name: "decimals",
            type: "felt"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "account",
            type: "felt"
          }
        ],
        name: "balanceOf",
        outputs: [
          {
            name: "balance",
            type: "Uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "owner",
            type: "felt"
          },
          {
            name: "spender",
            type: "felt"
          }
        ],
        name: "allowance",
        outputs: [
          {
            name: "remaining",
            type: "Uint256"
          }
        ],
        stateMutability: "view",
        type: "function"
      },
      {
        inputs: [
          {
            name: "recipient",
            type: "felt"
          },
          {
            name: "amount",
            type: "Uint256"
          }
        ],
        name: "transfer",
        outputs: [
          {
            name: "success",
            type: "felt"
          }
        ],
        type: "function"
      },
      {
        inputs: [
          {
            name: "sender",
            type: "felt"
          },
          {
            name: "recipient",
            type: "felt"
          },
          {
            name: "amount",
            type: "Uint256"
          }
        ],
        name: "transferFrom",
        outputs: [
          {
            name: "success",
            type: "felt"
          }
        ],
        type: "function"
      },
      {
        inputs: [
          {
            name: "spender",
            type: "felt"
          },
          {
            name: "amount",
            type: "Uint256"
          }
        ],
        name: "approve",
        outputs: [
          {
            name: "success",
            type: "felt"
          }
        ],
        type: "function"
      },
      {
        inputs: [
          {
            name: "spender",
            type: "felt"
          },
          {
            name: "added_value",
            type: "Uint256"
          }
        ],
        name: "increaseAllowance",
        outputs: [
          {
            name: "success",
            type: "felt"
          }
        ],
        type: "function"
      },
      {
        inputs: [
          {
            name: "spender",
            type: "felt"
          },
          {
            name: "subtracted_value",
            type: "Uint256"
          }
        ],
        name: "decreaseAllowance",
        outputs: [
          {
            name: "success",
            type: "felt"
          }
        ],
        type: "function"
      },
      {
        inputs: [
          {
            name: "newOwner",
            type: "felt"
          }
        ],
        name: "transferOwnership",
        outputs: [],
        type: "function"
      },
      {
        inputs: [],
        name: "renounceOwnership",
        outputs: [],
        type: "function"
      },
      {
        inputs: [
          {
            name: "to",
            type: "felt"
          },
          {
            name: "amount",
            type: "Uint256"
          }
        ],
        name: "mint",
        outputs: [],
        type: "function"
      }
    ];
    var _NetworkNames;
    var _TOKEN_DECIMALS_CACHE;
    var getDecimals = function getDecimals2(chainId, address2, provider) {
      try {
        var _TOKEN_DECIMALS_CACHE2, _TOKEN_DECIMALS_CACHE3;
        if (typeof ((_TOKEN_DECIMALS_CACHE2 = TOKEN_DECIMALS_CACHE) === null || _TOKEN_DECIMALS_CACHE2 === void 0 ? void 0 : (_TOKEN_DECIMALS_CACHE3 = _TOKEN_DECIMALS_CACHE2[chainId]) === null || _TOKEN_DECIMALS_CACHE3 === void 0 ? void 0 : _TOKEN_DECIMALS_CACHE3[address2]) === "number") {
          return Promise.resolve(TOKEN_DECIMALS_CACHE[chainId][address2]);
        }
        var contract = new starknet.Contract(ERC20, address2, provider);
        return Promise.resolve(contract.call("decimals")).then(function(_ref2) {
          var _TOKEN_DECIMALS_CACHE4, _extends2, _extends3;
          var decimals = _ref2.decimals;
          TOKEN_DECIMALS_CACHE = _extends({}, TOKEN_DECIMALS_CACHE, (_extends3 = {}, _extends3[chainId] = _extends({}, (_TOKEN_DECIMALS_CACHE4 = TOKEN_DECIMALS_CACHE) === null || _TOKEN_DECIMALS_CACHE4 === void 0 ? void 0 : _TOKEN_DECIMALS_CACHE4[chainId], (_extends2 = {}, _extends2[address2] = decimals.toNumber(), _extends2)), _extends3));
          return decimals.toNumber();
        });
      } catch (e) {
        return Promise.reject(e);
      }
    };
    var NetworkNames = (_NetworkNames = {}, _NetworkNames[constants.StarknetChainId.MAINNET] = "mainnet-alpha", _NetworkNames[constants.StarknetChainId.TESTNET] = "goerli-alpha", _NetworkNames);
    var TOKEN_DECIMALS_CACHE = (_TOKEN_DECIMALS_CACHE = {}, _TOKEN_DECIMALS_CACHE[constants.StarknetChainId.TESTNET] = {
      "0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7": 18
    }, _TOKEN_DECIMALS_CACHE);
    var Fetcher = function() {
      function Fetcher2() {
      }
      Fetcher2.fetchTokenData = function fetchTokenData(chainId, address2, provider, symbol, name) {
        try {
          if (provider === void 0)
            provider = new starknet.Provider({
              network: NetworkNames[chainId]
            });
          return Promise.resolve(getDecimals(chainId, address2, provider)).then(function(parsedDecimals) {
            return new Token(chainId, address2, parsedDecimals, symbol, name);
          });
        } catch (e) {
          return Promise.reject(e);
        }
      };
      Fetcher2.fetchPairData = function fetchPairData(tokenA, tokenB, provider) {
        try {
          if (provider === void 0)
            provider = new starknet.Provider({
              network: NetworkNames[tokenA.chainId]
            });
          !(tokenA.chainId === tokenB.chainId) ? true ? invariant(false, "CHAIN_ID") : invariant(false) : void 0;
          var address2 = Pair.getAddress(tokenA, tokenB);
          return Promise.resolve(new starknet.Contract(l0kPairAbi, address2, provider).call("getReserves", [])).then(function(_ref) {
            var reserve0 = _ref.reserve0, reserve1 = _ref.reserve1;
            var balances = tokenA.sortsBefore(tokenB) ? [reserve0, reserve1] : [reserve0, reserve1];
            return new Pair(new TokenAmount(tokenA, balances[0].toString()), new TokenAmount(tokenB, balances[1].toString()));
          });
        } catch (e) {
          return Promise.reject(e);
        }
      };
      return Fetcher2;
    }();
    exports.JSBI = JSBI;
    Object.defineProperty(exports, "ChainId", {
      enumerable: true,
      get: function() {
        return constants.StarknetChainId;
      }
    });
    exports.CONTRACT_ADDRESS_PREFIX = CONTRACT_ADDRESS_PREFIX;
    exports.FACTORY_ADDRESSES = FACTORY_ADDRESSES;
    exports.FEES_DENOMINATOR = FEES_DENOMINATOR;
    exports.FEES_NUMERATOR = FEES_NUMERATOR;
    exports.FIVE = FIVE;
    exports.Fetcher = Fetcher;
    exports.Fraction = Fraction;
    exports.InsufficientInputAmountError = InsufficientInputAmountError;
    exports.InsufficientReservesError = InsufficientReservesError;
    exports.MINIMUM_LIQUIDITY = MINIMUM_LIQUIDITY;
    exports.ONE = ONE;
    exports.PAIR_CONTRACT_CLASS_HASH = PAIR_CONTRACT_CLASS_HASH;
    exports.Pair = Pair;
    exports.Percent = Percent;
    exports.Price = Price;
    exports.Route = Route;
    exports.Router = Router;
    exports.SOLIDITY_TYPE_MAXIMA = SOLIDITY_TYPE_MAXIMA;
    exports.TEN = TEN;
    exports.THREE = THREE;
    exports.TWO = TWO;
    exports.Token = Token;
    exports.TokenAmount = TokenAmount;
    exports.Trade = Trade;
    exports.ZERO = ZERO;
    exports._100 = _100;
    exports.currencyEquals = currencyEquals;
    exports.getPairAddress = getPairAddress;
    exports.inputOutputComparator = inputOutputComparator;
    exports.isEqualAddress = isEqualAddress;
    exports.parseBigintIsh = parseBigintIsh;
    exports.sortedInsert = sortedInsert;
    exports.sortsBefore = sortsBefore;
    exports.sqrt = sqrt;
    exports.tradeComparator = tradeComparator;
    exports.validateAndParseAddress = validateAndParseAddress;
    exports.validateSolidityTypeInstance = validateSolidityTypeInstance;
  }
});

// node_modules/l0k_swap-sdk/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/l0k_swap-sdk/dist/index.js"(exports, module) {
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_l0k_swap_sdk_cjs_development();
    }
  }
});
export default require_dist2();
/*! decimal.js-light v2.5.1 https://github.com/MikeMcl/decimal.js-light/LICENCE */
//# sourceMappingURL=l0k_swap-sdk.js.map
